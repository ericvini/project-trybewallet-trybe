{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst isKeyframeSelector = require('../../utils/isKeyframeSelector');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');\n\nconst parseSelector = require('../../utils/parseSelector');\n\nconst report = require('../../utils/report');\n\nconst resolveNestedSelector = require('postcss-resolve-nested-selector');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-class-pattern';\nconst messages = ruleMessages(ruleName, {\n  expected: (selectorValue, pattern) => `Expected class selector \".${selectorValue}\" to match pattern \"${pattern}\"`\n});\n\nfunction rule(pattern, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [_.isRegExp, _.isString]\n    }, {\n      actual: options,\n      possible: {\n        resolveNestedSelectors: _.isBoolean\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const shouldResolveNestedSelectors = _.get(options, 'resolveNestedSelectors');\n\n    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern; // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    root.walkRules(rule => {\n      const selector = rule.selector;\n      const selectors = rule.selectors;\n\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      }\n\n      if (selectors.some(s => isKeyframeSelector(s))) {\n        return;\n      } // Only bother resolving selectors that have an interpolating &\n\n\n      if (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {\n        // TODO: Issue #4985\n        // eslint-disable-next-line no-shadow\n        resolveNestedSelector(selector, rule).forEach(selector => {\n          if (!isStandardSyntaxSelector(selector)) {\n            return;\n          }\n\n          parseSelector(selector, result, rule, s => checkSelector(s, rule));\n        });\n      } else {\n        parseSelector(selector, result, rule, s => checkSelector(s, rule));\n      }\n    }); // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    function checkSelector(fullSelector, rule) {\n      fullSelector.walkClasses(classNode => {\n        const value = classNode.value;\n        const sourceIndex = classNode.sourceIndex;\n\n        if (normalizedPattern.test(value)) {\n          return;\n        }\n\n        report({\n          result,\n          ruleName,\n          message: messages.expected(value, pattern),\n          node: rule,\n          index: sourceIndex\n        });\n      });\n    }\n  };\n} // An \"interpolating ampersand\" means an \"&\" used to interpolate\n// within another simple selector, rather than an \"&\" that\n// stands on its own as a simple selector\n\n\nfunction hasInterpolatingAmpersand(selector) {\n  for (let i = 0, l = selector.length; i < l; i++) {\n    if (selector[i] !== '&') {\n      continue;\n    }\n\n    if (selector[i - 1] !== undefined && !isCombinator(selector[i - 1])) {\n      return true;\n    }\n\n    if (selector[i + 1] !== undefined && !isCombinator(selector[i + 1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isCombinator(x) {\n  return /[\\s+>~]/.test(x);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-class-pattern/index.js"],"names":["_","require","isKeyframeSelector","isStandardSyntaxRule","isStandardSyntaxSelector","parseSelector","report","resolveNestedSelector","ruleMessages","validateOptions","ruleName","messages","expected","selectorValue","pattern","rule","options","root","result","validOptions","actual","possible","isRegExp","isString","resolveNestedSelectors","isBoolean","optional","shouldResolveNestedSelectors","get","normalizedPattern","RegExp","walkRules","selector","selectors","some","s","hasInterpolatingAmpersand","forEach","checkSelector","fullSelector","walkClasses","classNode","value","sourceIndex","test","message","node","index","i","l","length","undefined","isCombinator","x","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst isKeyframeSelector = require('../../utils/isKeyframeSelector');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');\nconst parseSelector = require('../../utils/parseSelector');\nconst report = require('../../utils/report');\nconst resolveNestedSelector = require('postcss-resolve-nested-selector');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-class-pattern';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (selectorValue, pattern) =>\n\t\t`Expected class selector \".${selectorValue}\" to match pattern \"${pattern}\"`,\n});\n\nfunction rule(pattern, options) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: pattern,\n\t\t\t\tpossible: [_.isRegExp, _.isString],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tresolveNestedSelectors: _.isBoolean,\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst shouldResolveNestedSelectors = _.get(options, 'resolveNestedSelectors');\n\t\tconst normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tconst selector = rule.selector;\n\t\t\tconst selectors = rule.selectors;\n\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (selectors.some((s) => isKeyframeSelector(s))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only bother resolving selectors that have an interpolating &\n\t\t\tif (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {\n\t\t\t\t// TODO: Issue #4985\n\t\t\t\t// eslint-disable-next-line no-shadow\n\t\t\t\tresolveNestedSelector(selector, rule).forEach((selector) => {\n\t\t\t\t\tif (!isStandardSyntaxSelector(selector)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tparseSelector(selector, result, rule, (s) => checkSelector(s, rule));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tparseSelector(selector, result, rule, (s) => checkSelector(s, rule));\n\t\t\t}\n\t\t});\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction checkSelector(fullSelector, rule) {\n\t\t\tfullSelector.walkClasses((classNode) => {\n\t\t\t\tconst value = classNode.value;\n\t\t\t\tconst sourceIndex = classNode.sourceIndex;\n\n\t\t\t\tif (normalizedPattern.test(value)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t\tmessage: messages.expected(value, pattern),\n\t\t\t\t\tnode: rule,\n\t\t\t\t\tindex: sourceIndex,\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\n// An \"interpolating ampersand\" means an \"&\" used to interpolate\n// within another simple selector, rather than an \"&\" that\n// stands on its own as a simple selector\nfunction hasInterpolatingAmpersand(selector) {\n\tfor (let i = 0, l = selector.length; i < l; i++) {\n\t\tif (selector[i] !== '&') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (selector[i - 1] !== undefined && !isCombinator(selector[i - 1])) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (selector[i + 1] !== undefined && !isCombinator(selector[i + 1])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction isCombinator(x) {\n\treturn /[\\s+>~]/.test(x);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}