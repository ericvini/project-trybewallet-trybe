{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-list-comma-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \",\"',\n  expectedAfterMultiLine: () => 'Expected newline after \",\" in a multi-line list',\n  rejectedAfterMultiLine: () => 'Unexpected whitespace after \",\" in a multi-line list'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      } // Get raw selector so we can allow end-of-line comments, e.g.\n      // a, /* comment */\n      // b {}\n\n\n      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n      const fixIndices = [];\n      styleSearch({\n        source: selector,\n        target: ',',\n        functionArguments: 'skip'\n      }, match => {\n        const nextChars = selector.substr(match.endIndex, selector.length - match.endIndex); // If there's a // comment, that means there has to be a newline\n        // ending the comment so we're fine\n\n        if (/^\\s+\\/\\//.test(nextChars)) {\n          return;\n        } // If there are spaces and then a comment begins, look for the newline\n\n\n        const indextoCheckAfter = /^\\s+\\/\\*/.test(nextChars) ? selector.indexOf('*/', match.endIndex) + 1 : match.startIndex;\n        checker.afterOneOnly({\n          source: selector,\n          index: indextoCheckAfter,\n          err: m => {\n            if (context.fix) {\n              fixIndices.push(indextoCheckAfter + 1);\n              return;\n            }\n\n            report({\n              message: m,\n              node: rule,\n              index: match.startIndex,\n              result,\n              ruleName\n            });\n          }\n        });\n      });\n\n      if (fixIndices.length) {\n        let fixedSelector = selector;\n        fixIndices.sort((a, b) => b - a).forEach(index => {\n          const beforeSelector = fixedSelector.slice(0, index);\n          let afterSelector = fixedSelector.slice(index);\n\n          if (expectation.startsWith('always')) {\n            afterSelector = context.newline + afterSelector;\n          } else if (expectation.startsWith('never-multi-line')) {\n            afterSelector = afterSelector.replace(/^\\s*/, '');\n          }\n\n          fixedSelector = beforeSelector + afterSelector;\n        });\n\n        if (rule.raws.selector) {\n          rule.raws.selector.raw = fixedSelector;\n        } else {\n          rule.selector = fixedSelector;\n        }\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-list-comma-newline-after/index.js"],"names":["isStandardSyntaxRule","require","report","ruleMessages","styleSearch","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","walkRules","selector","raws","raw","fixIndices","source","target","functionArguments","match","nextChars","substr","endIndex","length","test","indextoCheckAfter","indexOf","startIndex","afterOneOnly","index","err","m","fix","push","message","node","fixedSelector","sort","a","b","forEach","beforeSelector","slice","afterSelector","startsWith","newline","replace","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-list-comma-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \",\"',\n\texpectedAfterMultiLine: () => 'Expected newline after \",\" in a multi-line list',\n\trejectedAfterMultiLine: () => 'Unexpected whitespace after \",\" in a multi-line list',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get raw selector so we can allow end-of-line comments, e.g.\n\t\t\t// a, /* comment */\n\t\t\t// b {}\n\t\t\tconst selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\n\t\t\tconst fixIndices = [];\n\n\t\t\tstyleSearch(\n\t\t\t\t{\n\t\t\t\t\tsource: selector,\n\t\t\t\t\ttarget: ',',\n\t\t\t\t\tfunctionArguments: 'skip',\n\t\t\t\t},\n\t\t\t\t(match) => {\n\t\t\t\t\tconst nextChars = selector.substr(match.endIndex, selector.length - match.endIndex);\n\n\t\t\t\t\t// If there's a // comment, that means there has to be a newline\n\t\t\t\t\t// ending the comment so we're fine\n\t\t\t\t\tif (/^\\s+\\/\\//.test(nextChars)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If there are spaces and then a comment begins, look for the newline\n\t\t\t\t\tconst indextoCheckAfter = /^\\s+\\/\\*/.test(nextChars)\n\t\t\t\t\t\t? selector.indexOf('*/', match.endIndex) + 1\n\t\t\t\t\t\t: match.startIndex;\n\n\t\t\t\t\tchecker.afterOneOnly({\n\t\t\t\t\t\tsource: selector,\n\t\t\t\t\t\tindex: indextoCheckAfter,\n\t\t\t\t\t\terr: (m) => {\n\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\tfixIndices.push(indextoCheckAfter + 1);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treport({\n\t\t\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\t\t\tindex: match.startIndex,\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (fixIndices.length) {\n\t\t\t\tlet fixedSelector = selector;\n\n\t\t\t\tfixIndices\n\t\t\t\t\t.sort((a, b) => b - a)\n\t\t\t\t\t.forEach((index) => {\n\t\t\t\t\t\tconst beforeSelector = fixedSelector.slice(0, index);\n\t\t\t\t\t\tlet afterSelector = fixedSelector.slice(index);\n\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tafterSelector = context.newline + afterSelector;\n\t\t\t\t\t\t} else if (expectation.startsWith('never-multi-line')) {\n\t\t\t\t\t\t\tafterSelector = afterSelector.replace(/^\\s*/, '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfixedSelector = beforeSelector + afterSelector;\n\t\t\t\t\t});\n\n\t\t\t\tif (rule.raws.selector) {\n\t\t\t\t\trule.raws.selector.raw = fixedSelector;\n\t\t\t\t} else {\n\t\t\t\t\trule.selector = fixedSelector;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}