{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-combinator-space-before';\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: combinator => `Expected single space before \"${combinator}\"`,\n  rejectedBefore: combinator => `Unexpected whitespace before \"${combinator}\"`\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('space', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    selectorCombinatorSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      locationType: 'before',\n      checkedRuleName: ruleName,\n      fix: context.fix ? combinator => {\n        if (expectation === 'always') {\n          combinator.spaces.before = ' ';\n          return true;\n        }\n\n        if (expectation === 'never') {\n          combinator.spaces.before = '';\n          return true;\n        }\n      } : null\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-combinator-space-before/index.js"],"names":["ruleMessages","require","selectorCombinatorSpaceChecker","validateOptions","whitespaceChecker","ruleName","messages","expectedBefore","combinator","rejectedBefore","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","locationChecker","before","locationType","checkedRuleName","fix","spaces","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMC,8BAA8B,GAAGD,OAAO,CAAC,mCAAD,CAA9C;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,6BAAD,CAA/B;;AACA,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,+BAAD,CAAjC;;AAEA,MAAMI,QAAQ,GAAG,kCAAjB;AAEA,MAAMC,QAAQ,GAAGN,YAAY,CAACK,QAAD,EAAW;AACvCE,EAAAA,cAAc,EAAGC,UAAD,IAAiB,iCAAgCA,UAAW,GADrC;AAEvCC,EAAAA,cAAc,EAAGD,UAAD,IAAiB,iCAAgCA,UAAW;AAFrC,CAAX,CAA7B;;AAKA,SAASE,IAAT,CAAcC,WAAd,EAA2BC,OAA3B,EAAoCC,OAApC,EAA6C;AAC5C,QAAMC,OAAO,GAAGV,iBAAiB,CAAC,OAAD,EAAUO,WAAV,EAAuBL,QAAvB,CAAjC;AAEA,SAAO,CAACS,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGd,eAAe,CAACa,MAAD,EAASX,QAAT,EAAmB;AACtDa,MAAAA,MAAM,EAAEP,WAD8C;AAEtDQ,MAAAA,QAAQ,EAAE,CAAC,QAAD,EAAW,OAAX;AAF4C,KAAnB,CAApC;;AAKA,QAAI,CAACF,YAAL,EAAmB;AAClB;AACA;;AAEDf,IAAAA,8BAA8B,CAAC;AAC9Ba,MAAAA,IAD8B;AAE9BC,MAAAA,MAF8B;AAG9BI,MAAAA,eAAe,EAAEN,OAAO,CAACO,MAHK;AAI9BC,MAAAA,YAAY,EAAE,QAJgB;AAK9BC,MAAAA,eAAe,EAAElB,QALa;AAM9BmB,MAAAA,GAAG,EAAEX,OAAO,CAACW,GAAR,GACDhB,UAAD,IAAgB;AAChB,YAAIG,WAAW,KAAK,QAApB,EAA8B;AAC7BH,UAAAA,UAAU,CAACiB,MAAX,CAAkBJ,MAAlB,GAA2B,GAA3B;AAEA,iBAAO,IAAP;AACA;;AAED,YAAIV,WAAW,KAAK,OAApB,EAA6B;AAC5BH,UAAAA,UAAU,CAACiB,MAAX,CAAkBJ,MAAlB,GAA2B,EAA3B;AAEA,iBAAO,IAAP;AACA;AACA,OAbC,GAcF;AApB2B,KAAD,CAA9B;AAsBA,GAhCD;AAiCA;;AAEDX,IAAI,CAACL,QAAL,GAAgBA,QAAhB;AACAK,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAoB,MAAM,CAACC,OAAP,GAAiBjB,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst ruleMessages = require('../../utils/ruleMessages');\nconst selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-combinator-space-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedBefore: (combinator) => `Expected single space before \"${combinator}\"`,\n\trejectedBefore: (combinator) => `Unexpected whitespace before \"${combinator}\"`,\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('space', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tselectorCombinatorSpaceChecker({\n\t\t\troot,\n\t\t\tresult,\n\t\t\tlocationChecker: checker.before,\n\t\t\tlocationType: 'before',\n\t\t\tcheckedRuleName: ruleName,\n\t\t\tfix: context.fix\n\t\t\t\t? (combinator) => {\n\t\t\t\t\t\tif (expectation === 'always') {\n\t\t\t\t\t\t\tcombinator.spaces.before = ' ';\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expectation === 'never') {\n\t\t\t\t\t\t\tcombinator.spaces.before = '';\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t: null,\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}