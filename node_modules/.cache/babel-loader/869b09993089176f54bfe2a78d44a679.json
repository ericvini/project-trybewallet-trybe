{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst arrayUnion = require('array-union');\n\nconst merge2 = require('merge2');\n\nconst fastGlob = require('fast-glob');\n\nconst dirGlob = require('dir-glob');\n\nconst gitignore = require('./gitignore');\n\nconst {\n  FilterStream,\n  UniqueStream\n} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n  if (!patterns.every(pattern => typeof pattern === 'string')) {\n    throw new TypeError('Patterns must be a string or an array of strings');\n  }\n};\n\nconst checkCwdOption = (options = {}) => {\n  if (!options.cwd) {\n    return;\n  }\n\n  let stat;\n\n  try {\n    stat = fs.statSync(options.cwd);\n  } catch (_) {\n    return;\n  }\n\n  if (!stat.isDirectory()) {\n    throw new Error('The `cwd` option must be a path to a directory');\n  }\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n  patterns = arrayUnion([].concat(patterns));\n  assertPatternsInput(patterns);\n  checkCwdOption(taskOptions);\n  const globTasks = [];\n  taskOptions = {\n    ignore: [],\n    expandDirectories: true,\n    ...taskOptions\n  };\n\n  for (const [index, pattern] of patterns.entries()) {\n    if (isNegative(pattern)) {\n      continue;\n    }\n\n    const ignore = patterns.slice(index).filter(isNegative).map(pattern => pattern.slice(1));\n    const options = { ...taskOptions,\n      ignore: taskOptions.ignore.concat(ignore)\n    };\n    globTasks.push({\n      pattern,\n      options\n    });\n  }\n\n  return globTasks;\n};\n\nconst globDirs = (task, fn) => {\n  let options = {};\n\n  if (task.options.cwd) {\n    options.cwd = task.options.cwd;\n  }\n\n  if (Array.isArray(task.options.expandDirectories)) {\n    options = { ...options,\n      files: task.options.expandDirectories\n    };\n  } else if (typeof task.options.expandDirectories === 'object') {\n    options = { ...options,\n      ...task.options.expandDirectories\n    };\n  }\n\n  return fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n  return options && options.gitignore ? gitignore.sync({\n    cwd: options.cwd,\n    ignore: options.ignore\n  }) : DEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n  const {\n    options\n  } = task;\n\n  if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n    options.ignore = dirGlob.sync(options.ignore);\n  }\n\n  return {\n    pattern: glob,\n    options\n  };\n};\n\nmodule.exports = async (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n\n  const getFilter = async () => {\n    return options && options.gitignore ? gitignore({\n      cwd: options.cwd,\n      ignore: options.ignore\n    }) : DEFAULT_FILTER;\n  };\n\n  const getTasks = async () => {\n    const tasks = await Promise.all(globTasks.map(async task => {\n      const globs = await getPattern(task, dirGlob);\n      return Promise.all(globs.map(globToTask(task)));\n    }));\n    return arrayUnion(...tasks);\n  };\n\n  const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n  const paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n  return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n  const tasks = globTasks.reduce((tasks, task) => {\n    const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n    return tasks.concat(newTask);\n  }, []);\n  const filter = getFilterSync(options);\n  return tasks.reduce((matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)), []).filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n  const tasks = globTasks.reduce((tasks, task) => {\n    const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n    return tasks.concat(newTask);\n  }, []);\n  const filter = getFilterSync(options);\n  const filterStream = new FilterStream(p => !filter(p));\n  const uniqueStream = new UniqueStream();\n  return merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => [].concat(patterns).some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/node_modules/globby/index.js"],"names":["fs","require","arrayUnion","merge2","fastGlob","dirGlob","gitignore","FilterStream","UniqueStream","DEFAULT_FILTER","isNegative","pattern","assertPatternsInput","patterns","every","TypeError","checkCwdOption","options","cwd","stat","statSync","_","isDirectory","Error","getPathString","p","stats","Stats","path","generateGlobTasks","taskOptions","concat","globTasks","ignore","expandDirectories","index","entries","slice","filter","map","push","globDirs","task","fn","Array","isArray","files","getPattern","getFilterSync","sync","globToTask","glob","module","exports","getFilter","getTasks","tasks","Promise","all","globs","paths","path_","reduce","newTask","matches","stream","filterStream","uniqueStream","pipe","hasMagic","some","isDynamicPattern"],"mappings":"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","sourcesContent":["'use strict';\nconst fs = require('fs');\nconst arrayUnion = require('array-union');\nconst merge2 = require('merge2');\nconst fastGlob = require('fast-glob');\nconst dirGlob = require('dir-glob');\nconst gitignore = require('./gitignore');\nconst {FilterStream, UniqueStream} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(pattern => typeof pattern === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst checkCwdOption = (options = {}) => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch (_) {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n\tpatterns = arrayUnion([].concat(patterns));\n\tassertPatternsInput(patterns);\n\tcheckCwdOption(taskOptions);\n\n\tconst globTasks = [];\n\n\ttaskOptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...taskOptions\n\t};\n\n\tfor (const [index, pattern] of patterns.entries()) {\n\t\tif (isNegative(pattern)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(index)\n\t\t\t.filter(isNegative)\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst options = {\n\t\t\t...taskOptions,\n\t\t\tignore: taskOptions.ignore.concat(ignore)\n\t\t};\n\n\t\tglobTasks.push({pattern, options});\n\t}\n\n\treturn globTasks;\n};\n\nconst globDirs = (task, fn) => {\n\tlet options = {};\n\tif (task.options.cwd) {\n\t\toptions.cwd = task.options.cwd;\n\t}\n\n\tif (Array.isArray(task.options.expandDirectories)) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\tfiles: task.options.expandDirectories\n\t\t};\n\t} else if (typeof task.options.expandDirectories === 'object') {\n\t\toptions = {\n\t\t\t...options,\n\t\t\t...task.options.expandDirectories\n\t\t};\n\t}\n\n\treturn fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n\treturn options && options.gitignore ?\n\t\tgitignore.sync({cwd: options.cwd, ignore: options.ignore}) :\n\t\tDEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = dirGlob.sync(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions\n\t};\n};\n\nmodule.exports = async (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst getFilter = async () => {\n\t\treturn options && options.gitignore ?\n\t\t\tgitignore({cwd: options.cwd, ignore: options.ignore}) :\n\t\t\tDEFAULT_FILTER;\n\t};\n\n\tconst getTasks = async () => {\n\t\tconst tasks = await Promise.all(globTasks.map(async task => {\n\t\t\tconst globs = await getPattern(task, dirGlob);\n\t\t\treturn Promise.all(globs.map(globToTask(task)));\n\t\t}));\n\n\t\treturn arrayUnion(...tasks);\n\t};\n\n\tconst [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n\tconst paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n\n\treturn arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = globTasks.reduce((tasks, task) => {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\treturn tasks.concat(newTask);\n\t}, []);\n\n\tconst filter = getFilterSync(options);\n\n\treturn tasks.reduce(\n\t\t(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)),\n\t\t[]\n\t).filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = globTasks.reduce((tasks, task) => {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\treturn tasks.concat(newTask);\n\t}, []);\n\n\tconst filter = getFilterSync(options);\n\tconst filterStream = new FilterStream(p => !filter(p));\n\tconst uniqueStream = new UniqueStream();\n\n\treturn merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))\n\t\t.pipe(filterStream)\n\t\t.pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => []\n\t.concat(patterns)\n\t.some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;\n"]},"metadata":{},"sourceType":"script"}