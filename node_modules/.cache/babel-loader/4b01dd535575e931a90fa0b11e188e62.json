{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\n\nconst keywordSets = require('../../reference/keywordSets');\n\nconst matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-name-case';\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`\n});\nconst mapLowercaseFunctionNamesToCamelCase = new Map();\nkeywordSets.camelCaseFunctionNames.forEach(func => {\n  mapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func);\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['lower', 'upper']\n    }, {\n      actual: options,\n      possible: {\n        ignoreFunctions: [_.isString, _.isRegExp]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      let needFix = false;\n      const parsed = valueParser(decl.raws.value ? decl.raws.value.raw : decl.value);\n      parsed.walk(node => {\n        if (node.type !== 'function' || !isStandardSyntaxFunction(node)) {\n          return;\n        }\n\n        const functionName = node.value;\n        const functionNameLowerCase = functionName.toLowerCase();\n        const ignoreFunctions = options && options.ignoreFunctions || [];\n\n        if (ignoreFunctions.length > 0 && matchesStringOrRegExp(functionName, ignoreFunctions)) {\n          return;\n        }\n\n        let expectedFunctionName = null;\n\n        if (expectation === 'lower' && mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase)) {\n          expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase);\n        } else if (expectation === 'lower') {\n          expectedFunctionName = functionNameLowerCase;\n        } else {\n          expectedFunctionName = functionName.toUpperCase();\n        }\n\n        if (functionName === expectedFunctionName) {\n          return;\n        }\n\n        if (context.fix) {\n          needFix = true;\n          node.value = expectedFunctionName;\n          return;\n        }\n\n        report({\n          message: messages.expected(functionName, expectedFunctionName),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName\n        });\n      });\n\n      if (context.fix && needFix) {\n        const statement = parsed.toString();\n\n        if (decl.raws.value) {\n          decl.raws.value.raw = statement;\n        } else {\n          decl.value = statement;\n        }\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/function-name-case/index.js"],"names":["_","require","declarationValueIndex","isStandardSyntaxFunction","keywordSets","matchesStringOrRegExp","report","ruleMessages","validateOptions","valueParser","ruleName","messages","expected","actual","mapLowercaseFunctionNamesToCamelCase","Map","camelCaseFunctionNames","forEach","func","set","toLowerCase","rule","expectation","options","context","root","result","validOptions","possible","ignoreFunctions","isString","isRegExp","optional","walkDecls","decl","needFix","parsed","raws","value","raw","walk","node","type","functionName","functionNameLowerCase","length","expectedFunctionName","has","get","toUpperCase","fix","message","index","sourceIndex","statement","toString","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\nconst keywordSets = require('../../reference/keywordSets');\nconst matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-name-case';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n});\n\nconst mapLowercaseFunctionNamesToCamelCase = new Map();\n\nkeywordSets.camelCaseFunctionNames.forEach((func) => {\n\tmapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func);\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['lower', 'upper'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignoreFunctions: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tlet needFix = false;\n\t\t\tconst parsed = valueParser(decl.raws.value ? decl.raws.value.raw : decl.value);\n\n\t\t\tparsed.walk((node) => {\n\t\t\t\tif (node.type !== 'function' || !isStandardSyntaxFunction(node)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst functionName = node.value;\n\t\t\t\tconst functionNameLowerCase = functionName.toLowerCase();\n\n\t\t\t\tconst ignoreFunctions = (options && options.ignoreFunctions) || [];\n\n\t\t\t\tif (ignoreFunctions.length > 0 && matchesStringOrRegExp(functionName, ignoreFunctions)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet expectedFunctionName = null;\n\n\t\t\t\tif (\n\t\t\t\t\texpectation === 'lower' &&\n\t\t\t\t\tmapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase)\n\t\t\t\t) {\n\t\t\t\t\texpectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase);\n\t\t\t\t} else if (expectation === 'lower') {\n\t\t\t\t\texpectedFunctionName = functionNameLowerCase;\n\t\t\t\t} else {\n\t\t\t\t\texpectedFunctionName = functionName.toUpperCase();\n\t\t\t\t}\n\n\t\t\t\tif (functionName === expectedFunctionName) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tneedFix = true;\n\t\t\t\t\tnode.value = expectedFunctionName;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(functionName, expectedFunctionName),\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + node.sourceIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (context.fix && needFix) {\n\t\t\t\tconst statement = parsed.toString();\n\n\t\t\t\tif (decl.raws.value) {\n\t\t\t\t\tdecl.raws.value.raw = statement;\n\t\t\t\t} else {\n\t\t\t\t\tdecl.value = statement;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}