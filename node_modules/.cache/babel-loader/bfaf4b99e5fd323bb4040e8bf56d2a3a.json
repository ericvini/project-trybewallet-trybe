{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst createStylelint = require('./createStylelint');\n\nconst createStylelintResult = require('./createStylelintResult');\n\nconst debug = require('debug')('stylelint:standalone');\n\nconst fastGlob = require('fast-glob');\n\nconst FileCache = require('./utils/FileCache');\n\nconst filterFilePaths = require('./utils/filterFilePaths');\n\nconst formatters = require('./formatters');\n\nconst fs = require('fs');\n\nconst getFormatterOptionsText = require('./utils/getFormatterOptionsText');\n\nconst globby = require('globby');\n\nconst hash = require('./utils/hash');\n\nconst NoFilesFoundError = require('./utils/noFilesFoundError');\n\nconst path = require('path');\n\nconst pkg = require('../package.json');\n\nconst prepareReturnValue = require('./prepareReturnValue');\n\nconst {\n  default: ignore\n} = require('ignore');\n\nconst DEFAULT_IGNORE_FILENAME = '.stylelintignore';\nconst FILE_NOT_FOUND_ERROR_CODE = 'ENOENT';\nconst ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];\n\nconst writeFileAtomic = require('write-file-atomic');\n/** @typedef {import('stylelint').StylelintStandaloneOptions} StylelintStandaloneOptions */\n\n/** @typedef {import('stylelint').StylelintStandaloneReturnValue} StylelintStandaloneReturnValue */\n\n/** @typedef {import('stylelint').StylelintResult} StylelintResult */\n\n/** @typedef {import('stylelint').Formatter} Formatter */\n\n/** @typedef {import('stylelint').FormatterIdentifier} FormatterIdentifier */\n\n/**\n * @param {StylelintStandaloneOptions} options\n * @returns {Promise<StylelintStandaloneReturnValue>}\n */\n\n\nmodule.exports = function (options) {\n  const cacheLocation = options.cacheLocation;\n  const code = options.code;\n  const codeFilename = options.codeFilename;\n  const config = options.config;\n  const configBasedir = options.configBasedir;\n  const configFile = options.configFile;\n  const configOverrides = options.configOverrides;\n  const customSyntax = options.customSyntax;\n  const globbyOptions = options.globbyOptions;\n  const files = options.files;\n  const fix = options.fix;\n  const formatter = options.formatter;\n  const ignoreDisables = options.ignoreDisables;\n  const reportNeedlessDisables = options.reportNeedlessDisables;\n  const reportInvalidScopeDisables = options.reportInvalidScopeDisables;\n  const reportDescriptionlessDisables = options.reportDescriptionlessDisables;\n  const syntax = options.syntax;\n  const allowEmptyInput = options.allowEmptyInput || false;\n  const useCache = options.cache || false;\n  /** @type {FileCache} */\n\n  let fileCache;\n  const startTime = Date.now(); // The ignorer will be used to filter file paths after the glob is checked,\n  // before any files are actually read\n\n  const ignoreFilePath = options.ignorePath || DEFAULT_IGNORE_FILENAME;\n  const absoluteIgnoreFilePath = path.isAbsolute(ignoreFilePath) ? ignoreFilePath : path.resolve(process.cwd(), ignoreFilePath);\n  let ignoreText = '';\n\n  try {\n    ignoreText = fs.readFileSync(absoluteIgnoreFilePath, 'utf8');\n  } catch (readError) {\n    if (readError.code !== FILE_NOT_FOUND_ERROR_CODE) throw readError;\n  }\n\n  const ignorePattern = options.ignorePattern || [];\n  const ignorer = ignore().add(ignoreText).add(ignorePattern);\n  const isValidCode = typeof code === 'string';\n\n  if (!files && !isValidCode || files && (code || isValidCode)) {\n    throw new Error('You must pass stylelint a `files` glob or a `code` string, though not both');\n  }\n  /** @type {Formatter} */\n\n\n  let formatterFunction;\n\n  try {\n    formatterFunction = getFormatterFunction(formatter);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  const stylelint = createStylelint({\n    config,\n    configFile,\n    configBasedir,\n    configOverrides,\n    ignoreDisables,\n    ignorePath: ignoreFilePath,\n    reportNeedlessDisables,\n    reportInvalidScopeDisables,\n    reportDescriptionlessDisables,\n    syntax,\n    customSyntax,\n    fix\n  });\n\n  if (!files) {\n    const absoluteCodeFilename = codeFilename !== undefined && !path.isAbsolute(codeFilename) ? path.join(process.cwd(), codeFilename) : codeFilename; // if file is ignored, return nothing\n\n    if (absoluteCodeFilename && !filterFilePaths(ignorer, [path.relative(process.cwd(), absoluteCodeFilename)]).length) {\n      return Promise.resolve(prepareReturnValue([], options, formatterFunction));\n    }\n\n    return stylelint._lintSource({\n      code,\n      codeFilename: absoluteCodeFilename\n    }).then(postcssResult => {\n      // Check for file existence\n      return new Promise((resolve, reject) => {\n        if (!absoluteCodeFilename) {\n          reject();\n          return;\n        }\n\n        fs.stat(absoluteCodeFilename, err => {\n          if (err) {\n            reject();\n          } else {\n            resolve();\n          }\n        });\n      }).then(() => {\n        return stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);\n      }).catch(() => {\n        return stylelint._createStylelintResult(postcssResult);\n      });\n    }).catch(_.partial(handleError, stylelint)).then(stylelintResult => {\n      const postcssResult = stylelintResult._postcssResult;\n      const returnValue = prepareReturnValue([stylelintResult], options, formatterFunction);\n\n      if (options.fix && postcssResult && !postcssResult.stylelint.ignored) {\n        if (!postcssResult.stylelint.disableWritingFix) {\n          // If we're fixing, the output should be the fixed code\n          returnValue.output = postcssResult.root.toString(postcssResult.opts.syntax);\n        } else {\n          // If the writing of the fix is disabled, the input code is returned as-is\n          returnValue.output = code;\n        }\n      }\n\n      return returnValue;\n    });\n  }\n\n  let fileList = files;\n\n  if (typeof fileList === 'string') {\n    fileList = [fileList];\n  }\n\n  fileList = fileList.map(entry => {\n    const cwd = _.get(globbyOptions, 'cwd', process.cwd());\n\n    const absolutePath = !path.isAbsolute(entry) ? path.join(cwd, entry) : path.normalize(entry);\n\n    if (fs.existsSync(absolutePath)) {\n      // This path points to a file. Return an escaped path to avoid globbing\n      return fastGlob.escapePath(entry);\n    }\n\n    return entry;\n  });\n\n  if (!options.disableDefaultIgnores) {\n    fileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map(glob => `!${glob}`));\n  }\n\n  if (useCache) {\n    const stylelintVersion = pkg.version;\n    const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);\n    fileCache = new FileCache(cacheLocation, hashOfConfig);\n  } else {\n    // No need to calculate hash here, we just want to delete cache file.\n    fileCache = new FileCache(cacheLocation); // Remove cache file if cache option is disabled\n\n    fileCache.destroy();\n  }\n\n  return globby(fileList, globbyOptions).then(filePaths => {\n    // The ignorer filter needs to check paths relative to cwd\n    filePaths = filterFilePaths(ignorer, filePaths.map(p => path.relative(process.cwd(), p)));\n\n    if (!filePaths.length) {\n      if (!allowEmptyInput) {\n        throw new NoFilesFoundError(fileList);\n      }\n\n      return Promise.all([]);\n    }\n\n    const cwd = _.get(globbyOptions, 'cwd', process.cwd());\n\n    let absoluteFilePaths = filePaths.map(filePath => {\n      const absoluteFilepath = !path.isAbsolute(filePath) ? path.join(cwd, filePath) : path.normalize(filePath);\n      return absoluteFilepath;\n    });\n\n    if (useCache) {\n      absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));\n    }\n\n    const getStylelintResults = absoluteFilePaths.map(absoluteFilepath => {\n      debug(`Processing ${absoluteFilepath}`);\n      return stylelint._lintSource({\n        filePath: absoluteFilepath\n      }).then(postcssResult => {\n        if (postcssResult.stylelint.stylelintError && useCache) {\n          debug(`${absoluteFilepath} contains linting errors and will not be cached.`);\n          fileCache.removeEntry(absoluteFilepath);\n        }\n        /**\n         * If we're fixing, save the file with changed code\n         * @type {Promise<Error | void>}\n         */\n\n\n        let fixFile = Promise.resolve();\n\n        if (postcssResult.root && postcssResult.opts && !postcssResult.stylelint.ignored && options.fix && !postcssResult.stylelint.disableWritingFix) {\n          // @ts-ignore TODO TYPES toString accepts 0 arguments\n          const fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);\n\n          if (postcssResult.root && postcssResult.root.source && // @ts-ignore TODO TYPES css is unknown property\n          postcssResult.root.source.input.css !== fixedCss) {\n            fixFile = writeFileAtomic(absoluteFilepath, fixedCss);\n          }\n        }\n\n        return fixFile.then(() => stylelint._createStylelintResult(postcssResult, absoluteFilepath));\n      }).catch(error => {\n        // On any error, we should not cache the lint result\n        fileCache.removeEntry(absoluteFilepath);\n        return handleError(stylelint, error, absoluteFilepath);\n      });\n    });\n    return Promise.all(getStylelintResults);\n  }).then(stylelintResults => {\n    if (useCache) {\n      fileCache.reconcile();\n    }\n\n    const rtn = prepareReturnValue(stylelintResults, options, formatterFunction);\n    debug(`Linting complete in ${Date.now() - startTime}ms`);\n    return rtn;\n  });\n};\n/**\n * @param {FormatterIdentifier | undefined} selected\n * @returns {Formatter}\n */\n\n\nfunction getFormatterFunction(selected) {\n  /** @type {Formatter} */\n  let formatterFunction;\n\n  if (typeof selected === 'string') {\n    formatterFunction = formatters[selected];\n\n    if (formatterFunction === undefined) {\n      throw new Error(`You must use a valid formatter option: ${getFormatterOptionsText()} or a function`);\n    }\n  } else if (typeof selected === 'function') {\n    formatterFunction = selected;\n  } else {\n    formatterFunction = formatters.json;\n  }\n\n  return formatterFunction;\n}\n/**\n * @param {import('stylelint').StylelintInternalApi} stylelint\n * @param {any} error\n * @param {string} [filePath]\n * @return {Promise<StylelintResult>}\n */\n\n\nfunction handleError(stylelint, error, filePath = undefined) {\n  if (error.name === 'CssSyntaxError') {\n    return createStylelintResult(stylelint, undefined, filePath, error);\n  }\n\n  throw error;\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/standalone.js"],"names":["_","require","createStylelint","createStylelintResult","debug","fastGlob","FileCache","filterFilePaths","formatters","fs","getFormatterOptionsText","globby","hash","NoFilesFoundError","path","pkg","prepareReturnValue","default","ignore","DEFAULT_IGNORE_FILENAME","FILE_NOT_FOUND_ERROR_CODE","ALWAYS_IGNORED_GLOBS","writeFileAtomic","module","exports","options","cacheLocation","code","codeFilename","config","configBasedir","configFile","configOverrides","customSyntax","globbyOptions","files","fix","formatter","ignoreDisables","reportNeedlessDisables","reportInvalidScopeDisables","reportDescriptionlessDisables","syntax","allowEmptyInput","useCache","cache","fileCache","startTime","Date","now","ignoreFilePath","ignorePath","absoluteIgnoreFilePath","isAbsolute","resolve","process","cwd","ignoreText","readFileSync","readError","ignorePattern","ignorer","add","isValidCode","Error","formatterFunction","getFormatterFunction","error","Promise","reject","stylelint","absoluteCodeFilename","undefined","join","relative","length","_lintSource","then","postcssResult","stat","err","_createStylelintResult","catch","partial","handleError","stylelintResult","_postcssResult","returnValue","ignored","disableWritingFix","output","root","toString","opts","fileList","map","entry","get","absolutePath","normalize","existsSync","escapePath","disableDefaultIgnores","concat","glob","stylelintVersion","version","hashOfConfig","JSON","stringify","destroy","filePaths","p","all","absoluteFilePaths","filePath","absoluteFilepath","filter","hasFileChanged","bind","getStylelintResults","stylelintError","removeEntry","fixFile","fixedCss","source","input","css","stylelintResults","reconcile","rtn","selected","json","name"],"mappings":"AAAA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA/B;;AACA,MAAME,qBAAqB,GAAGF,OAAO,CAAC,yBAAD,CAArC;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,sBAAjB,CAAd;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMK,SAAS,GAAGL,OAAO,CAAC,mBAAD,CAAzB;;AACA,MAAMM,eAAe,GAAGN,OAAO,CAAC,yBAAD,CAA/B;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAMQ,EAAE,GAAGR,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMS,uBAAuB,GAAGT,OAAO,CAAC,iCAAD,CAAvC;;AACA,MAAMU,MAAM,GAAGV,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMW,IAAI,GAAGX,OAAO,CAAC,cAAD,CAApB;;AACA,MAAMY,iBAAiB,GAAGZ,OAAO,CAAC,2BAAD,CAAjC;;AACA,MAAMa,IAAI,GAAGb,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMc,GAAG,GAAGd,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMe,kBAAkB,GAAGf,OAAO,CAAC,sBAAD,CAAlC;;AACA,MAAM;AAAEgB,EAAAA,OAAO,EAAEC;AAAX,IAAsBjB,OAAO,CAAC,QAAD,CAAnC;;AACA,MAAMkB,uBAAuB,GAAG,kBAAhC;AACA,MAAMC,yBAAyB,GAAG,QAAlC;AACA,MAAMC,oBAAoB,GAAG,CAAC,oBAAD,CAA7B;;AACA,MAAMC,eAAe,GAAGrB,OAAO,CAAC,mBAAD,CAA/B;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;;;AACAsB,MAAM,CAACC,OAAP,GAAiB,UAAUC,OAAV,EAAmB;AACnC,QAAMC,aAAa,GAAGD,OAAO,CAACC,aAA9B;AACA,QAAMC,IAAI,GAAGF,OAAO,CAACE,IAArB;AACA,QAAMC,YAAY,GAAGH,OAAO,CAACG,YAA7B;AACA,QAAMC,MAAM,GAAGJ,OAAO,CAACI,MAAvB;AACA,QAAMC,aAAa,GAAGL,OAAO,CAACK,aAA9B;AACA,QAAMC,UAAU,GAAGN,OAAO,CAACM,UAA3B;AACA,QAAMC,eAAe,GAAGP,OAAO,CAACO,eAAhC;AACA,QAAMC,YAAY,GAAGR,OAAO,CAACQ,YAA7B;AACA,QAAMC,aAAa,GAAGT,OAAO,CAACS,aAA9B;AACA,QAAMC,KAAK,GAAGV,OAAO,CAACU,KAAtB;AACA,QAAMC,GAAG,GAAGX,OAAO,CAACW,GAApB;AACA,QAAMC,SAAS,GAAGZ,OAAO,CAACY,SAA1B;AACA,QAAMC,cAAc,GAAGb,OAAO,CAACa,cAA/B;AACA,QAAMC,sBAAsB,GAAGd,OAAO,CAACc,sBAAvC;AACA,QAAMC,0BAA0B,GAAGf,OAAO,CAACe,0BAA3C;AACA,QAAMC,6BAA6B,GAAGhB,OAAO,CAACgB,6BAA9C;AACA,QAAMC,MAAM,GAAGjB,OAAO,CAACiB,MAAvB;AACA,QAAMC,eAAe,GAAGlB,OAAO,CAACkB,eAAR,IAA2B,KAAnD;AACA,QAAMC,QAAQ,GAAGnB,OAAO,CAACoB,KAAR,IAAiB,KAAlC;AACA;;AACA,MAAIC,SAAJ;AACA,QAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB,CAtBmC,CAwBnC;AACA;;AACA,QAAMC,cAAc,GAAGzB,OAAO,CAAC0B,UAAR,IAAsBhC,uBAA7C;AACA,QAAMiC,sBAAsB,GAAGtC,IAAI,CAACuC,UAAL,CAAgBH,cAAhB,IAC5BA,cAD4B,GAE5BpC,IAAI,CAACwC,OAAL,CAAaC,OAAO,CAACC,GAAR,EAAb,EAA4BN,cAA5B,CAFH;AAGA,MAAIO,UAAU,GAAG,EAAjB;;AAEA,MAAI;AACHA,IAAAA,UAAU,GAAGhD,EAAE,CAACiD,YAAH,CAAgBN,sBAAhB,EAAwC,MAAxC,CAAb;AACA,GAFD,CAEE,OAAOO,SAAP,EAAkB;AACnB,QAAIA,SAAS,CAAChC,IAAV,KAAmBP,yBAAvB,EAAkD,MAAMuC,SAAN;AAClD;;AAED,QAAMC,aAAa,GAAGnC,OAAO,CAACmC,aAAR,IAAyB,EAA/C;AACA,QAAMC,OAAO,GAAG3C,MAAM,GAAG4C,GAAT,CAAaL,UAAb,EAAyBK,GAAzB,CAA6BF,aAA7B,CAAhB;AAEA,QAAMG,WAAW,GAAG,OAAOpC,IAAP,KAAgB,QAApC;;AAEA,MAAK,CAACQ,KAAD,IAAU,CAAC4B,WAAZ,IAA6B5B,KAAK,KAAKR,IAAI,IAAIoC,WAAb,CAAtC,EAAkE;AACjE,UAAM,IAAIC,KAAJ,CAAU,4EAAV,CAAN;AACA;AAED;;;AACA,MAAIC,iBAAJ;;AAEA,MAAI;AACHA,IAAAA,iBAAiB,GAAGC,oBAAoB,CAAC7B,SAAD,CAAxC;AACA,GAFD,CAEE,OAAO8B,KAAP,EAAc;AACf,WAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACA;;AAED,QAAMG,SAAS,GAAGpE,eAAe,CAAC;AACjC2B,IAAAA,MADiC;AAEjCE,IAAAA,UAFiC;AAGjCD,IAAAA,aAHiC;AAIjCE,IAAAA,eAJiC;AAKjCM,IAAAA,cALiC;AAMjCa,IAAAA,UAAU,EAAED,cANqB;AAOjCX,IAAAA,sBAPiC;AAQjCC,IAAAA,0BARiC;AASjCC,IAAAA,6BATiC;AAUjCC,IAAAA,MAViC;AAWjCT,IAAAA,YAXiC;AAYjCG,IAAAA;AAZiC,GAAD,CAAjC;;AAeA,MAAI,CAACD,KAAL,EAAY;AACX,UAAMoC,oBAAoB,GACzB3C,YAAY,KAAK4C,SAAjB,IAA8B,CAAC1D,IAAI,CAACuC,UAAL,CAAgBzB,YAAhB,CAA/B,GACGd,IAAI,CAAC2D,IAAL,CAAUlB,OAAO,CAACC,GAAR,EAAV,EAAyB5B,YAAzB,CADH,GAEGA,YAHJ,CADW,CAMX;;AACA,QACC2C,oBAAoB,IACpB,CAAChE,eAAe,CAACsD,OAAD,EAAU,CAAC/C,IAAI,CAAC4D,QAAL,CAAcnB,OAAO,CAACC,GAAR,EAAd,EAA6Be,oBAA7B,CAAD,CAAV,CAAf,CAA+EI,MAFjF,EAGE;AACD,aAAOP,OAAO,CAACd,OAAR,CAAgBtC,kBAAkB,CAAC,EAAD,EAAKS,OAAL,EAAcwC,iBAAd,CAAlC,CAAP;AACA;;AAED,WAAOK,SAAS,CACdM,WADK,CACO;AACZjD,MAAAA,IADY;AAEZC,MAAAA,YAAY,EAAE2C;AAFF,KADP,EAKLM,IALK,CAKCC,aAAD,IAAmB;AACxB;AACA,aAAO,IAAIV,OAAJ,CAAY,CAACd,OAAD,EAAUe,MAAV,KAAqB;AACvC,YAAI,CAACE,oBAAL,EAA2B;AAC1BF,UAAAA,MAAM;AAEN;AACA;;AAED5D,QAAAA,EAAE,CAACsE,IAAH,CAAQR,oBAAR,EAA+BS,GAAD,IAAS;AACtC,cAAIA,GAAJ,EAAS;AACRX,YAAAA,MAAM;AACN,WAFD,MAEO;AACNf,YAAAA,OAAO;AACP;AACD,SAND;AAOA,OAdM,EAeLuB,IAfK,CAeA,MAAM;AACX,eAAOP,SAAS,CAACW,sBAAV,CAAiCH,aAAjC,EAAgDP,oBAAhD,CAAP;AACA,OAjBK,EAkBLW,KAlBK,CAkBC,MAAM;AACZ,eAAOZ,SAAS,CAACW,sBAAV,CAAiCH,aAAjC,CAAP;AACA,OApBK,CAAP;AAqBA,KA5BK,EA6BLI,KA7BK,CA6BClF,CAAC,CAACmF,OAAF,CAAUC,WAAV,EAAuBd,SAAvB,CA7BD,EA8BLO,IA9BK,CA8BCQ,eAAD,IAAqB;AAC1B,YAAMP,aAAa,GAAGO,eAAe,CAACC,cAAtC;AACA,YAAMC,WAAW,GAAGvE,kBAAkB,CAAC,CAACqE,eAAD,CAAD,EAAoB5D,OAApB,EAA6BwC,iBAA7B,CAAtC;;AAEA,UAAIxC,OAAO,CAACW,GAAR,IAAe0C,aAAf,IAAgC,CAACA,aAAa,CAACR,SAAd,CAAwBkB,OAA7D,EAAsE;AACrE,YAAI,CAACV,aAAa,CAACR,SAAd,CAAwBmB,iBAA7B,EAAgD;AAC/C;AACAF,UAAAA,WAAW,CAACG,MAAZ,GAAqBZ,aAAa,CAACa,IAAd,CAAmBC,QAAnB,CAA4Bd,aAAa,CAACe,IAAd,CAAmBnD,MAA/C,CAArB;AACA,SAHD,MAGO;AACN;AACA6C,UAAAA,WAAW,CAACG,MAAZ,GAAqB/D,IAArB;AACA;AACD;;AAED,aAAO4D,WAAP;AACA,KA7CK,CAAP;AA8CA;;AAED,MAAIO,QAAQ,GAAG3D,KAAf;;AAEA,MAAI,OAAO2D,QAAP,KAAoB,QAAxB,EAAkC;AACjCA,IAAAA,QAAQ,GAAG,CAACA,QAAD,CAAX;AACA;;AAEDA,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,GAAT,CAAcC,KAAD,IAAW;AAClC,UAAMxC,GAAG,GAAGxD,CAAC,CAACiG,GAAF,CAAM/D,aAAN,EAAqB,KAArB,EAA4BqB,OAAO,CAACC,GAAR,EAA5B,CAAZ;;AACA,UAAM0C,YAAY,GAAG,CAACpF,IAAI,CAACuC,UAAL,CAAgB2C,KAAhB,CAAD,GAA0BlF,IAAI,CAAC2D,IAAL,CAAUjB,GAAV,EAAewC,KAAf,CAA1B,GAAkDlF,IAAI,CAACqF,SAAL,CAAeH,KAAf,CAAvE;;AAEA,QAAIvF,EAAE,CAAC2F,UAAH,CAAcF,YAAd,CAAJ,EAAiC;AAChC;AACA,aAAO7F,QAAQ,CAACgG,UAAT,CAAoBL,KAApB,CAAP;AACA;;AAED,WAAOA,KAAP;AACA,GAVU,CAAX;;AAYA,MAAI,CAACvE,OAAO,CAAC6E,qBAAb,EAAoC;AACnCR,IAAAA,QAAQ,GAAGA,QAAQ,CAACS,MAAT,CAAgBlF,oBAAoB,CAAC0E,GAArB,CAA0BS,IAAD,IAAW,IAAGA,IAAK,EAA5C,CAAhB,CAAX;AACA;;AAED,MAAI5D,QAAJ,EAAc;AACb,UAAM6D,gBAAgB,GAAG1F,GAAG,CAAC2F,OAA7B;AACA,UAAMC,YAAY,GAAG/F,IAAI,CAAE,GAAE6F,gBAAiB,IAAGG,IAAI,CAACC,SAAL,CAAehF,MAAM,IAAI,EAAzB,CAA6B,EAArD,CAAzB;AAEAiB,IAAAA,SAAS,GAAG,IAAIxC,SAAJ,CAAcoB,aAAd,EAA6BiF,YAA7B,CAAZ;AACA,GALD,MAKO;AACN;AACA7D,IAAAA,SAAS,GAAG,IAAIxC,SAAJ,CAAcoB,aAAd,CAAZ,CAFM,CAGN;;AACAoB,IAAAA,SAAS,CAACgE,OAAV;AACA;;AAED,SAAOnG,MAAM,CAACmF,QAAD,EAAW5D,aAAX,CAAN,CACL2C,IADK,CACCkC,SAAD,IAAe;AACpB;AACAA,IAAAA,SAAS,GAAGxG,eAAe,CAC1BsD,OAD0B,EAE1BkD,SAAS,CAAChB,GAAV,CAAeiB,CAAD,IAAOlG,IAAI,CAAC4D,QAAL,CAAcnB,OAAO,CAACC,GAAR,EAAd,EAA6BwD,CAA7B,CAArB,CAF0B,CAA3B;;AAKA,QAAI,CAACD,SAAS,CAACpC,MAAf,EAAuB;AACtB,UAAI,CAAChC,eAAL,EAAsB;AACrB,cAAM,IAAI9B,iBAAJ,CAAsBiF,QAAtB,CAAN;AACA;;AAED,aAAO1B,OAAO,CAAC6C,GAAR,CAAY,EAAZ,CAAP;AACA;;AAED,UAAMzD,GAAG,GAAGxD,CAAC,CAACiG,GAAF,CAAM/D,aAAN,EAAqB,KAArB,EAA4BqB,OAAO,CAACC,GAAR,EAA5B,CAAZ;;AACA,QAAI0D,iBAAiB,GAAGH,SAAS,CAAChB,GAAV,CAAeoB,QAAD,IAAc;AACnD,YAAMC,gBAAgB,GAAG,CAACtG,IAAI,CAACuC,UAAL,CAAgB8D,QAAhB,CAAD,GACtBrG,IAAI,CAAC2D,IAAL,CAAUjB,GAAV,EAAe2D,QAAf,CADsB,GAEtBrG,IAAI,CAACqF,SAAL,CAAegB,QAAf,CAFH;AAIA,aAAOC,gBAAP;AACA,KANuB,CAAxB;;AAQA,QAAIxE,QAAJ,EAAc;AACbsE,MAAAA,iBAAiB,GAAGA,iBAAiB,CAACG,MAAlB,CAAyBvE,SAAS,CAACwE,cAAV,CAAyBC,IAAzB,CAA8BzE,SAA9B,CAAzB,CAApB;AACA;;AAED,UAAM0E,mBAAmB,GAAGN,iBAAiB,CAACnB,GAAlB,CAAuBqB,gBAAD,IAAsB;AACvEhH,MAAAA,KAAK,CAAE,cAAagH,gBAAiB,EAAhC,CAAL;AAEA,aAAO9C,SAAS,CACdM,WADK,CACO;AACZuC,QAAAA,QAAQ,EAAEC;AADE,OADP,EAILvC,IAJK,CAICC,aAAD,IAAmB;AACxB,YAAIA,aAAa,CAACR,SAAd,CAAwBmD,cAAxB,IAA0C7E,QAA9C,EAAwD;AACvDxC,UAAAA,KAAK,CAAE,GAAEgH,gBAAiB,kDAArB,CAAL;AACAtE,UAAAA,SAAS,CAAC4E,WAAV,CAAsBN,gBAAtB;AACA;AAED;AACN;AACA;AACA;;;AACM,YAAIO,OAAO,GAAGvD,OAAO,CAACd,OAAR,EAAd;;AAEA,YACCwB,aAAa,CAACa,IAAd,IACAb,aAAa,CAACe,IADd,IAEA,CAACf,aAAa,CAACR,SAAd,CAAwBkB,OAFzB,IAGA/D,OAAO,CAACW,GAHR,IAIA,CAAC0C,aAAa,CAACR,SAAd,CAAwBmB,iBAL1B,EAME;AACD;AACA,gBAAMmC,QAAQ,GAAG9C,aAAa,CAACa,IAAd,CAAmBC,QAAnB,CAA4Bd,aAAa,CAACe,IAAd,CAAmBnD,MAA/C,CAAjB;;AAEA,cACCoC,aAAa,CAACa,IAAd,IACAb,aAAa,CAACa,IAAd,CAAmBkC,MADnB,IAEA;AACA/C,UAAAA,aAAa,CAACa,IAAd,CAAmBkC,MAAnB,CAA0BC,KAA1B,CAAgCC,GAAhC,KAAwCH,QAJzC,EAKE;AACDD,YAAAA,OAAO,GAAGrG,eAAe,CAAC8F,gBAAD,EAAmBQ,QAAnB,CAAzB;AACA;AACD;;AAED,eAAOD,OAAO,CAAC9C,IAAR,CAAa,MACnBP,SAAS,CAACW,sBAAV,CAAiCH,aAAjC,EAAgDsC,gBAAhD,CADM,CAAP;AAGA,OAvCK,EAwCLlC,KAxCK,CAwCEf,KAAD,IAAW;AACjB;AACArB,QAAAA,SAAS,CAAC4E,WAAV,CAAsBN,gBAAtB;AAEA,eAAOhC,WAAW,CAACd,SAAD,EAAYH,KAAZ,EAAmBiD,gBAAnB,CAAlB;AACA,OA7CK,CAAP;AA8CA,KAjD2B,CAA5B;AAmDA,WAAOhD,OAAO,CAAC6C,GAAR,CAAYO,mBAAZ,CAAP;AACA,GAjFK,EAkFL3C,IAlFK,CAkFCmD,gBAAD,IAAsB;AAC3B,QAAIpF,QAAJ,EAAc;AACbE,MAAAA,SAAS,CAACmF,SAAV;AACA;;AAED,UAAMC,GAAG,GAAGlH,kBAAkB,CAACgH,gBAAD,EAAmBvG,OAAnB,EAA4BwC,iBAA5B,CAA9B;AAEA7D,IAAAA,KAAK,CAAE,uBAAsB4C,IAAI,CAACC,GAAL,KAAaF,SAAU,IAA/C,CAAL;AAEA,WAAOmF,GAAP;AACA,GA5FK,CAAP;AA6FA,CApQD;AAsQA;AACA;AACA;AACA;;;AACA,SAAShE,oBAAT,CAA8BiE,QAA9B,EAAwC;AACvC;AACA,MAAIlE,iBAAJ;;AAEA,MAAI,OAAOkE,QAAP,KAAoB,QAAxB,EAAkC;AACjClE,IAAAA,iBAAiB,GAAGzD,UAAU,CAAC2H,QAAD,CAA9B;;AAEA,QAAIlE,iBAAiB,KAAKO,SAA1B,EAAqC;AACpC,YAAM,IAAIR,KAAJ,CACJ,0CAAyCtD,uBAAuB,EAAG,gBAD/D,CAAN;AAGA;AACD,GARD,MAQO,IAAI,OAAOyH,QAAP,KAAoB,UAAxB,EAAoC;AAC1ClE,IAAAA,iBAAiB,GAAGkE,QAApB;AACA,GAFM,MAEA;AACNlE,IAAAA,iBAAiB,GAAGzD,UAAU,CAAC4H,IAA/B;AACA;;AAED,SAAOnE,iBAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmB,WAAT,CAAqBd,SAArB,EAAgCH,KAAhC,EAAuCgD,QAAQ,GAAG3C,SAAlD,EAA6D;AAC5D,MAAIL,KAAK,CAACkE,IAAN,KAAe,gBAAnB,EAAqC;AACpC,WAAOlI,qBAAqB,CAACmE,SAAD,EAAYE,SAAZ,EAAuB2C,QAAvB,EAAiChD,KAAjC,CAA5B;AACA;;AAED,QAAMA,KAAN;AACA","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst createStylelint = require('./createStylelint');\nconst createStylelintResult = require('./createStylelintResult');\nconst debug = require('debug')('stylelint:standalone');\nconst fastGlob = require('fast-glob');\nconst FileCache = require('./utils/FileCache');\nconst filterFilePaths = require('./utils/filterFilePaths');\nconst formatters = require('./formatters');\nconst fs = require('fs');\nconst getFormatterOptionsText = require('./utils/getFormatterOptionsText');\nconst globby = require('globby');\nconst hash = require('./utils/hash');\nconst NoFilesFoundError = require('./utils/noFilesFoundError');\nconst path = require('path');\nconst pkg = require('../package.json');\nconst prepareReturnValue = require('./prepareReturnValue');\nconst { default: ignore } = require('ignore');\nconst DEFAULT_IGNORE_FILENAME = '.stylelintignore';\nconst FILE_NOT_FOUND_ERROR_CODE = 'ENOENT';\nconst ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];\nconst writeFileAtomic = require('write-file-atomic');\n\n/** @typedef {import('stylelint').StylelintStandaloneOptions} StylelintStandaloneOptions */\n/** @typedef {import('stylelint').StylelintStandaloneReturnValue} StylelintStandaloneReturnValue */\n/** @typedef {import('stylelint').StylelintResult} StylelintResult */\n/** @typedef {import('stylelint').Formatter} Formatter */\n/** @typedef {import('stylelint').FormatterIdentifier} FormatterIdentifier */\n\n/**\n * @param {StylelintStandaloneOptions} options\n * @returns {Promise<StylelintStandaloneReturnValue>}\n */\nmodule.exports = function (options) {\n\tconst cacheLocation = options.cacheLocation;\n\tconst code = options.code;\n\tconst codeFilename = options.codeFilename;\n\tconst config = options.config;\n\tconst configBasedir = options.configBasedir;\n\tconst configFile = options.configFile;\n\tconst configOverrides = options.configOverrides;\n\tconst customSyntax = options.customSyntax;\n\tconst globbyOptions = options.globbyOptions;\n\tconst files = options.files;\n\tconst fix = options.fix;\n\tconst formatter = options.formatter;\n\tconst ignoreDisables = options.ignoreDisables;\n\tconst reportNeedlessDisables = options.reportNeedlessDisables;\n\tconst reportInvalidScopeDisables = options.reportInvalidScopeDisables;\n\tconst reportDescriptionlessDisables = options.reportDescriptionlessDisables;\n\tconst syntax = options.syntax;\n\tconst allowEmptyInput = options.allowEmptyInput || false;\n\tconst useCache = options.cache || false;\n\t/** @type {FileCache} */\n\tlet fileCache;\n\tconst startTime = Date.now();\n\n\t// The ignorer will be used to filter file paths after the glob is checked,\n\t// before any files are actually read\n\tconst ignoreFilePath = options.ignorePath || DEFAULT_IGNORE_FILENAME;\n\tconst absoluteIgnoreFilePath = path.isAbsolute(ignoreFilePath)\n\t\t? ignoreFilePath\n\t\t: path.resolve(process.cwd(), ignoreFilePath);\n\tlet ignoreText = '';\n\n\ttry {\n\t\tignoreText = fs.readFileSync(absoluteIgnoreFilePath, 'utf8');\n\t} catch (readError) {\n\t\tif (readError.code !== FILE_NOT_FOUND_ERROR_CODE) throw readError;\n\t}\n\n\tconst ignorePattern = options.ignorePattern || [];\n\tconst ignorer = ignore().add(ignoreText).add(ignorePattern);\n\n\tconst isValidCode = typeof code === 'string';\n\n\tif ((!files && !isValidCode) || (files && (code || isValidCode))) {\n\t\tthrow new Error('You must pass stylelint a `files` glob or a `code` string, though not both');\n\t}\n\n\t/** @type {Formatter} */\n\tlet formatterFunction;\n\n\ttry {\n\t\tformatterFunction = getFormatterFunction(formatter);\n\t} catch (error) {\n\t\treturn Promise.reject(error);\n\t}\n\n\tconst stylelint = createStylelint({\n\t\tconfig,\n\t\tconfigFile,\n\t\tconfigBasedir,\n\t\tconfigOverrides,\n\t\tignoreDisables,\n\t\tignorePath: ignoreFilePath,\n\t\treportNeedlessDisables,\n\t\treportInvalidScopeDisables,\n\t\treportDescriptionlessDisables,\n\t\tsyntax,\n\t\tcustomSyntax,\n\t\tfix,\n\t});\n\n\tif (!files) {\n\t\tconst absoluteCodeFilename =\n\t\t\tcodeFilename !== undefined && !path.isAbsolute(codeFilename)\n\t\t\t\t? path.join(process.cwd(), codeFilename)\n\t\t\t\t: codeFilename;\n\n\t\t// if file is ignored, return nothing\n\t\tif (\n\t\t\tabsoluteCodeFilename &&\n\t\t\t!filterFilePaths(ignorer, [path.relative(process.cwd(), absoluteCodeFilename)]).length\n\t\t) {\n\t\t\treturn Promise.resolve(prepareReturnValue([], options, formatterFunction));\n\t\t}\n\n\t\treturn stylelint\n\t\t\t._lintSource({\n\t\t\t\tcode,\n\t\t\t\tcodeFilename: absoluteCodeFilename,\n\t\t\t})\n\t\t\t.then((postcssResult) => {\n\t\t\t\t// Check for file existence\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tif (!absoluteCodeFilename) {\n\t\t\t\t\t\treject();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tfs.stat(absoluteCodeFilename, (err) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\treturn stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);\n\t\t\t\t\t})\n\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\treturn stylelint._createStylelintResult(postcssResult);\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(_.partial(handleError, stylelint))\n\t\t\t.then((stylelintResult) => {\n\t\t\t\tconst postcssResult = stylelintResult._postcssResult;\n\t\t\t\tconst returnValue = prepareReturnValue([stylelintResult], options, formatterFunction);\n\n\t\t\t\tif (options.fix && postcssResult && !postcssResult.stylelint.ignored) {\n\t\t\t\t\tif (!postcssResult.stylelint.disableWritingFix) {\n\t\t\t\t\t\t// If we're fixing, the output should be the fixed code\n\t\t\t\t\t\treturnValue.output = postcssResult.root.toString(postcssResult.opts.syntax);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the writing of the fix is disabled, the input code is returned as-is\n\t\t\t\t\t\treturnValue.output = code;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn returnValue;\n\t\t\t});\n\t}\n\n\tlet fileList = files;\n\n\tif (typeof fileList === 'string') {\n\t\tfileList = [fileList];\n\t}\n\n\tfileList = fileList.map((entry) => {\n\t\tconst cwd = _.get(globbyOptions, 'cwd', process.cwd());\n\t\tconst absolutePath = !path.isAbsolute(entry) ? path.join(cwd, entry) : path.normalize(entry);\n\n\t\tif (fs.existsSync(absolutePath)) {\n\t\t\t// This path points to a file. Return an escaped path to avoid globbing\n\t\t\treturn fastGlob.escapePath(entry);\n\t\t}\n\n\t\treturn entry;\n\t});\n\n\tif (!options.disableDefaultIgnores) {\n\t\tfileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map((glob) => `!${glob}`));\n\t}\n\n\tif (useCache) {\n\t\tconst stylelintVersion = pkg.version;\n\t\tconst hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);\n\n\t\tfileCache = new FileCache(cacheLocation, hashOfConfig);\n\t} else {\n\t\t// No need to calculate hash here, we just want to delete cache file.\n\t\tfileCache = new FileCache(cacheLocation);\n\t\t// Remove cache file if cache option is disabled\n\t\tfileCache.destroy();\n\t}\n\n\treturn globby(fileList, globbyOptions)\n\t\t.then((filePaths) => {\n\t\t\t// The ignorer filter needs to check paths relative to cwd\n\t\t\tfilePaths = filterFilePaths(\n\t\t\t\tignorer,\n\t\t\t\tfilePaths.map((p) => path.relative(process.cwd(), p)),\n\t\t\t);\n\n\t\t\tif (!filePaths.length) {\n\t\t\t\tif (!allowEmptyInput) {\n\t\t\t\t\tthrow new NoFilesFoundError(fileList);\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all([]);\n\t\t\t}\n\n\t\t\tconst cwd = _.get(globbyOptions, 'cwd', process.cwd());\n\t\t\tlet absoluteFilePaths = filePaths.map((filePath) => {\n\t\t\t\tconst absoluteFilepath = !path.isAbsolute(filePath)\n\t\t\t\t\t? path.join(cwd, filePath)\n\t\t\t\t\t: path.normalize(filePath);\n\n\t\t\t\treturn absoluteFilepath;\n\t\t\t});\n\n\t\t\tif (useCache) {\n\t\t\t\tabsoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));\n\t\t\t}\n\n\t\t\tconst getStylelintResults = absoluteFilePaths.map((absoluteFilepath) => {\n\t\t\t\tdebug(`Processing ${absoluteFilepath}`);\n\n\t\t\t\treturn stylelint\n\t\t\t\t\t._lintSource({\n\t\t\t\t\t\tfilePath: absoluteFilepath,\n\t\t\t\t\t})\n\t\t\t\t\t.then((postcssResult) => {\n\t\t\t\t\t\tif (postcssResult.stylelint.stylelintError && useCache) {\n\t\t\t\t\t\t\tdebug(`${absoluteFilepath} contains linting errors and will not be cached.`);\n\t\t\t\t\t\t\tfileCache.removeEntry(absoluteFilepath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * If we're fixing, save the file with changed code\n\t\t\t\t\t\t * @type {Promise<Error | void>}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlet fixFile = Promise.resolve();\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tpostcssResult.root &&\n\t\t\t\t\t\t\tpostcssResult.opts &&\n\t\t\t\t\t\t\t!postcssResult.stylelint.ignored &&\n\t\t\t\t\t\t\toptions.fix &&\n\t\t\t\t\t\t\t!postcssResult.stylelint.disableWritingFix\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// @ts-ignore TODO TYPES toString accepts 0 arguments\n\t\t\t\t\t\t\tconst fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tpostcssResult.root &&\n\t\t\t\t\t\t\t\tpostcssResult.root.source &&\n\t\t\t\t\t\t\t\t// @ts-ignore TODO TYPES css is unknown property\n\t\t\t\t\t\t\t\tpostcssResult.root.source.input.css !== fixedCss\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfixFile = writeFileAtomic(absoluteFilepath, fixedCss);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn fixFile.then(() =>\n\t\t\t\t\t\t\tstylelint._createStylelintResult(postcssResult, absoluteFilepath),\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\t// On any error, we should not cache the lint result\n\t\t\t\t\t\tfileCache.removeEntry(absoluteFilepath);\n\n\t\t\t\t\t\treturn handleError(stylelint, error, absoluteFilepath);\n\t\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn Promise.all(getStylelintResults);\n\t\t})\n\t\t.then((stylelintResults) => {\n\t\t\tif (useCache) {\n\t\t\t\tfileCache.reconcile();\n\t\t\t}\n\n\t\t\tconst rtn = prepareReturnValue(stylelintResults, options, formatterFunction);\n\n\t\t\tdebug(`Linting complete in ${Date.now() - startTime}ms`);\n\n\t\t\treturn rtn;\n\t\t});\n};\n\n/**\n * @param {FormatterIdentifier | undefined} selected\n * @returns {Formatter}\n */\nfunction getFormatterFunction(selected) {\n\t/** @type {Formatter} */\n\tlet formatterFunction;\n\n\tif (typeof selected === 'string') {\n\t\tformatterFunction = formatters[selected];\n\n\t\tif (formatterFunction === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`You must use a valid formatter option: ${getFormatterOptionsText()} or a function`,\n\t\t\t);\n\t\t}\n\t} else if (typeof selected === 'function') {\n\t\tformatterFunction = selected;\n\t} else {\n\t\tformatterFunction = formatters.json;\n\t}\n\n\treturn formatterFunction;\n}\n\n/**\n * @param {import('stylelint').StylelintInternalApi} stylelint\n * @param {any} error\n * @param {string} [filePath]\n * @return {Promise<StylelintResult>}\n */\nfunction handleError(stylelint, error, filePath = undefined) {\n\tif (error.name === 'CssSyntaxError') {\n\t\treturn createStylelintResult(stylelint, undefined, filePath, error);\n\t}\n\n\tthrow error;\n}\n"]},"metadata":{},"sourceType":"script"}