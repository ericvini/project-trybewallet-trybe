{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst beforeBlockString = require('../../utils/beforeBlockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'indentation';\nconst messages = ruleMessages(ruleName, {\n  expected: x => `Expected indentation of ${x}`\n});\n/**\n * @param {number|\"tab\"} space - Number of whitespaces to expect, or else\n *   keyword \"tab\" for single `\\t`\n * @param {object} [options]\n */\n\nfunction rule(space, options = {}, context) {\n  const isTab = space === 'tab';\n  const indentChar = isTab ? '\\t' : ' '.repeat(space);\n  const warningWord = isTab ? 'tab' : 'space';\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: space,\n      possible: [_.isNumber, 'tab']\n    }, {\n      actual: options,\n      possible: {\n        baseIndentLevel: [_.isNumber, 'auto'],\n        except: ['block', 'value', 'param'],\n        ignore: ['value', 'param', 'inside-parens'],\n        indentInsideParens: ['twice', 'once-at-root-twice-in-block'],\n        indentClosingBrace: [_.isBoolean]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    } // Cycle through all nodes using walk.\n\n\n    root.walk(node => {\n      if (node.type === 'root') {\n        // Ignore nested template literals root in css-in-js lang\n        return;\n      }\n\n      const nodeLevel = indentationLevel(node); // Cut out any * and _ hacks from `before`\n\n      const before = (node.raws.before || '').replace(/[*_]$/, '');\n      const after = node.raws.after || '';\n      const parent = node.parent;\n      const expectedOpeningBraceIndentation = indentChar.repeat(nodeLevel); // Only inspect the spaces before the node\n      // if this is the first node in root\n      // or there is a newline in the `before` string.\n      // (If there is no newline before a node,\n      // there is no \"indentation\" to check.)\n\n      const isFirstChild = parent.type === 'root' && parent.first === node;\n      const lastIndexOfNewline = before.lastIndexOf('\\n'); // Inspect whitespace in the `before` string that is\n      // *after* the *last* newline character,\n      // because anything besides that is not indentation for this node:\n      // it is some other kind of separation, checked by some separate rule\n\n      if ((lastIndexOfNewline !== -1 || isFirstChild && (!getDocument(parent) || parent.raws.beforeStart.endsWith('\\n'))) && before.slice(lastIndexOfNewline + 1) !== expectedOpeningBraceIndentation) {\n        if (context.fix) {\n          if (isFirstChild && _.isString(node.raws.before)) {\n            node.raws.before = node.raws.before.replace(/^[ \\t]*(?=\\S|$)/, expectedOpeningBraceIndentation);\n          }\n\n          node.raws.before = fixIndentation(node.raws.before, expectedOpeningBraceIndentation);\n        } else {\n          report({\n            message: messages.expected(legibleExpectation(nodeLevel)),\n            node,\n            result,\n            ruleName\n          });\n        }\n      } // Only blocks have the `after` string to check.\n      // Only inspect `after` strings that start with a newline;\n      // otherwise there's no indentation involved.\n      // And check `indentClosingBrace` to see if it should be indented an extra level.\n\n\n      const closingBraceLevel = options.indentClosingBrace ? nodeLevel + 1 : nodeLevel;\n      const expectedClosingBraceIndentation = indentChar.repeat(closingBraceLevel);\n\n      if (hasBlock(node) && after && after.includes('\\n') && after.slice(after.lastIndexOf('\\n') + 1) !== expectedClosingBraceIndentation) {\n        if (context.fix) {\n          node.raws.after = fixIndentation(node.raws.after, expectedClosingBraceIndentation);\n        } else {\n          report({\n            message: messages.expected(legibleExpectation(closingBraceLevel)),\n            node,\n            index: node.toString().length - 1,\n            result,\n            ruleName\n          });\n        }\n      } // If this is a declaration, check the value\n\n\n      if (node.value) {\n        checkValue(node, nodeLevel);\n      } // If this is a rule, check the selector\n\n\n      if (node.selector) {\n        checkSelector(node, nodeLevel);\n      } // If this is an at rule, check the params\n\n\n      if (node.type === 'atrule') {\n        checkAtRuleParams(node, nodeLevel);\n      }\n    });\n\n    function indentationLevel(node, level = 0) {\n      if (node.parent.type === 'root') {\n        return level + getRootBaseIndentLevel(node.parent, options.baseIndentLevel, space);\n      }\n\n      let calculatedLevel; // Indentation level equals the ancestor nodes\n      // separating this node from root; so recursively\n      // run this operation\n\n      calculatedLevel = indentationLevel(node.parent, level + 1); // If options.except includes \"block\",\n      // blocks are taken down one from their calculated level\n      // (all blocks are the same level as their parents)\n\n      if (optionsMatches(options, 'except', 'block') && (node.type === 'rule' || node.type === 'atrule') && hasBlock(node)) {\n        calculatedLevel--;\n      }\n\n      return calculatedLevel;\n    }\n\n    function checkValue(decl, declLevel) {\n      if (!decl.value.includes('\\n')) {\n        return;\n      }\n\n      if (optionsMatches(options, 'ignore', 'value')) {\n        return;\n      }\n\n      const declString = decl.toString();\n      const valueLevel = optionsMatches(options, 'except', 'value') ? declLevel : declLevel + 1;\n      checkMultilineBit(declString, valueLevel, decl);\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function checkSelector(rule, ruleLevel) {\n      const selector = rule.selector; // Less mixins have params, and they should be indented extra\n\n      if (rule.params) {\n        ruleLevel += 1;\n      }\n\n      checkMultilineBit(selector, ruleLevel, rule);\n    }\n\n    function checkAtRuleParams(atRule, ruleLevel) {\n      if (optionsMatches(options, 'ignore', 'param')) {\n        return;\n      } // @nest and SCSS's @at-root rules should be treated like regular rules, not expected\n      // to have their params (selectors) indented\n\n\n      const paramLevel = optionsMatches(options, 'except', 'param') || atRule.name === 'nest' || atRule.name === 'at-root' ? ruleLevel : ruleLevel + 1;\n      checkMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule);\n    }\n\n    function checkMultilineBit(source, newlineIndentLevel, node) {\n      if (!source.includes('\\n')) {\n        return;\n      } // Data for current node fixing\n\n\n      const fixPositions = []; // `outsideParens` because function arguments and also non-standard parenthesized stuff like\n      // Sass maps are ignored to allow for arbitrary indentation\n\n      let parentheticalDepth = 0;\n      styleSearch({\n        source,\n        target: '\\n',\n        outsideParens: optionsMatches(options, 'ignore', 'inside-parens')\n      }, (match, matchCount) => {\n        const precedesClosingParenthesis = /^[ \\t]*\\)/.test(source.slice(match.startIndex + 1));\n\n        if (optionsMatches(options, 'ignore', 'inside-parens') && (precedesClosingParenthesis || match.insideParens)) {\n          return;\n        }\n\n        let expectedIndentLevel = newlineIndentLevel; // Modififications for parenthetical content\n\n        if (!optionsMatches(options, 'ignore', 'inside-parens') && match.insideParens) {\n          // If the first match in is within parentheses, reduce the parenthesis penalty\n          if (matchCount === 1) parentheticalDepth -= 1; // Account for windows line endings\n\n          let newlineIndex = match.startIndex;\n\n          if (source[match.startIndex - 1] === '\\r') {\n            newlineIndex--;\n          }\n\n          const followsOpeningParenthesis = /\\([ \\t]*$/.test(source.slice(0, newlineIndex));\n\n          if (followsOpeningParenthesis) {\n            parentheticalDepth += 1;\n          }\n\n          const followsOpeningBrace = /{[ \\t]*$/.test(source.slice(0, newlineIndex));\n\n          if (followsOpeningBrace) {\n            parentheticalDepth += 1;\n          }\n\n          const startingClosingBrace = /^[ \\t]*}/.test(source.slice(match.startIndex + 1));\n\n          if (startingClosingBrace) {\n            parentheticalDepth -= 1;\n          }\n\n          expectedIndentLevel += parentheticalDepth; // Past this point, adjustments to parentheticalDepth affect next line\n\n          if (precedesClosingParenthesis) {\n            parentheticalDepth -= 1;\n          }\n\n          switch (options.indentInsideParens) {\n            case 'twice':\n              if (!precedesClosingParenthesis || options.indentClosingBrace) {\n                expectedIndentLevel += 1;\n              }\n\n              break;\n\n            case 'once-at-root-twice-in-block':\n              if (node.parent === node.root()) {\n                if (precedesClosingParenthesis && !options.indentClosingBrace) {\n                  expectedIndentLevel -= 1;\n                }\n\n                break;\n              }\n\n              if (!precedesClosingParenthesis || options.indentClosingBrace) {\n                expectedIndentLevel += 1;\n              }\n\n              break;\n\n            default:\n              if (precedesClosingParenthesis && !options.indentClosingBrace) {\n                expectedIndentLevel -= 1;\n              }\n\n          }\n        } // Starting at the index after the newline, we want to\n        // check that the whitespace characters (excluding newlines) before the first\n        // non-whitespace character equal the expected indentation\n\n\n        const afterNewlineSpaceMatches = /^([ \\t]*)\\S/.exec(source.slice(match.startIndex + 1));\n\n        if (!afterNewlineSpaceMatches) {\n          return;\n        }\n\n        const afterNewlineSpace = afterNewlineSpaceMatches[1];\n        const expectedIndentation = indentChar.repeat(expectedIndentLevel > 0 ? expectedIndentLevel : 0);\n\n        if (afterNewlineSpace !== expectedIndentation) {\n          if (context.fix) {\n            // Adding fixes position in reverse order, because if we change indent in the beginning of the string it will break all following fixes for that string\n            fixPositions.unshift({\n              expectedIndentation,\n              currentIndentation: afterNewlineSpace,\n              startIndex: match.startIndex\n            });\n          } else {\n            report({\n              message: messages.expected(legibleExpectation(expectedIndentLevel)),\n              node,\n              index: match.startIndex + afterNewlineSpace.length + 1,\n              result,\n              ruleName\n            });\n          }\n        }\n      });\n\n      if (fixPositions.length) {\n        if (node.type === 'rule') {\n          fixPositions.forEach(fixPosition => {\n            node.selector = replaceIndentation(node.selector, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex);\n          });\n        }\n\n        if (node.type === 'decl') {\n          const declProp = node.prop;\n          const declBetween = node.raws.between;\n          fixPositions.forEach(fixPosition => {\n            if (fixPosition.startIndex < declProp.length + declBetween.length) {\n              node.raws.between = replaceIndentation(declBetween, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - declProp.length);\n            } else {\n              node.value = replaceIndentation(node.value, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - declProp.length - declBetween.length);\n            }\n          });\n        }\n\n        if (node.type === 'atrule') {\n          const atRuleName = node.name;\n          const atRuleAfterName = node.raws.afterName;\n          const atRuleParams = node.params;\n          fixPositions.forEach(fixPosition => {\n            // 1 — it's a @ length\n            if (fixPosition.startIndex < 1 + atRuleName.length + atRuleAfterName.length) {\n              node.raws.afterName = replaceIndentation(atRuleAfterName, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - atRuleName.length - 1);\n            } else {\n              node.params = replaceIndentation(atRuleParams, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - atRuleName.length - atRuleAfterName.length - 1);\n            }\n          });\n        }\n      }\n    }\n  };\n\n  function legibleExpectation(level) {\n    const count = isTab ? level : level * space;\n    const quantifiedWarningWord = count === 1 ? warningWord : `${warningWord}s`;\n    return `${count} ${quantifiedWarningWord}`;\n  }\n}\n\nfunction getRootBaseIndentLevel(root, baseIndentLevel, space) {\n  const document = getDocument(root);\n\n  if (!document) {\n    return 0;\n  }\n\n  let indentLevel = root.source.baseIndentLevel;\n\n  if (!Number.isSafeInteger(indentLevel)) {\n    indentLevel = inferRootIndentLevel(root, baseIndentLevel, () => inferDocIndentSize(document, space));\n    root.source.baseIndentLevel = indentLevel;\n  }\n\n  return indentLevel;\n}\n\nfunction getDocument(node) {\n  const document = node.document;\n\n  if (document) {\n    return document;\n  }\n\n  const root = node.root();\n  return root && root.document;\n}\n\nfunction inferDocIndentSize(document, space) {\n  let indentSize = document.source.indentSize;\n\n  if (Number.isSafeInteger(indentSize)) {\n    return indentSize;\n  }\n\n  const source = document.source.input.css;\n  const indents = source.match(/^ *(?=\\S)/gm);\n\n  if (indents) {\n    const scores = {};\n    let lastIndentSize = 0;\n    let lastLeadingSpacesLength = 0;\n\n    const vote = leadingSpacesLength => {\n      if (leadingSpacesLength) {\n        lastIndentSize = Math.abs(leadingSpacesLength - lastLeadingSpacesLength) || lastIndentSize;\n\n        if (lastIndentSize > 1) {\n          if (scores[lastIndentSize]) {\n            scores[lastIndentSize]++;\n          } else {\n            scores[lastIndentSize] = 1;\n          }\n        }\n      } else {\n        lastIndentSize = 0;\n      }\n\n      lastLeadingSpacesLength = leadingSpacesLength;\n    };\n\n    indents.forEach(leadingSpaces => {\n      vote(leadingSpaces.length);\n    });\n    let bestScore = 0;\n\n    for (const indentSizeDate in scores) {\n      if (Object.prototype.hasOwnProperty.call(scores, indentSizeDate)) {\n        const score = scores[indentSizeDate];\n\n        if (score > bestScore) {\n          bestScore = score;\n          indentSize = indentSizeDate;\n        }\n      }\n    }\n  }\n\n  indentSize = Number(indentSize) || indents && indents[0].length || Number(space) || 2;\n  document.source.indentSize = indentSize;\n  return indentSize;\n}\n\nfunction inferRootIndentLevel(root, baseIndentLevel, indentSize) {\n  function getIndentLevel(indent) {\n    let tabCount = indent.match(/\\t/g);\n    tabCount = tabCount ? tabCount.length : 0;\n    let spaceCount = indent.match(/ /g);\n    spaceCount = spaceCount ? Math.round(spaceCount.length / indentSize()) : 0;\n    return tabCount + spaceCount;\n  }\n\n  if (!Number.isSafeInteger(baseIndentLevel)) {\n    let source = root.source.input.css;\n    source = source.replace(/^[^\\r\\n]+/, firstLine => {\n      if (/(?:^|\\n)([ \\t]*)$/.test(root.raws.beforeStart)) {\n        return RegExp.$1 + firstLine;\n      }\n\n      return '';\n    });\n    const indents = source.match(/^[ \\t]*(?=\\S)/gm);\n\n    if (indents) {\n      return Math.min(...indents.map(getIndentLevel));\n    }\n\n    baseIndentLevel = 1;\n  }\n\n  const indents = [];\n  const foundIndents = /(?:^|\\n)([ \\t]*)\\S[^\\r\\n]*(?:\\r?\\n\\s*)*$/m.exec(root.raws.beforeStart); // The indent level of the CSS code block in non-CSS-like files is determined by the shortest indent of non-empty line.\n\n  if (foundIndents) {\n    let shortest = Number.MAX_SAFE_INTEGER;\n    let i = 0;\n\n    while (++i < foundIndents.length) {\n      const current = getIndentLevel(foundIndents[i]);\n\n      if (current < shortest) {\n        shortest = current;\n\n        if (shortest === 0) {\n          break;\n        }\n      }\n    }\n\n    if (shortest !== Number.MAX_SAFE_INTEGER) {\n      indents.push(new Array(shortest).fill(' ').join(''));\n    }\n  }\n\n  const after = root.raws.after;\n\n  if (after) {\n    let afterEnd;\n\n    if (after.endsWith('\\n')) {\n      const document = root.document;\n\n      if (document) {\n        const nextRoot = document.nodes[document.nodes.indexOf(root) + 1];\n\n        if (nextRoot) {\n          afterEnd = nextRoot.raws.beforeStart;\n        } else {\n          afterEnd = document.raws.afterEnd;\n        }\n      } else {\n        // Nested root node in css-in-js lang\n        const parent = root.parent;\n        const nextRoot = parent.nodes[parent.nodes.indexOf(root) + 1];\n\n        if (nextRoot) {\n          afterEnd = nextRoot.raws.beforeStart;\n        } else {\n          afterEnd = root.raws.afterEnd;\n        }\n      }\n    } else {\n      afterEnd = after;\n    }\n\n    indents.push(afterEnd.match(/^[ \\t]*/)[0]);\n  }\n\n  if (indents.length) {\n    return Math.max(...indents.map(getIndentLevel)) + baseIndentLevel;\n  }\n\n  return baseIndentLevel;\n}\n\nfunction fixIndentation(str, whitespace) {\n  if (!_.isString(str)) {\n    return str;\n  }\n\n  return str.replace(/\\n[ \\t]*(?=\\S|$)/g, `\\n${whitespace}`);\n}\n\nfunction replaceIndentation(input, searchString, replaceString, startIndex) {\n  const offset = startIndex + 1;\n  const stringStart = input.slice(0, offset);\n  const stringEnd = input.slice(offset + searchString.length);\n  return stringStart + replaceString + stringEnd;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/indentation/index.js"],"names":["_","require","beforeBlockString","hasBlock","optionsMatches","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","expected","x","rule","space","options","context","isTab","indentChar","repeat","warningWord","root","result","validOptions","actual","possible","isNumber","baseIndentLevel","except","ignore","indentInsideParens","indentClosingBrace","isBoolean","optional","walk","node","type","nodeLevel","indentationLevel","before","raws","replace","after","parent","expectedOpeningBraceIndentation","isFirstChild","first","lastIndexOfNewline","lastIndexOf","getDocument","beforeStart","endsWith","slice","fix","isString","fixIndentation","message","legibleExpectation","closingBraceLevel","expectedClosingBraceIndentation","includes","index","toString","length","value","checkValue","selector","checkSelector","checkAtRuleParams","level","getRootBaseIndentLevel","calculatedLevel","decl","declLevel","declString","valueLevel","checkMultilineBit","ruleLevel","params","atRule","paramLevel","name","trim","source","newlineIndentLevel","fixPositions","parentheticalDepth","target","outsideParens","match","matchCount","precedesClosingParenthesis","test","startIndex","insideParens","expectedIndentLevel","newlineIndex","followsOpeningParenthesis","followsOpeningBrace","startingClosingBrace","afterNewlineSpaceMatches","exec","afterNewlineSpace","expectedIndentation","unshift","currentIndentation","forEach","fixPosition","replaceIndentation","declProp","prop","declBetween","between","atRuleName","atRuleAfterName","afterName","atRuleParams","count","quantifiedWarningWord","document","indentLevel","Number","isSafeInteger","inferRootIndentLevel","inferDocIndentSize","indentSize","input","css","indents","scores","lastIndentSize","lastLeadingSpacesLength","vote","leadingSpacesLength","Math","abs","leadingSpaces","bestScore","indentSizeDate","Object","prototype","hasOwnProperty","call","score","getIndentLevel","indent","tabCount","spaceCount","round","firstLine","RegExp","$1","min","map","foundIndents","shortest","MAX_SAFE_INTEGER","i","current","push","Array","fill","join","afterEnd","nextRoot","nodes","indexOf","max","str","whitespace","searchString","replaceString","offset","stringStart","stringEnd","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst beforeBlockString = require('../../utils/beforeBlockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'indentation';\nconst messages = ruleMessages(ruleName, {\n\texpected: (x) => `Expected indentation of ${x}`,\n});\n\n/**\n * @param {number|\"tab\"} space - Number of whitespaces to expect, or else\n *   keyword \"tab\" for single `\\t`\n * @param {object} [options]\n */\nfunction rule(space, options = {}, context) {\n\tconst isTab = space === 'tab';\n\tconst indentChar = isTab ? '\\t' : ' '.repeat(space);\n\tconst warningWord = isTab ? 'tab' : 'space';\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: space,\n\t\t\t\tpossible: [_.isNumber, 'tab'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tbaseIndentLevel: [_.isNumber, 'auto'],\n\t\t\t\t\texcept: ['block', 'value', 'param'],\n\t\t\t\t\tignore: ['value', 'param', 'inside-parens'],\n\t\t\t\t\tindentInsideParens: ['twice', 'once-at-root-twice-in-block'],\n\t\t\t\t\tindentClosingBrace: [_.isBoolean],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Cycle through all nodes using walk.\n\t\troot.walk((node) => {\n\t\t\tif (node.type === 'root') {\n\t\t\t\t// Ignore nested template literals root in css-in-js lang\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nodeLevel = indentationLevel(node);\n\n\t\t\t// Cut out any * and _ hacks from `before`\n\t\t\tconst before = (node.raws.before || '').replace(/[*_]$/, '');\n\t\t\tconst after = node.raws.after || '';\n\t\t\tconst parent = node.parent;\n\n\t\t\tconst expectedOpeningBraceIndentation = indentChar.repeat(nodeLevel);\n\n\t\t\t// Only inspect the spaces before the node\n\t\t\t// if this is the first node in root\n\t\t\t// or there is a newline in the `before` string.\n\t\t\t// (If there is no newline before a node,\n\t\t\t// there is no \"indentation\" to check.)\n\t\t\tconst isFirstChild = parent.type === 'root' && parent.first === node;\n\t\t\tconst lastIndexOfNewline = before.lastIndexOf('\\n');\n\n\t\t\t// Inspect whitespace in the `before` string that is\n\t\t\t// *after* the *last* newline character,\n\t\t\t// because anything besides that is not indentation for this node:\n\t\t\t// it is some other kind of separation, checked by some separate rule\n\t\t\tif (\n\t\t\t\t(lastIndexOfNewline !== -1 ||\n\t\t\t\t\t(isFirstChild && (!getDocument(parent) || parent.raws.beforeStart.endsWith('\\n')))) &&\n\t\t\t\tbefore.slice(lastIndexOfNewline + 1) !== expectedOpeningBraceIndentation\n\t\t\t) {\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tif (isFirstChild && _.isString(node.raws.before)) {\n\t\t\t\t\t\tnode.raws.before = node.raws.before.replace(\n\t\t\t\t\t\t\t/^[ \\t]*(?=\\S|$)/,\n\t\t\t\t\t\t\texpectedOpeningBraceIndentation,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tnode.raws.before = fixIndentation(node.raws.before, expectedOpeningBraceIndentation);\n\t\t\t\t} else {\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: messages.expected(legibleExpectation(nodeLevel)),\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Only blocks have the `after` string to check.\n\t\t\t// Only inspect `after` strings that start with a newline;\n\t\t\t// otherwise there's no indentation involved.\n\t\t\t// And check `indentClosingBrace` to see if it should be indented an extra level.\n\t\t\tconst closingBraceLevel = options.indentClosingBrace ? nodeLevel + 1 : nodeLevel;\n\t\t\tconst expectedClosingBraceIndentation = indentChar.repeat(closingBraceLevel);\n\n\t\t\tif (\n\t\t\t\thasBlock(node) &&\n\t\t\t\tafter &&\n\t\t\t\tafter.includes('\\n') &&\n\t\t\t\tafter.slice(after.lastIndexOf('\\n') + 1) !== expectedClosingBraceIndentation\n\t\t\t) {\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tnode.raws.after = fixIndentation(node.raws.after, expectedClosingBraceIndentation);\n\t\t\t\t} else {\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: messages.expected(legibleExpectation(closingBraceLevel)),\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tindex: node.toString().length - 1,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is a declaration, check the value\n\t\t\tif (node.value) {\n\t\t\t\tcheckValue(node, nodeLevel);\n\t\t\t}\n\n\t\t\t// If this is a rule, check the selector\n\t\t\tif (node.selector) {\n\t\t\t\tcheckSelector(node, nodeLevel);\n\t\t\t}\n\n\t\t\t// If this is an at rule, check the params\n\t\t\tif (node.type === 'atrule') {\n\t\t\t\tcheckAtRuleParams(node, nodeLevel);\n\t\t\t}\n\t\t});\n\n\t\tfunction indentationLevel(node, level = 0) {\n\t\t\tif (node.parent.type === 'root') {\n\t\t\t\treturn level + getRootBaseIndentLevel(node.parent, options.baseIndentLevel, space);\n\t\t\t}\n\n\t\t\tlet calculatedLevel;\n\n\t\t\t// Indentation level equals the ancestor nodes\n\t\t\t// separating this node from root; so recursively\n\t\t\t// run this operation\n\t\t\tcalculatedLevel = indentationLevel(node.parent, level + 1);\n\n\t\t\t// If options.except includes \"block\",\n\t\t\t// blocks are taken down one from their calculated level\n\t\t\t// (all blocks are the same level as their parents)\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'except', 'block') &&\n\t\t\t\t(node.type === 'rule' || node.type === 'atrule') &&\n\t\t\t\thasBlock(node)\n\t\t\t) {\n\t\t\t\tcalculatedLevel--;\n\t\t\t}\n\n\t\t\treturn calculatedLevel;\n\t\t}\n\n\t\tfunction checkValue(decl, declLevel) {\n\t\t\tif (!decl.value.includes('\\n')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (optionsMatches(options, 'ignore', 'value')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst declString = decl.toString();\n\t\t\tconst valueLevel = optionsMatches(options, 'except', 'value') ? declLevel : declLevel + 1;\n\n\t\t\tcheckMultilineBit(declString, valueLevel, decl);\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction checkSelector(rule, ruleLevel) {\n\t\t\tconst selector = rule.selector;\n\n\t\t\t// Less mixins have params, and they should be indented extra\n\t\t\tif (rule.params) {\n\t\t\t\truleLevel += 1;\n\t\t\t}\n\n\t\t\tcheckMultilineBit(selector, ruleLevel, rule);\n\t\t}\n\n\t\tfunction checkAtRuleParams(atRule, ruleLevel) {\n\t\t\tif (optionsMatches(options, 'ignore', 'param')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// @nest and SCSS's @at-root rules should be treated like regular rules, not expected\n\t\t\t// to have their params (selectors) indented\n\t\t\tconst paramLevel =\n\t\t\t\toptionsMatches(options, 'except', 'param') ||\n\t\t\t\tatRule.name === 'nest' ||\n\t\t\t\tatRule.name === 'at-root'\n\t\t\t\t\t? ruleLevel\n\t\t\t\t\t: ruleLevel + 1;\n\n\t\t\tcheckMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule);\n\t\t}\n\n\t\tfunction checkMultilineBit(source, newlineIndentLevel, node) {\n\t\t\tif (!source.includes('\\n')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Data for current node fixing\n\t\t\tconst fixPositions = [];\n\n\t\t\t// `outsideParens` because function arguments and also non-standard parenthesized stuff like\n\t\t\t// Sass maps are ignored to allow for arbitrary indentation\n\t\t\tlet parentheticalDepth = 0;\n\n\t\t\tstyleSearch(\n\t\t\t\t{\n\t\t\t\t\tsource,\n\t\t\t\t\ttarget: '\\n',\n\t\t\t\t\toutsideParens: optionsMatches(options, 'ignore', 'inside-parens'),\n\t\t\t\t},\n\t\t\t\t(match, matchCount) => {\n\t\t\t\t\tconst precedesClosingParenthesis = /^[ \\t]*\\)/.test(source.slice(match.startIndex + 1));\n\n\t\t\t\t\tif (\n\t\t\t\t\t\toptionsMatches(options, 'ignore', 'inside-parens') &&\n\t\t\t\t\t\t(precedesClosingParenthesis || match.insideParens)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet expectedIndentLevel = newlineIndentLevel;\n\n\t\t\t\t\t// Modififications for parenthetical content\n\t\t\t\t\tif (!optionsMatches(options, 'ignore', 'inside-parens') && match.insideParens) {\n\t\t\t\t\t\t// If the first match in is within parentheses, reduce the parenthesis penalty\n\t\t\t\t\t\tif (matchCount === 1) parentheticalDepth -= 1;\n\n\t\t\t\t\t\t// Account for windows line endings\n\t\t\t\t\t\tlet newlineIndex = match.startIndex;\n\n\t\t\t\t\t\tif (source[match.startIndex - 1] === '\\r') {\n\t\t\t\t\t\t\tnewlineIndex--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst followsOpeningParenthesis = /\\([ \\t]*$/.test(source.slice(0, newlineIndex));\n\n\t\t\t\t\t\tif (followsOpeningParenthesis) {\n\t\t\t\t\t\t\tparentheticalDepth += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst followsOpeningBrace = /{[ \\t]*$/.test(source.slice(0, newlineIndex));\n\n\t\t\t\t\t\tif (followsOpeningBrace) {\n\t\t\t\t\t\t\tparentheticalDepth += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst startingClosingBrace = /^[ \\t]*}/.test(source.slice(match.startIndex + 1));\n\n\t\t\t\t\t\tif (startingClosingBrace) {\n\t\t\t\t\t\t\tparentheticalDepth -= 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texpectedIndentLevel += parentheticalDepth;\n\n\t\t\t\t\t\t// Past this point, adjustments to parentheticalDepth affect next line\n\n\t\t\t\t\t\tif (precedesClosingParenthesis) {\n\t\t\t\t\t\t\tparentheticalDepth -= 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (options.indentInsideParens) {\n\t\t\t\t\t\t\tcase 'twice':\n\t\t\t\t\t\t\t\tif (!precedesClosingParenthesis || options.indentClosingBrace) {\n\t\t\t\t\t\t\t\t\texpectedIndentLevel += 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'once-at-root-twice-in-block':\n\t\t\t\t\t\t\t\tif (node.parent === node.root()) {\n\t\t\t\t\t\t\t\t\tif (precedesClosingParenthesis && !options.indentClosingBrace) {\n\t\t\t\t\t\t\t\t\t\texpectedIndentLevel -= 1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!precedesClosingParenthesis || options.indentClosingBrace) {\n\t\t\t\t\t\t\t\t\texpectedIndentLevel += 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (precedesClosingParenthesis && !options.indentClosingBrace) {\n\t\t\t\t\t\t\t\t\texpectedIndentLevel -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Starting at the index after the newline, we want to\n\t\t\t\t\t// check that the whitespace characters (excluding newlines) before the first\n\t\t\t\t\t// non-whitespace character equal the expected indentation\n\t\t\t\t\tconst afterNewlineSpaceMatches = /^([ \\t]*)\\S/.exec(source.slice(match.startIndex + 1));\n\n\t\t\t\t\tif (!afterNewlineSpaceMatches) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst afterNewlineSpace = afterNewlineSpaceMatches[1];\n\t\t\t\t\tconst expectedIndentation = indentChar.repeat(\n\t\t\t\t\t\texpectedIndentLevel > 0 ? expectedIndentLevel : 0,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (afterNewlineSpace !== expectedIndentation) {\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t// Adding fixes position in reverse order, because if we change indent in the beginning of the string it will break all following fixes for that string\n\t\t\t\t\t\t\tfixPositions.unshift({\n\t\t\t\t\t\t\t\texpectedIndentation,\n\t\t\t\t\t\t\t\tcurrentIndentation: afterNewlineSpace,\n\t\t\t\t\t\t\t\tstartIndex: match.startIndex,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treport({\n\t\t\t\t\t\t\t\tmessage: messages.expected(legibleExpectation(expectedIndentLevel)),\n\t\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t\tindex: match.startIndex + afterNewlineSpace.length + 1,\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (fixPositions.length) {\n\t\t\t\tif (node.type === 'rule') {\n\t\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\t\tnode.selector = replaceIndentation(\n\t\t\t\t\t\t\tnode.selector,\n\t\t\t\t\t\t\tfixPosition.currentIndentation,\n\t\t\t\t\t\t\tfixPosition.expectedIndentation,\n\t\t\t\t\t\t\tfixPosition.startIndex,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'decl') {\n\t\t\t\t\tconst declProp = node.prop;\n\t\t\t\t\tconst declBetween = node.raws.between;\n\n\t\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\t\tif (fixPosition.startIndex < declProp.length + declBetween.length) {\n\t\t\t\t\t\t\tnode.raws.between = replaceIndentation(\n\t\t\t\t\t\t\t\tdeclBetween,\n\t\t\t\t\t\t\t\tfixPosition.currentIndentation,\n\t\t\t\t\t\t\t\tfixPosition.expectedIndentation,\n\t\t\t\t\t\t\t\tfixPosition.startIndex - declProp.length,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.value = replaceIndentation(\n\t\t\t\t\t\t\t\tnode.value,\n\t\t\t\t\t\t\t\tfixPosition.currentIndentation,\n\t\t\t\t\t\t\t\tfixPosition.expectedIndentation,\n\t\t\t\t\t\t\t\tfixPosition.startIndex - declProp.length - declBetween.length,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'atrule') {\n\t\t\t\t\tconst atRuleName = node.name;\n\t\t\t\t\tconst atRuleAfterName = node.raws.afterName;\n\t\t\t\t\tconst atRuleParams = node.params;\n\n\t\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\t\t// 1 — it's a @ length\n\t\t\t\t\t\tif (fixPosition.startIndex < 1 + atRuleName.length + atRuleAfterName.length) {\n\t\t\t\t\t\t\tnode.raws.afterName = replaceIndentation(\n\t\t\t\t\t\t\t\tatRuleAfterName,\n\t\t\t\t\t\t\t\tfixPosition.currentIndentation,\n\t\t\t\t\t\t\t\tfixPosition.expectedIndentation,\n\t\t\t\t\t\t\t\tfixPosition.startIndex - atRuleName.length - 1,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.params = replaceIndentation(\n\t\t\t\t\t\t\t\tatRuleParams,\n\t\t\t\t\t\t\t\tfixPosition.currentIndentation,\n\t\t\t\t\t\t\t\tfixPosition.expectedIndentation,\n\t\t\t\t\t\t\t\tfixPosition.startIndex - atRuleName.length - atRuleAfterName.length - 1,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction legibleExpectation(level) {\n\t\tconst count = isTab ? level : level * space;\n\t\tconst quantifiedWarningWord = count === 1 ? warningWord : `${warningWord}s`;\n\n\t\treturn `${count} ${quantifiedWarningWord}`;\n\t}\n}\n\nfunction getRootBaseIndentLevel(root, baseIndentLevel, space) {\n\tconst document = getDocument(root);\n\n\tif (!document) {\n\t\treturn 0;\n\t}\n\n\tlet indentLevel = root.source.baseIndentLevel;\n\n\tif (!Number.isSafeInteger(indentLevel)) {\n\t\tindentLevel = inferRootIndentLevel(root, baseIndentLevel, () =>\n\t\t\tinferDocIndentSize(document, space),\n\t\t);\n\t\troot.source.baseIndentLevel = indentLevel;\n\t}\n\n\treturn indentLevel;\n}\n\nfunction getDocument(node) {\n\tconst document = node.document;\n\n\tif (document) {\n\t\treturn document;\n\t}\n\n\tconst root = node.root();\n\n\treturn root && root.document;\n}\n\nfunction inferDocIndentSize(document, space) {\n\tlet indentSize = document.source.indentSize;\n\n\tif (Number.isSafeInteger(indentSize)) {\n\t\treturn indentSize;\n\t}\n\n\tconst source = document.source.input.css;\n\tconst indents = source.match(/^ *(?=\\S)/gm);\n\n\tif (indents) {\n\t\tconst scores = {};\n\t\tlet lastIndentSize = 0;\n\t\tlet lastLeadingSpacesLength = 0;\n\t\tconst vote = (leadingSpacesLength) => {\n\t\t\tif (leadingSpacesLength) {\n\t\t\t\tlastIndentSize = Math.abs(leadingSpacesLength - lastLeadingSpacesLength) || lastIndentSize;\n\n\t\t\t\tif (lastIndentSize > 1) {\n\t\t\t\t\tif (scores[lastIndentSize]) {\n\t\t\t\t\t\tscores[lastIndentSize]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscores[lastIndentSize] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlastIndentSize = 0;\n\t\t\t}\n\n\t\t\tlastLeadingSpacesLength = leadingSpacesLength;\n\t\t};\n\n\t\tindents.forEach((leadingSpaces) => {\n\t\t\tvote(leadingSpaces.length);\n\t\t});\n\n\t\tlet bestScore = 0;\n\n\t\tfor (const indentSizeDate in scores) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(scores, indentSizeDate)) {\n\t\t\t\tconst score = scores[indentSizeDate];\n\n\t\t\t\tif (score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tindentSize = indentSizeDate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tindentSize = Number(indentSize) || (indents && indents[0].length) || Number(space) || 2;\n\tdocument.source.indentSize = indentSize;\n\n\treturn indentSize;\n}\n\nfunction inferRootIndentLevel(root, baseIndentLevel, indentSize) {\n\tfunction getIndentLevel(indent) {\n\t\tlet tabCount = indent.match(/\\t/g);\n\n\t\ttabCount = tabCount ? tabCount.length : 0;\n\t\tlet spaceCount = indent.match(/ /g);\n\n\t\tspaceCount = spaceCount ? Math.round(spaceCount.length / indentSize()) : 0;\n\n\t\treturn tabCount + spaceCount;\n\t}\n\n\tif (!Number.isSafeInteger(baseIndentLevel)) {\n\t\tlet source = root.source.input.css;\n\n\t\tsource = source.replace(/^[^\\r\\n]+/, (firstLine) => {\n\t\t\tif (/(?:^|\\n)([ \\t]*)$/.test(root.raws.beforeStart)) {\n\t\t\t\treturn RegExp.$1 + firstLine;\n\t\t\t}\n\n\t\t\treturn '';\n\t\t});\n\n\t\tconst indents = source.match(/^[ \\t]*(?=\\S)/gm);\n\n\t\tif (indents) {\n\t\t\treturn Math.min(...indents.map(getIndentLevel));\n\t\t}\n\n\t\tbaseIndentLevel = 1;\n\t}\n\n\tconst indents = [];\n\tconst foundIndents = /(?:^|\\n)([ \\t]*)\\S[^\\r\\n]*(?:\\r?\\n\\s*)*$/m.exec(root.raws.beforeStart);\n\n\t// The indent level of the CSS code block in non-CSS-like files is determined by the shortest indent of non-empty line.\n\tif (foundIndents) {\n\t\tlet shortest = Number.MAX_SAFE_INTEGER;\n\t\tlet i = 0;\n\n\t\twhile (++i < foundIndents.length) {\n\t\t\tconst current = getIndentLevel(foundIndents[i]);\n\n\t\t\tif (current < shortest) {\n\t\t\t\tshortest = current;\n\n\t\t\t\tif (shortest === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (shortest !== Number.MAX_SAFE_INTEGER) {\n\t\t\tindents.push(new Array(shortest).fill(' ').join(''));\n\t\t}\n\t}\n\n\tconst after = root.raws.after;\n\n\tif (after) {\n\t\tlet afterEnd;\n\n\t\tif (after.endsWith('\\n')) {\n\t\t\tconst document = root.document;\n\n\t\t\tif (document) {\n\t\t\t\tconst nextRoot = document.nodes[document.nodes.indexOf(root) + 1];\n\n\t\t\t\tif (nextRoot) {\n\t\t\t\t\tafterEnd = nextRoot.raws.beforeStart;\n\t\t\t\t} else {\n\t\t\t\t\tafterEnd = document.raws.afterEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Nested root node in css-in-js lang\n\t\t\t\tconst parent = root.parent;\n\n\t\t\t\tconst nextRoot = parent.nodes[parent.nodes.indexOf(root) + 1];\n\n\t\t\t\tif (nextRoot) {\n\t\t\t\t\tafterEnd = nextRoot.raws.beforeStart;\n\t\t\t\t} else {\n\t\t\t\t\tafterEnd = root.raws.afterEnd;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tafterEnd = after;\n\t\t}\n\n\t\tindents.push(afterEnd.match(/^[ \\t]*/)[0]);\n\t}\n\n\tif (indents.length) {\n\t\treturn Math.max(...indents.map(getIndentLevel)) + baseIndentLevel;\n\t}\n\n\treturn baseIndentLevel;\n}\n\nfunction fixIndentation(str, whitespace) {\n\tif (!_.isString(str)) {\n\t\treturn str;\n\t}\n\n\treturn str.replace(/\\n[ \\t]*(?=\\S|$)/g, `\\n${whitespace}`);\n}\n\nfunction replaceIndentation(input, searchString, replaceString, startIndex) {\n\tconst offset = startIndex + 1;\n\tconst stringStart = input.slice(0, offset);\n\tconst stringEnd = input.slice(offset + searchString.length);\n\n\treturn stringStart + replaceString + stringEnd;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}