{"ast":null,"code":"'use strict';\n\nconst balancedMatch = require('balanced-match');\n/**\n * Replace all of the characters that are arguments to a certain\n * CSS function with some innocuous character.\n *\n * This is useful if you need to use a RegExp to find a string\n * but want to ignore matches in certain functions (e.g. `url()`,\n * which might contain all kinds of false positives).\n *\n * For example:\n * blurFunctionArguments(\"abc url(abc) abc\", \"url\") === \"abc url(```) abc\"\n *\n * @param {string} source\n * @param {string} functionName\n * @return {string} - The result string, with the function arguments \"blurred\"\n */\n\n\nmodule.exports = function (source, functionName, blurChar = '`') {\n  const nameWithParen = `${functionName.toLowerCase()}(`;\n  const lowerCaseSource = source.toLowerCase();\n\n  if (!lowerCaseSource.includes(nameWithParen)) {\n    return source;\n  }\n\n  const functionNameLength = functionName.length;\n  let result = source;\n  let searchStartIndex = 0;\n\n  while (lowerCaseSource.includes(nameWithParen, searchStartIndex)) {\n    const openingParenIndex = lowerCaseSource.indexOf(nameWithParen, searchStartIndex) + functionNameLength;\n    const parensMatch = balancedMatch('(', ')', lowerCaseSource.slice(openingParenIndex));\n\n    if (!parensMatch) {\n      throw new Error(`No parens match: \"${source}\"`);\n    }\n\n    const closingParenIndex = parensMatch.end + openingParenIndex;\n    const argumentsLength = closingParenIndex - openingParenIndex - 1;\n    result = result.slice(0, openingParenIndex + 1) + blurChar.repeat(argumentsLength) + result.slice(closingParenIndex);\n    searchStartIndex = closingParenIndex;\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/blurFunctionArguments.js"],"names":["balancedMatch","require","module","exports","source","functionName","blurChar","nameWithParen","toLowerCase","lowerCaseSource","includes","functionNameLength","length","result","searchStartIndex","openingParenIndex","indexOf","parensMatch","slice","Error","closingParenIndex","end","argumentsLength","repeat"],"mappings":"AAAA;;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,gBAAD,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,MAAV,EAAkBC,YAAlB,EAAgCC,QAAQ,GAAG,GAA3C,EAAgD;AAChE,QAAMC,aAAa,GAAI,GAAEF,YAAY,CAACG,WAAb,EAA2B,GAApD;AACA,QAAMC,eAAe,GAAGL,MAAM,CAACI,WAAP,EAAxB;;AAEA,MAAI,CAACC,eAAe,CAACC,QAAhB,CAAyBH,aAAzB,CAAL,EAA8C;AAC7C,WAAOH,MAAP;AACA;;AAED,QAAMO,kBAAkB,GAAGN,YAAY,CAACO,MAAxC;AAEA,MAAIC,MAAM,GAAGT,MAAb;AACA,MAAIU,gBAAgB,GAAG,CAAvB;;AAEA,SAAOL,eAAe,CAACC,QAAhB,CAAyBH,aAAzB,EAAwCO,gBAAxC,CAAP,EAAkE;AACjE,UAAMC,iBAAiB,GACtBN,eAAe,CAACO,OAAhB,CAAwBT,aAAxB,EAAuCO,gBAAvC,IAA2DH,kBAD5D;AAEA,UAAMM,WAAW,GAAGjB,aAAa,CAAC,GAAD,EAAM,GAAN,EAAWS,eAAe,CAACS,KAAhB,CAAsBH,iBAAtB,CAAX,CAAjC;;AAEA,QAAI,CAACE,WAAL,EAAkB;AACjB,YAAM,IAAIE,KAAJ,CAAW,qBAAoBf,MAAO,GAAtC,CAAN;AACA;;AAED,UAAMgB,iBAAiB,GAAGH,WAAW,CAACI,GAAZ,GAAkBN,iBAA5C;AACA,UAAMO,eAAe,GAAGF,iBAAiB,GAAGL,iBAApB,GAAwC,CAAhE;AAEAF,IAAAA,MAAM,GACLA,MAAM,CAACK,KAAP,CAAa,CAAb,EAAgBH,iBAAiB,GAAG,CAApC,IACAT,QAAQ,CAACiB,MAAT,CAAgBD,eAAhB,CADA,GAEAT,MAAM,CAACK,KAAP,CAAaE,iBAAb,CAHD;AAIAN,IAAAA,gBAAgB,GAAGM,iBAAnB;AACA;;AAED,SAAOP,MAAP;AACA,CAjCD","sourcesContent":["'use strict';\n\nconst balancedMatch = require('balanced-match');\n\n/**\n * Replace all of the characters that are arguments to a certain\n * CSS function with some innocuous character.\n *\n * This is useful if you need to use a RegExp to find a string\n * but want to ignore matches in certain functions (e.g. `url()`,\n * which might contain all kinds of false positives).\n *\n * For example:\n * blurFunctionArguments(\"abc url(abc) abc\", \"url\") === \"abc url(```) abc\"\n *\n * @param {string} source\n * @param {string} functionName\n * @return {string} - The result string, with the function arguments \"blurred\"\n */\nmodule.exports = function (source, functionName, blurChar = '`') {\n\tconst nameWithParen = `${functionName.toLowerCase()}(`;\n\tconst lowerCaseSource = source.toLowerCase();\n\n\tif (!lowerCaseSource.includes(nameWithParen)) {\n\t\treturn source;\n\t}\n\n\tconst functionNameLength = functionName.length;\n\n\tlet result = source;\n\tlet searchStartIndex = 0;\n\n\twhile (lowerCaseSource.includes(nameWithParen, searchStartIndex)) {\n\t\tconst openingParenIndex =\n\t\t\tlowerCaseSource.indexOf(nameWithParen, searchStartIndex) + functionNameLength;\n\t\tconst parensMatch = balancedMatch('(', ')', lowerCaseSource.slice(openingParenIndex));\n\n\t\tif (!parensMatch) {\n\t\t\tthrow new Error(`No parens match: \"${source}\"`);\n\t\t}\n\n\t\tconst closingParenIndex = parensMatch.end + openingParenIndex;\n\t\tconst argumentsLength = closingParenIndex - openingParenIndex - 1;\n\n\t\tresult =\n\t\t\tresult.slice(0, openingParenIndex + 1) +\n\t\t\tblurChar.repeat(argumentsLength) +\n\t\t\tresult.slice(closingParenIndex);\n\t\tsearchStartIndex = closingParenIndex;\n\t}\n\n\treturn result;\n};\n"]},"metadata":{},"sourceType":"script"}