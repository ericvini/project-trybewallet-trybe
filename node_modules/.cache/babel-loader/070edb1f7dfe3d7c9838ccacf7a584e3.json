{"ast":null,"code":"'use strict';\n\nconst keywordSets = require('../reference/keywordSets');\n/**\n * Check whether a type selector is standard\n *\n * @param {import('postcss-selector-parser').Tag} node postcss-selector-parser node (of type tag)\n * @return {boolean} If `true`, the type selector is standard\n */\n\n\nmodule.exports = function (node) {\n  // postcss-selector-parser includes the arguments to nth-child() functions\n  // as \"tags\", so we need to ignore them ourselves.\n  // The fake-tag's \"parent\" is actually a selector node, whose parent\n  // should be the :nth-child pseudo node.\n  if (!node.parent || !node.parent.parent) {\n    return false;\n  }\n\n  const _node$parent$parent = node.parent.parent;\n  const parentType = _node$parent$parent.type;\n  const parentValue = _node$parent$parent.value;\n\n  if (parentValue) {\n    const normalisedParentName = parentValue.toLowerCase().replace(/:+/, '');\n\n    if (parentType === 'pseudo' && (keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentName) || keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName) || keywordSets.linguisticPseudoClasses.has(normalisedParentName) || keywordSets.shadowTreePseudoElements.has(normalisedParentName))) {\n      return false;\n    }\n  } // &-bar is a nesting selector combined with a suffix\n\n\n  if (node.prev() && node.prev().type === 'nesting') {\n    return false;\n  }\n\n  if (node.value.startsWith('%')) {\n    return false;\n  } // Reference combinators like `/deep/`\n\n\n  if (node.value.startsWith('/') && node.value.endsWith('/')) {\n    return false;\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/isStandardSyntaxTypeSelector.js"],"names":["keywordSets","require","module","exports","node","parent","_node$parent$parent","parentType","type","parentValue","value","normalisedParentName","toLowerCase","replace","aNPlusBNotationPseudoClasses","has","aNPlusBOfSNotationPseudoClasses","linguisticPseudoClasses","shadowTreePseudoElements","prev","startsWith","endsWith"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,0BAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAChC;AACA;AACA;AACA;AACA,MAAI,CAACA,IAAI,CAACC,MAAN,IAAgB,CAACD,IAAI,CAACC,MAAL,CAAYA,MAAjC,EAAyC;AACxC,WAAO,KAAP;AACA;;AAED,QAAMC,mBAAmB,GAAGF,IAAI,CAACC,MAAL,CAAYA,MAAxC;AACA,QAAME,UAAU,GAAGD,mBAAmB,CAACE,IAAvC;AACA,QAAMC,WAAW,GAAGH,mBAAmB,CAACI,KAAxC;;AAEA,MAAID,WAAJ,EAAiB;AAChB,UAAME,oBAAoB,GAAGF,WAAW,CAACG,WAAZ,GAA0BC,OAA1B,CAAkC,IAAlC,EAAwC,EAAxC,CAA7B;;AAEA,QACCN,UAAU,KAAK,QAAf,KACCP,WAAW,CAACc,4BAAZ,CAAyCC,GAAzC,CAA6CJ,oBAA7C,KACAX,WAAW,CAACgB,+BAAZ,CAA4CD,GAA5C,CAAgDJ,oBAAhD,CADA,IAEAX,WAAW,CAACiB,uBAAZ,CAAoCF,GAApC,CAAwCJ,oBAAxC,CAFA,IAGAX,WAAW,CAACkB,wBAAZ,CAAqCH,GAArC,CAAyCJ,oBAAzC,CAJD,CADD,EAME;AACD,aAAO,KAAP;AACA;AACD,GAzB+B,CA2BhC;;;AACA,MAAIP,IAAI,CAACe,IAAL,MAAef,IAAI,CAACe,IAAL,GAAYX,IAAZ,KAAqB,SAAxC,EAAmD;AAClD,WAAO,KAAP;AACA;;AAED,MAAIJ,IAAI,CAACM,KAAL,CAAWU,UAAX,CAAsB,GAAtB,CAAJ,EAAgC;AAC/B,WAAO,KAAP;AACA,GAlC+B,CAoChC;;;AACA,MAAIhB,IAAI,CAACM,KAAL,CAAWU,UAAX,CAAsB,GAAtB,KAA8BhB,IAAI,CAACM,KAAL,CAAWW,QAAX,CAAoB,GAApB,CAAlC,EAA4D;AAC3D,WAAO,KAAP;AACA;;AAED,SAAO,IAAP;AACA,CA1CD","sourcesContent":["'use strict';\n\nconst keywordSets = require('../reference/keywordSets');\n\n/**\n * Check whether a type selector is standard\n *\n * @param {import('postcss-selector-parser').Tag} node postcss-selector-parser node (of type tag)\n * @return {boolean} If `true`, the type selector is standard\n */\nmodule.exports = function (node) {\n\t// postcss-selector-parser includes the arguments to nth-child() functions\n\t// as \"tags\", so we need to ignore them ourselves.\n\t// The fake-tag's \"parent\" is actually a selector node, whose parent\n\t// should be the :nth-child pseudo node.\n\tif (!node.parent || !node.parent.parent) {\n\t\treturn false;\n\t}\n\n\tconst _node$parent$parent = node.parent.parent;\n\tconst parentType = _node$parent$parent.type;\n\tconst parentValue = _node$parent$parent.value;\n\n\tif (parentValue) {\n\t\tconst normalisedParentName = parentValue.toLowerCase().replace(/:+/, '');\n\n\t\tif (\n\t\t\tparentType === 'pseudo' &&\n\t\t\t(keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentName) ||\n\t\t\t\tkeywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName) ||\n\t\t\t\tkeywordSets.linguisticPseudoClasses.has(normalisedParentName) ||\n\t\t\t\tkeywordSets.shadowTreePseudoElements.has(normalisedParentName))\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// &-bar is a nesting selector combined with a suffix\n\tif (node.prev() && node.prev().type === 'nesting') {\n\t\treturn false;\n\t}\n\n\tif (node.value.startsWith('%')) {\n\t\treturn false;\n\t}\n\n\t// Reference combinators like `/deep/`\n\tif (node.value.startsWith('/') && node.value.endsWith('/')) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n"]},"metadata":{},"sourceType":"script"}