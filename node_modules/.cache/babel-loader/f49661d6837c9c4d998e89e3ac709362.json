{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst getUnitFromValueNode = require('../../utils/getUnitFromValueNode');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst _ = require('lodash');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'number-max-precision';\nconst messages = ruleMessages(ruleName, {\n  expected: (number, precision) => `Expected \"${number}\" to be \"${number.toFixed(precision)}\"`\n});\n\nfunction rule(precision, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: precision,\n      possible: [_.isNumber]\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignoreUnits: [_.isString, _.isRegExp]\n      }\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(atRule => {\n      if (atRule.name.toLowerCase() === 'import') {\n        return;\n      }\n\n      check(atRule, atRule.params, atRuleParamIndex);\n    });\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));\n\n    function check(node, value, getIndex) {\n      // Get out quickly if there are no periods\n      if (!value.includes('.')) {\n        return;\n      }\n\n      valueParser(value).walk(valueNode => {\n        const unit = getUnitFromValueNode(valueNode);\n\n        if (optionsMatches(options, 'ignoreUnits', unit)) {\n          return;\n        } // Ignore `url` function\n\n\n        if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {\n          return false;\n        } // Ignore strings, comments, etc\n\n\n        if (valueNode.type !== 'word') {\n          return;\n        }\n\n        const match = /\\d*\\.(\\d+)/.exec(valueNode.value);\n\n        if (match === null) {\n          return;\n        }\n\n        if (match[1].length <= precision) {\n          return;\n        }\n\n        report({\n          result,\n          ruleName,\n          node,\n          index: getIndex(node) + valueNode.sourceIndex + match.index,\n          message: messages.expected(parseFloat(match[0]), precision)\n        });\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/number-max-precision/index.js"],"names":["atRuleParamIndex","require","declarationValueIndex","getUnitFromValueNode","optionsMatches","report","ruleMessages","validateOptions","_","valueParser","ruleName","messages","expected","number","precision","toFixed","rule","options","root","result","validOptions","actual","possible","isNumber","optional","ignoreUnits","isString","isRegExp","walkAtRules","atRule","name","toLowerCase","check","params","walkDecls","decl","value","node","getIndex","includes","walk","valueNode","unit","type","match","exec","length","index","sourceIndex","message","parseFloat","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst getUnitFromValueNode = require('../../utils/getUnitFromValueNode');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst _ = require('lodash');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'number-max-precision';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (number, precision) => `Expected \"${number}\" to be \"${number.toFixed(precision)}\"`,\n});\n\nfunction rule(precision, options) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: precision,\n\t\t\t\tpossible: [_.isNumber],\n\t\t\t},\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignoreUnits: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkAtRules((atRule) => {\n\t\t\tif (atRule.name.toLowerCase() === 'import') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcheck(atRule, atRule.params, atRuleParamIndex);\n\t\t});\n\n\t\troot.walkDecls((decl) => check(decl, decl.value, declarationValueIndex));\n\n\t\tfunction check(node, value, getIndex) {\n\t\t\t// Get out quickly if there are no periods\n\t\t\tif (!value.includes('.')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalueParser(value).walk((valueNode) => {\n\t\t\t\tconst unit = getUnitFromValueNode(valueNode);\n\n\t\t\t\tif (optionsMatches(options, 'ignoreUnits', unit)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Ignore `url` function\n\t\t\t\tif (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Ignore strings, comments, etc\n\t\t\t\tif (valueNode.type !== 'word') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst match = /\\d*\\.(\\d+)/.exec(valueNode.value);\n\n\t\t\t\tif (match === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (match[1].length <= precision) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t\tnode,\n\t\t\t\t\tindex: getIndex(node) + valueNode.sourceIndex + match.index,\n\t\t\t\t\tmessage: messages.expected(parseFloat(match[0]), precision),\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}