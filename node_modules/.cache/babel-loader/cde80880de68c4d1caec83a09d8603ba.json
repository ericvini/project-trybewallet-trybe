{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-max-empty-lines';\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`\n});\n\nfunction rule(max, options, context) {\n  const maxAdjacentNewlines = max + 1;\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const violatedCRLFNewLinesRegex = new RegExp(`(?:\\r\\n){${maxAdjacentNewlines + 1},}`);\n    const violatedLFNewLinesRegex = new RegExp(`\\n{${maxAdjacentNewlines + 1},}`);\n    const allowedLFNewLinesString = context.fix ? '\\n'.repeat(maxAdjacentNewlines) : '';\n    const allowedCRLFNewLinesString = context.fix ? '\\r\\n'.repeat(maxAdjacentNewlines) : ''; // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    root.walkRules(rule => {\n      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\n      if (context.fix) {\n        const newSelectorString = selector.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);\n\n        if (rule.raws.selector) {\n          rule.raws.selector.raw = newSelectorString;\n        } else {\n          rule.selector = newSelectorString;\n        }\n      } else if (violatedLFNewLinesRegex.test(selector) || violatedCRLFNewLinesRegex.test(selector)) {\n        report({\n          message: messages.expected(max),\n          node: rule,\n          index: 0,\n          result,\n          ruleName\n        });\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-max-empty-lines/index.js"],"names":["_","require","report","ruleMessages","validateOptions","ruleName","messages","expected","max","rule","options","context","maxAdjacentNewlines","root","result","validOptions","actual","possible","isNumber","violatedCRLFNewLinesRegex","RegExp","violatedLFNewLinesRegex","allowedLFNewLinesString","fix","repeat","allowedCRLFNewLinesString","walkRules","selector","raws","raw","newSelectorString","replace","test","message","node","index","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-max-empty-lines';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (max) => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`,\n});\n\nfunction rule(max, options, context) {\n\tconst maxAdjacentNewlines = max + 1;\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: max,\n\t\t\tpossible: _.isNumber,\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst violatedCRLFNewLinesRegex = new RegExp(`(?:\\r\\n){${maxAdjacentNewlines + 1},}`);\n\t\tconst violatedLFNewLinesRegex = new RegExp(`\\n{${maxAdjacentNewlines + 1},}`);\n\t\tconst allowedLFNewLinesString = context.fix ? '\\n'.repeat(maxAdjacentNewlines) : '';\n\t\tconst allowedCRLFNewLinesString = context.fix ? '\\r\\n'.repeat(maxAdjacentNewlines) : '';\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tconst selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\n\t\t\tif (context.fix) {\n\t\t\t\tconst newSelectorString = selector\n\t\t\t\t\t.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString)\n\t\t\t\t\t.replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);\n\n\t\t\t\tif (rule.raws.selector) {\n\t\t\t\t\trule.raws.selector.raw = newSelectorString;\n\t\t\t\t} else {\n\t\t\t\t\trule.selector = newSelectorString;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tviolatedLFNewLinesRegex.test(selector) ||\n\t\t\t\tviolatedCRLFNewLinesRegex.test(selector)\n\t\t\t) {\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(max),\n\t\t\t\t\tnode: rule,\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}