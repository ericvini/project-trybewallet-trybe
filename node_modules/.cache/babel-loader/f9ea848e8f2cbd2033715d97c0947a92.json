{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst beforeBlockString = require('../../utils/beforeBlockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'block-no-empty';\nconst messages = ruleMessages(ruleName, {\n  rejected: 'Unexpected empty block'\n});\n\nfunction rule(primary, options = {}) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: primary,\n      possible: _.isBoolean\n    }, {\n      actual: options,\n      possible: {\n        ignore: ['comments']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const ignoreComments = optionsMatches(options, 'ignore', 'comments'); // Check both kinds of statements: rules and at-rules\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      if (!hasEmptyBlock(statement) && !ignoreComments) {\n        return;\n      }\n\n      if (!hasBlock(statement)) {\n        return;\n      }\n\n      const hasCommentsOnly = statement.nodes.every(node => node.type === 'comment');\n\n      if (!hasCommentsOnly) {\n        return;\n      }\n\n      let index = beforeBlockString(statement, {\n        noRawBefore: true\n      }).length; // For empty blocks when using SugarSS parser\n\n      if (statement.raws.between === undefined) {\n        index--;\n      }\n\n      report({\n        message: messages.rejected,\n        node: statement,\n        index,\n        result,\n        ruleName\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-no-empty/index.js"],"names":["_","require","beforeBlockString","hasBlock","hasEmptyBlock","optionsMatches","report","ruleMessages","validateOptions","ruleName","messages","rejected","rule","primary","options","root","result","validOptions","actual","possible","isBoolean","ignore","optional","ignoreComments","walkRules","check","walkAtRules","statement","hasCommentsOnly","nodes","every","node","type","index","noRawBefore","length","raws","between","undefined","message","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,+BAAD,CAAjC;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMI,cAAc,GAAGJ,OAAO,CAAC,4BAAD,CAA9B;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMO,eAAe,GAAGP,OAAO,CAAC,6BAAD,CAA/B;;AAEA,MAAMQ,QAAQ,GAAG,gBAAjB;AAEA,MAAMC,QAAQ,GAAGH,YAAY,CAACE,QAAD,EAAW;AACvCE,EAAAA,QAAQ,EAAE;AAD6B,CAAX,CAA7B;;AAIA,SAASC,IAAT,CAAcC,OAAd,EAAuBC,OAAO,GAAG,EAAjC,EAAqC;AACpC,SAAO,CAACC,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGT,eAAe,CACnCQ,MADmC,EAEnCP,QAFmC,EAGnC;AACCS,MAAAA,MAAM,EAAEL,OADT;AAECM,MAAAA,QAAQ,EAAEnB,CAAC,CAACoB;AAFb,KAHmC,EAOnC;AACCF,MAAAA,MAAM,EAAEJ,OADT;AAECK,MAAAA,QAAQ,EAAE;AACTE,QAAAA,MAAM,EAAE,CAAC,UAAD;AADC,OAFX;AAKCC,MAAAA,QAAQ,EAAE;AALX,KAPmC,CAApC;;AAgBA,QAAI,CAACL,YAAL,EAAmB;AAClB;AACA;;AAED,UAAMM,cAAc,GAAGlB,cAAc,CAACS,OAAD,EAAU,QAAV,EAAoB,UAApB,CAArC,CArBwB,CAuBxB;;AACAC,IAAAA,IAAI,CAACS,SAAL,CAAeC,KAAf;AACAV,IAAAA,IAAI,CAACW,WAAL,CAAiBD,KAAjB;;AAEA,aAASA,KAAT,CAAeE,SAAf,EAA0B;AACzB,UAAI,CAACvB,aAAa,CAACuB,SAAD,CAAd,IAA6B,CAACJ,cAAlC,EAAkD;AACjD;AACA;;AAED,UAAI,CAACpB,QAAQ,CAACwB,SAAD,CAAb,EAA0B;AACzB;AACA;;AAED,YAAMC,eAAe,GAAGD,SAAS,CAACE,KAAV,CAAgBC,KAAhB,CAAuBC,IAAD,IAAUA,IAAI,CAACC,IAAL,KAAc,SAA9C,CAAxB;;AAEA,UAAI,CAACJ,eAAL,EAAsB;AACrB;AACA;;AAED,UAAIK,KAAK,GAAG/B,iBAAiB,CAACyB,SAAD,EAAY;AAAEO,QAAAA,WAAW,EAAE;AAAf,OAAZ,CAAjB,CAAoDC,MAAhE,CAfyB,CAiBzB;;AACA,UAAIR,SAAS,CAACS,IAAV,CAAeC,OAAf,KAA2BC,SAA/B,EAA0C;AACzCL,QAAAA,KAAK;AACL;;AAED3B,MAAAA,MAAM,CAAC;AACNiC,QAAAA,OAAO,EAAE7B,QAAQ,CAACC,QADZ;AAENoB,QAAAA,IAAI,EAAEJ,SAFA;AAGNM,QAAAA,KAHM;AAINjB,QAAAA,MAJM;AAKNP,QAAAA;AALM,OAAD,CAAN;AAOA;AACD,GAzDD;AA0DA;;AAEDG,IAAI,CAACH,QAAL,GAAgBA,QAAhB;AACAG,IAAI,CAACF,QAAL,GAAgBA,QAAhB;AACA8B,MAAM,CAACC,OAAP,GAAiB7B,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst beforeBlockString = require('../../utils/beforeBlockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'block-no-empty';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: 'Unexpected empty block',\n});\n\nfunction rule(primary, options = {}) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: primary,\n\t\t\t\tpossible: _.isBoolean,\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['comments'],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ignoreComments = optionsMatches(options, 'ignore', 'comments');\n\n\t\t// Check both kinds of statements: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\tif (!hasEmptyBlock(statement) && !ignoreComments) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!hasBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst hasCommentsOnly = statement.nodes.every((node) => node.type === 'comment');\n\n\t\t\tif (!hasCommentsOnly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet index = beforeBlockString(statement, { noRawBefore: true }).length;\n\n\t\t\t// For empty blocks when using SugarSS parser\n\t\t\tif (statement.raws.between === undefined) {\n\t\t\t\tindex--;\n\t\t\t}\n\n\t\t\treport({\n\t\t\t\tmessage: messages.rejected,\n\t\t\t\tnode: statement,\n\t\t\t\tindex,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}