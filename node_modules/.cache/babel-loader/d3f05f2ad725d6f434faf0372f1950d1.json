{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst declarationValueIndex = require('../utils/declarationValueIndex');\n\nconst isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');\n\nconst report = require('../utils/report');\n\nmodule.exports = function (opts) {\n  opts.root.walkDecls(decl => {\n    if (!isStandardSyntaxDeclaration(decl)) {\n      return;\n    } // Get the raw prop, and only the prop\n\n\n    const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1; // The extra characters tacked onto the end ensure that there is a character to check\n    // after the colon. Otherwise, with `background:pink` the character after the\n\n    const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;\n\n    for (let i = 0, l = propPlusColon.length; i < l; i++) {\n      if (propPlusColon[i] !== ':') {\n        continue;\n      }\n\n      opts.locationChecker({\n        source: propPlusColon,\n        index: i,\n        lineCheckStr: decl.value,\n        err: m => {\n          if (opts.fix && opts.fix(decl, i)) {\n            return;\n          }\n\n          report({\n            message: m,\n            node: decl,\n            index: decl.prop.toString().length + 1,\n            result: opts.result,\n            ruleName: opts.checkedRuleName\n          });\n        }\n      });\n      break;\n    }\n  });\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/declarationColonSpaceChecker.js"],"names":["declarationValueIndex","require","isStandardSyntaxDeclaration","report","module","exports","opts","root","walkDecls","decl","endOfPropIndex","raws","between","length","propPlusColon","toString","slice","i","l","locationChecker","source","index","lineCheckStr","value","err","m","fix","message","node","prop","result","ruleName","checkedRuleName"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,qBAAqB,GAAGC,OAAO,CAAC,gCAAD,CAArC;;AACA,MAAMC,2BAA2B,GAAGD,OAAO,CAAC,sCAAD,CAA3C;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,iBAAD,CAAtB;;AAEAG,MAAM,CAACC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAChCA,EAAAA,IAAI,CAACC,IAAL,CAAUC,SAAV,CAAqBC,IAAD,IAAU;AAC7B,QAAI,CAACP,2BAA2B,CAACO,IAAD,CAAhC,EAAwC;AACvC;AACA,KAH4B,CAK7B;;;AACA,UAAMC,cAAc,GAAGV,qBAAqB,CAACS,IAAD,CAArB,GAA8B,CAACA,IAAI,CAACE,IAAL,CAAUC,OAAV,IAAqB,EAAtB,EAA0BC,MAAxD,GAAiE,CAAxF,CAN6B,CAQ7B;AACA;;AACA,UAAMC,aAAa,GAAI,GAAEL,IAAI,CAACM,QAAL,GAAgBC,KAAhB,CAAsB,CAAtB,EAAyBN,cAAzB,CAAyC,KAAlE;;AAEA,SAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,aAAa,CAACD,MAAlC,EAA0CI,CAAC,GAAGC,CAA9C,EAAiDD,CAAC,EAAlD,EAAsD;AACrD,UAAIH,aAAa,CAACG,CAAD,CAAb,KAAqB,GAAzB,EAA8B;AAC7B;AACA;;AAEDX,MAAAA,IAAI,CAACa,eAAL,CAAqB;AACpBC,QAAAA,MAAM,EAAEN,aADY;AAEpBO,QAAAA,KAAK,EAAEJ,CAFa;AAGpBK,QAAAA,YAAY,EAAEb,IAAI,CAACc,KAHC;AAIpBC,QAAAA,GAAG,EAAGC,CAAD,IAAO;AACX,cAAInB,IAAI,CAACoB,GAAL,IAAYpB,IAAI,CAACoB,GAAL,CAASjB,IAAT,EAAeQ,CAAf,CAAhB,EAAmC;AAClC;AACA;;AAEDd,UAAAA,MAAM,CAAC;AACNwB,YAAAA,OAAO,EAAEF,CADH;AAENG,YAAAA,IAAI,EAAEnB,IAFA;AAGNY,YAAAA,KAAK,EAAEZ,IAAI,CAACoB,IAAL,CAAUd,QAAV,GAAqBF,MAArB,GAA8B,CAH/B;AAINiB,YAAAA,MAAM,EAAExB,IAAI,CAACwB,MAJP;AAKNC,YAAAA,QAAQ,EAAEzB,IAAI,CAAC0B;AALT,WAAD,CAAN;AAOA;AAhBmB,OAArB;AAkBA;AACA;AACD,GArCD;AAsCA,CAvCD","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst declarationValueIndex = require('../utils/declarationValueIndex');\nconst isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');\nconst report = require('../utils/report');\n\nmodule.exports = function (opts) {\n\topts.root.walkDecls((decl) => {\n\t\tif (!isStandardSyntaxDeclaration(decl)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the raw prop, and only the prop\n\t\tconst endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;\n\n\t\t// The extra characters tacked onto the end ensure that there is a character to check\n\t\t// after the colon. Otherwise, with `background:pink` the character after the\n\t\tconst propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;\n\n\t\tfor (let i = 0, l = propPlusColon.length; i < l; i++) {\n\t\t\tif (propPlusColon[i] !== ':') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\topts.locationChecker({\n\t\t\t\tsource: propPlusColon,\n\t\t\t\tindex: i,\n\t\t\t\tlineCheckStr: decl.value,\n\t\t\t\terr: (m) => {\n\t\t\t\t\tif (opts.fix && opts.fix(decl, i)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\tnode: decl,\n\t\t\t\t\t\tindex: decl.prop.toString().length + 1,\n\t\t\t\t\t\tresult: opts.result,\n\t\t\t\t\t\truleName: opts.checkedRuleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}