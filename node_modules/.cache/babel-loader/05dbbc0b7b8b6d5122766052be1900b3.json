{"ast":null,"code":"'use strict';\n/**\n * Compares a string to a second value that, if it fits a certain convention,\n * is converted to a regular expression before the comparison.\n * If it doesn't fit the convention, then two strings are compared.\n *\n * Any strings starting and ending with `/` are interpreted\n * as regular expressions.\n *\n * @param {string} input\n * @param {string | RegExp | Array<string | RegExp>} comparison\n *\n * @returns {false | {match: string, pattern: (string | RegExp) }}\n */\n\nmodule.exports = function matchesStringOrRegExp(input, comparison) {\n  if (!Array.isArray(input)) {\n    return testAgainstStringOrRegExpOrArray(input, comparison);\n  }\n\n  for (const inputItem of input) {\n    const testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);\n\n    if (testResult) {\n      return testResult;\n    }\n  }\n\n  return false;\n};\n/**\n * @param {string} value\n * @param {string | RegExp | Array<string | RegExp>} comparison\n */\n\n\nfunction testAgainstStringOrRegExpOrArray(value, comparison) {\n  if (!Array.isArray(comparison)) {\n    return testAgainstStringOrRegExp(value, comparison);\n  }\n\n  for (const comparisonItem of comparison) {\n    const testResult = testAgainstStringOrRegExp(value, comparisonItem);\n\n    if (testResult) {\n      return testResult;\n    }\n  }\n\n  return false;\n}\n/**\n * @param {string} value\n * @param {string | RegExp} comparison\n */\n\n\nfunction testAgainstStringOrRegExp(value, comparison) {\n  // If it's a RegExp, test directly\n  if (comparison instanceof RegExp) {\n    return comparison.test(value) ? {\n      match: value,\n      pattern: comparison\n    } : false;\n  } // Check if it's RegExp in a string\n\n\n  const firstComparisonChar = comparison[0];\n  const lastComparisonChar = comparison[comparison.length - 1];\n  const secondToLastComparisonChar = comparison[comparison.length - 2];\n  const comparisonIsRegex = firstComparisonChar === '/' && (lastComparisonChar === '/' || secondToLastComparisonChar === '/' && lastComparisonChar === 'i');\n  const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i'; // If so, create a new RegExp from it\n\n  if (comparisonIsRegex) {\n    const valueMatches = hasCaseInsensitiveFlag ? new RegExp(comparison.slice(1, -2), 'i').test(value) : new RegExp(comparison.slice(1, -1)).test(value);\n    return valueMatches ? {\n      match: value,\n      pattern: comparison\n    } : false;\n  } // Otherwise, it's a string. Do a strict comparison\n\n\n  return value === comparison ? {\n    match: value,\n    pattern: comparison\n  } : false;\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/matchesStringOrRegExp.js"],"names":["module","exports","matchesStringOrRegExp","input","comparison","Array","isArray","testAgainstStringOrRegExpOrArray","inputItem","testResult","value","testAgainstStringOrRegExp","comparisonItem","RegExp","test","match","pattern","firstComparisonChar","lastComparisonChar","length","secondToLastComparisonChar","comparisonIsRegex","hasCaseInsensitiveFlag","valueMatches","slice"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,OAAP,GAAiB,SAASC,qBAAT,CAA+BC,KAA/B,EAAsCC,UAAtC,EAAkD;AAClE,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,KAAd,CAAL,EAA2B;AAC1B,WAAOI,gCAAgC,CAACJ,KAAD,EAAQC,UAAR,CAAvC;AACA;;AAED,OAAK,MAAMI,SAAX,IAAwBL,KAAxB,EAA+B;AAC9B,UAAMM,UAAU,GAAGF,gCAAgC,CAACC,SAAD,EAAYJ,UAAZ,CAAnD;;AAEA,QAAIK,UAAJ,EAAgB;AACf,aAAOA,UAAP;AACA;AACD;;AAED,SAAO,KAAP;AACA,CAdD;AAgBA;AACA;AACA;AACA;;;AACA,SAASF,gCAAT,CAA0CG,KAA1C,EAAiDN,UAAjD,EAA6D;AAC5D,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,UAAd,CAAL,EAAgC;AAC/B,WAAOO,yBAAyB,CAACD,KAAD,EAAQN,UAAR,CAAhC;AACA;;AAED,OAAK,MAAMQ,cAAX,IAA6BR,UAA7B,EAAyC;AACxC,UAAMK,UAAU,GAAGE,yBAAyB,CAACD,KAAD,EAAQE,cAAR,CAA5C;;AAEA,QAAIH,UAAJ,EAAgB;AACf,aAAOA,UAAP;AACA;AACD;;AAED,SAAO,KAAP;AACA;AAED;AACA;AACA;AACA;;;AACA,SAASE,yBAAT,CAAmCD,KAAnC,EAA0CN,UAA1C,EAAsD;AACrD;AACA,MAAIA,UAAU,YAAYS,MAA1B,EAAkC;AACjC,WAAOT,UAAU,CAACU,IAAX,CAAgBJ,KAAhB,IAAyB;AAAEK,MAAAA,KAAK,EAAEL,KAAT;AAAgBM,MAAAA,OAAO,EAAEZ;AAAzB,KAAzB,GAAiE,KAAxE;AACA,GAJoD,CAMrD;;;AACA,QAAMa,mBAAmB,GAAGb,UAAU,CAAC,CAAD,CAAtC;AACA,QAAMc,kBAAkB,GAAGd,UAAU,CAACA,UAAU,CAACe,MAAX,GAAoB,CAArB,CAArC;AACA,QAAMC,0BAA0B,GAAGhB,UAAU,CAACA,UAAU,CAACe,MAAX,GAAoB,CAArB,CAA7C;AAEA,QAAME,iBAAiB,GACtBJ,mBAAmB,KAAK,GAAxB,KACCC,kBAAkB,KAAK,GAAvB,IACCE,0BAA0B,KAAK,GAA/B,IAAsCF,kBAAkB,KAAK,GAF/D,CADD;AAKA,QAAMI,sBAAsB,GAAGD,iBAAiB,IAAIH,kBAAkB,KAAK,GAA3E,CAhBqD,CAkBrD;;AACA,MAAIG,iBAAJ,EAAuB;AACtB,UAAME,YAAY,GAAGD,sBAAsB,GACxC,IAAIT,MAAJ,CAAWT,UAAU,CAACoB,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAX,EAAoC,GAApC,EAAyCV,IAAzC,CAA8CJ,KAA9C,CADwC,GAExC,IAAIG,MAAJ,CAAWT,UAAU,CAACoB,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAX,EAAoCV,IAApC,CAAyCJ,KAAzC,CAFH;AAIA,WAAOa,YAAY,GAAG;AAAER,MAAAA,KAAK,EAAEL,KAAT;AAAgBM,MAAAA,OAAO,EAAEZ;AAAzB,KAAH,GAA2C,KAA9D;AACA,GAzBoD,CA2BrD;;;AACA,SAAOM,KAAK,KAAKN,UAAV,GAAuB;AAAEW,IAAAA,KAAK,EAAEL,KAAT;AAAgBM,IAAAA,OAAO,EAAEZ;AAAzB,GAAvB,GAA+D,KAAtE;AACA","sourcesContent":["'use strict';\n\n/**\n * Compares a string to a second value that, if it fits a certain convention,\n * is converted to a regular expression before the comparison.\n * If it doesn't fit the convention, then two strings are compared.\n *\n * Any strings starting and ending with `/` are interpreted\n * as regular expressions.\n *\n * @param {string} input\n * @param {string | RegExp | Array<string | RegExp>} comparison\n *\n * @returns {false | {match: string, pattern: (string | RegExp) }}\n */\nmodule.exports = function matchesStringOrRegExp(input, comparison) {\n\tif (!Array.isArray(input)) {\n\t\treturn testAgainstStringOrRegExpOrArray(input, comparison);\n\t}\n\n\tfor (const inputItem of input) {\n\t\tconst testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);\n\n\t\tif (testResult) {\n\t\t\treturn testResult;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * @param {string} value\n * @param {string | RegExp | Array<string | RegExp>} comparison\n */\nfunction testAgainstStringOrRegExpOrArray(value, comparison) {\n\tif (!Array.isArray(comparison)) {\n\t\treturn testAgainstStringOrRegExp(value, comparison);\n\t}\n\n\tfor (const comparisonItem of comparison) {\n\t\tconst testResult = testAgainstStringOrRegExp(value, comparisonItem);\n\n\t\tif (testResult) {\n\t\t\treturn testResult;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {string} value\n * @param {string | RegExp} comparison\n */\nfunction testAgainstStringOrRegExp(value, comparison) {\n\t// If it's a RegExp, test directly\n\tif (comparison instanceof RegExp) {\n\t\treturn comparison.test(value) ? { match: value, pattern: comparison } : false;\n\t}\n\n\t// Check if it's RegExp in a string\n\tconst firstComparisonChar = comparison[0];\n\tconst lastComparisonChar = comparison[comparison.length - 1];\n\tconst secondToLastComparisonChar = comparison[comparison.length - 2];\n\n\tconst comparisonIsRegex =\n\t\tfirstComparisonChar === '/' &&\n\t\t(lastComparisonChar === '/' ||\n\t\t\t(secondToLastComparisonChar === '/' && lastComparisonChar === 'i'));\n\n\tconst hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';\n\n\t// If so, create a new RegExp from it\n\tif (comparisonIsRegex) {\n\t\tconst valueMatches = hasCaseInsensitiveFlag\n\t\t\t? new RegExp(comparison.slice(1, -2), 'i').test(value)\n\t\t\t: new RegExp(comparison.slice(1, -1)).test(value);\n\n\t\treturn valueMatches ? { match: value, pattern: comparison } : false;\n\t}\n\n\t// Otherwise, it's a string. Do a strict comparison\n\treturn value === comparison ? { match: value, pattern: comparison } : false;\n}\n"]},"metadata":{},"sourceType":"script"}