{"ast":null,"code":"'use strict';\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase();\n  return '0x' + (h.length % 2 ? '0' : '') + h;\n};\n\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0\n    };\n  }\n\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i);\n  const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;\n\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0 : errIdx - context;\n    const end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n    const slice = (start === 0 ? '' : '...') + txt.slice(start, end) + (end === txt.length ? '' : '...');\n    const near = txt === slice ? '' : 'near ';\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx\n    };\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0\n    };\n  }\n};\n\nclass JSONParseError extends SyntaxError {\n  constructor(er, txt, context, caller) {\n    context = context || 20;\n    const metadata = parseError(er, txt, context);\n    super(metadata.message);\n    Object.assign(this, metadata);\n    this.code = 'EJSONPARSE';\n    this.systemError = er;\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n\n  get name() {\n    return this.constructor.name;\n  }\n\n  set name(n) {}\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n}\n\nconst kIndent = Symbol.for('indent');\nconst kNewline = Symbol.for('newline'); // only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\n\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/;\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/;\n\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt);\n  context = context || 20;\n\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) || parseText.match(formatRE) || [, '', ''];\n    const result = JSON.parse(parseText, reviver);\n\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline;\n      result[kIndent] = indent;\n    }\n\n    return result;\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0;\n      throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`), {\n        code: 'EJSONPARSE',\n        systemError: e\n      });\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson);\n  }\n}; // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\n\n\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '');\n\nmodule.exports = parseJson;\nparseJson.JSONParseError = JSONParseError;\n\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver);\n  } catch (e) {}\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/json-parse-even-better-errors/index.js"],"names":["hexify","char","h","charCodeAt","toString","toUpperCase","length","parseError","e","txt","context","message","position","badToken","match","errIdx","msg","replace","JSON","stringify","undefined","start","end","slice","near","JSONParseError","SyntaxError","constructor","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","name","n","Symbol","toStringTag","kIndent","for","kNewline","formatRE","emptyRE","parseJson","reviver","parseText","stripBOM","newline","indent","result","parse","Buffer","isBuffer","isEmptyArray","Array","isArray","TypeError","String","module","exports","noExceptions"],"mappings":"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","sourcesContent":["'use strict'\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return '0x' + (h.length % 2 ? '0' : '') + h\n}\n\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0,\n    }\n  }\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i)\n  const errIdx = badToken ? +badToken[2]\n    : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1\n    : null\n\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${\n      JSON.stringify(badToken[1])\n    } (${hexify(badToken[1])})`)\n    : e.message\n\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0\n      : errIdx - context\n\n    const end = errIdx + context >= txt.length ? txt.length\n      : errIdx + context\n\n    const slice = (start === 0 ? '' : '...') +\n      txt.slice(start, end) +\n      (end === txt.length ? '' : '...')\n\n    const near = txt === slice ? '' : 'near '\n\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx,\n    }\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0,\n    }\n  }\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    context = context || 20\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () { return this.constructor.name }\n  set name (n) {}\n  get [Symbol.toStringTag] () { return this.constructor.name }\n}\n\nconst kIndent = Symbol.for('indent')\nconst kNewline = Symbol.for('newline')\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt)\n  context = context || 20\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) ||\n      parseText.match(formatRE) ||\n      [, '', '']\n\n    const result = JSON.parse(parseText, reviver)\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline\n      result[kIndent] = indent\n    }\n    return result\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      throw Object.assign(new TypeError(\n        `Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`\n      ), {\n        code: 'EJSONPARSE',\n        systemError: e,\n      })\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson)\n  }\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '')\n\nmodule.exports = parseJson\nparseJson.JSONParseError = JSONParseError\n\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver)\n  } catch (e) {}\n}\n"]},"metadata":{},"sourceType":"script"}