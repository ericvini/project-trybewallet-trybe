{"ast":null,"code":"/* normalize-selector v0.1.0 (c) 2014 Kyle Simpson */\n(function UMD(name, context, definition) {\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = definition();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(definition);\n  } else {\n    context[name] = definition(name, context);\n  }\n})(\"normalizeSelector\", this, function DEF(name, context) {\n  \"use strict\";\n\n  function normalizeSelector(sel) {\n    // save unmatched text, if any\n    function saveUnmatched() {\n      if (unmatched) {\n        // whitespace needed after combinator?\n        if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {\n          tokens.push(\" \");\n        } // save unmatched text\n\n\n        tokens.push(unmatched);\n      }\n    }\n\n    var tokens = [],\n        match,\n        unmatched,\n        regex,\n        state = [0],\n        next_match_idx = 0,\n        prev_match_idx,\n        not_escaped_pattern = /(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/,\n        whitespace_pattern = /^\\s+$/,\n        attribute_nonspecial_pattern = /[^\\s=~!^|$*\\[\\]\\(\\)]{2}/,\n        state_patterns = [/\\s+|\\/\\*|[\"'>~+\\[\\(]/g, // general\n    /\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g, // [..] set\n    /\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g, // (..) set\n    null, // string literal (placeholder)\n    /\\*\\//g // comment\n    ];\n    sel = sel.trim();\n\n    while (true) {\n      unmatched = \"\";\n      regex = state_patterns[state[state.length - 1]];\n      regex.lastIndex = next_match_idx;\n      match = regex.exec(sel); // matched text to process?\n\n      if (match) {\n        prev_match_idx = next_match_idx;\n        next_match_idx = regex.lastIndex; // collect the previous string chunk not matched before this token\n\n        if (prev_match_idx < next_match_idx - match[0].length) {\n          unmatched = sel.substring(prev_match_idx, next_match_idx - match[0].length);\n        } // need to force a space (possibly skipped\n        // previously by the parser)?\n\n\n        if (state[state.length - 1] === 1 && attribute_nonspecial_pattern.test(tokens[tokens.length - 1].substr(-1) + unmatched.charAt(0))) {\n          tokens.push(\" \");\n        } // general, [ ] pair, ( ) pair?\n\n\n        if (state[state.length - 1] < 3) {\n          saveUnmatched(); // starting a [ ] pair?\n\n          if (match[0] === \"[\") {\n            state.push(1);\n          } // starting a ( ) pair?\n          else if (match[0] === \"(\") {\n              state.push(2);\n            } // starting a string literal?\n            else if (/^[\"']$/.test(match[0])) {\n                state.push(3);\n                state_patterns[3] = new RegExp(match[0], \"g\");\n              } // starting a comment?\n              else if (match[0] === \"/*\") {\n                  state.push(4);\n                } // ending a [ ] or ( ) pair?\n                else if (/^[\\]\\)]$/.test(match[0]) && state.length > 0) {\n                    state.pop();\n                  } // handling whitespace or a combinator?\n                  else if (/^(?:\\s+|[~+>])$/.test(match[0])) {\n                      // need to insert whitespace before?\n                      if (tokens.length > 0 && !whitespace_pattern.test(tokens[tokens.length - 1]) && state[state.length - 1] === 0) {\n                        // add normalized whitespace\n                        tokens.push(\" \");\n                      } // whitespace token we can skip?\n\n\n                      if (whitespace_pattern.test(match[0])) {\n                        continue;\n                      }\n                    } // save matched text\n\n\n          tokens.push(match[0]);\n        } // otherwise, string literal or comment\n        else {\n            // save unmatched text\n            tokens[tokens.length - 1] += unmatched; // unescaped terminator to string literal or comment?\n\n            if (not_escaped_pattern.test(tokens[tokens.length - 1])) {\n              // comment terminator?\n              if (state[state.length - 1] === 4) {\n                // ok to drop comment?\n                if (tokens.length < 2 || whitespace_pattern.test(tokens[tokens.length - 2])) {\n                  tokens.pop();\n                } // otherwise, turn comment into whitespace\n                else {\n                    tokens[tokens.length - 1] = \" \";\n                  } // handled already\n\n\n                match[0] = \"\";\n              }\n\n              state.pop();\n            } // append matched text to existing token\n\n\n            tokens[tokens.length - 1] += match[0];\n          }\n      } // otherwise, end of processing (no more matches)\n      else {\n          unmatched = sel.substr(next_match_idx);\n          saveUnmatched();\n          break;\n        }\n    }\n\n    return tokens.join(\"\").trim();\n  }\n\n  return normalizeSelector;\n});","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/normalize-selector/lib/normalize-selector.js"],"names":["UMD","name","context","definition","module","exports","define","amd","DEF","normalizeSelector","sel","saveUnmatched","unmatched","tokens","length","test","push","match","regex","state","next_match_idx","prev_match_idx","not_escaped_pattern","whitespace_pattern","attribute_nonspecial_pattern","state_patterns","trim","lastIndex","exec","substring","substr","charAt","RegExp","pop","join"],"mappings":"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","sourcesContent":["/* normalize-selector v0.1.0 (c) 2014 Kyle Simpson */\n\n(function UMD(name,context,definition){\n\tif (typeof module !== \"undefined\" && module.exports) { module.exports = definition(); }\n\telse if (typeof define === \"function\" && define.amd) { define(definition); }\n\telse { context[name] = definition(name,context); }\n})(\"normalizeSelector\",this,function DEF(name,context){\n\t\"use strict\";\n\n\tfunction normalizeSelector(sel) {\n\n\t\t// save unmatched text, if any\n\t\tfunction saveUnmatched() {\n\t\t\tif (unmatched) {\n\t\t\t\t// whitespace needed after combinator?\n\t\t\t\tif (tokens.length > 0 &&\n\t\t\t\t\t/^[~+>]$/.test(tokens[tokens.length-1])\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(\" \");\n\t\t\t\t}\n\n\t\t\t\t// save unmatched text\n\t\t\t\ttokens.push(unmatched);\n\t\t\t}\n\t\t}\n\n\t\tvar tokens = [], match, unmatched, regex, state = [0],\n\t\t\tnext_match_idx = 0, prev_match_idx,\n\t\t\tnot_escaped_pattern = /(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/,\n\t\t\twhitespace_pattern = /^\\s+$/,\n\t\t\tattribute_nonspecial_pattern = /[^\\s=~!^|$*\\[\\]\\(\\)]{2}/,\n\t\t\tstate_patterns = [\n\t\t\t\t/\\s+|\\/\\*|[\"'>~+\\[\\(]/g, // general\n\t\t\t\t/\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g, // [..] set\n\t\t\t\t/\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g, // (..) set\n\t\t\t\tnull, // string literal (placeholder)\n\t\t\t\t/\\*\\//g // comment\n\t\t\t]\n\t\t;\n\n\t\tsel = sel.trim();\n\n\t\twhile (true) {\n\t\t\tunmatched = \"\";\n\n\t\t\tregex = state_patterns[state[state.length-1]];\n\n\t\t\tregex.lastIndex = next_match_idx;\n\t\t\tmatch = regex.exec(sel);\n\n\t\t\t// matched text to process?\n\t\t\tif (match) {\n\t\t\t\tprev_match_idx = next_match_idx;\n\t\t\t\tnext_match_idx = regex.lastIndex;\n\n\t\t\t\t// collect the previous string chunk not matched before this token\n\t\t\t\tif (prev_match_idx < next_match_idx - match[0].length) {\n\t\t\t\t\tunmatched = sel.substring(prev_match_idx,next_match_idx - match[0].length);\n\t\t\t\t}\n\n\t\t\t\t// need to force a space (possibly skipped\n\t\t\t\t// previously by the parser)?\n\t\t\t\tif (\n\t\t\t\t\tstate[state.length-1] === 1 &&\n\t\t\t\t\tattribute_nonspecial_pattern.test(\n\t\t\t\t\t\ttokens[tokens.length-1].substr(-1) +\n\t\t\t\t\t\tunmatched.charAt(0)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(\" \");\n\t\t\t\t}\n\n\t\t\t\t// general, [ ] pair, ( ) pair?\n\t\t\t\tif (state[state.length-1] < 3) {\n\t\t\t\t\tsaveUnmatched();\n\n\t\t\t\t\t// starting a [ ] pair?\n\t\t\t\t\tif (match[0] === \"[\") {\n\t\t\t\t\t\tstate.push(1);\n\t\t\t\t\t}\n\t\t\t\t\t// starting a ( ) pair?\n\t\t\t\t\telse if (match[0] === \"(\") {\n\t\t\t\t\t\tstate.push(2);\n\t\t\t\t\t}\n\t\t\t\t\t// starting a string literal?\n\t\t\t\t\telse if (/^[\"']$/.test(match[0])) {\n\t\t\t\t\t\tstate.push(3);\n\t\t\t\t\t\tstate_patterns[3] = new RegExp(match[0],\"g\");\n\t\t\t\t\t}\n\t\t\t\t\t// starting a comment?\n\t\t\t\t\telse if (match[0] === \"/*\") {\n\t\t\t\t\t\tstate.push(4);\n\t\t\t\t\t}\n\t\t\t\t\t// ending a [ ] or ( ) pair?\n\t\t\t\t\telse if (/^[\\]\\)]$/.test(match[0]) && state.length > 0) {\n\t\t\t\t\t\tstate.pop();\n\t\t\t\t\t}\n\t\t\t\t\t// handling whitespace or a combinator?\n\t\t\t\t\telse if (/^(?:\\s+|[~+>])$/.test(match[0])) {\n\t\t\t\t\t\t// need to insert whitespace before?\n\t\t\t\t\t\tif (tokens.length > 0 &&\n\t\t\t\t\t\t\t!whitespace_pattern.test(tokens[tokens.length-1]) &&\n\t\t\t\t\t\t\tstate[state.length-1] === 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// add normalized whitespace\n\t\t\t\t\t\t\ttokens.push(\" \");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// whitespace token we can skip?\n\t\t\t\t\t\tif (whitespace_pattern.test(match[0])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// save matched text\n\t\t\t\t\ttokens.push(match[0]);\n\t\t\t\t}\n\t\t\t\t// otherwise, string literal or comment\n\t\t\t\telse {\n\t\t\t\t\t// save unmatched text\n\t\t\t\t\ttokens[tokens.length-1] += unmatched;\n\n\t\t\t\t\t// unescaped terminator to string literal or comment?\n\t\t\t\t\tif (not_escaped_pattern.test(tokens[tokens.length-1])) {\n\t\t\t\t\t\t// comment terminator?\n\t\t\t\t\t\tif (state[state.length-1] === 4) {\n\t\t\t\t\t\t\t// ok to drop comment?\n\t\t\t\t\t\t\tif (tokens.length < 2 ||\n\t\t\t\t\t\t\t\twhitespace_pattern.test(tokens[tokens.length-2])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\ttokens.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// otherwise, turn comment into whitespace\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttokens[tokens.length-1] = \" \";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// handled already\n\t\t\t\t\t\t\tmatch[0] = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// append matched text to existing token\n\t\t\t\t\ttokens[tokens.length-1] += match[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// otherwise, end of processing (no more matches)\n\t\t\telse {\n\t\t\t\tunmatched = sel.substr(next_match_idx);\n\t\t\t\tsaveUnmatched();\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tokens.join(\"\").trim();\n\t}\n\n\treturn normalizeSelector;\n});\n\n"]},"metadata":{},"sourceType":"script"}