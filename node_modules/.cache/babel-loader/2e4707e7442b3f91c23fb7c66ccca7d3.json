{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxMathFunction = require('../../utils/isStandardSyntaxMathFunction');\n\nconst parseCalcExpression = require('../../utils/parseCalcExpression');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-calc-no-invalid';\nconst messages = ruleMessages(ruleName, {\n  expectedExpression: () => 'Expected a valid expression',\n  expectedSpaceBeforeOperator: operator => `Expected space before \"${operator}\" operator`,\n  expectedSpaceAfterOperator: operator => `Expected space after \"${operator}\" operator`,\n  rejectedDivisionByZero: () => 'Unexpected division by zero',\n  expectedValidResolvedType: operator => `Expected to be compatible with the left and right argument types of \"${operator}\" operation.`\n});\n\nfunction rule(actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      const checked = [];\n      valueParser(decl.value).walk(node => {\n        if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') {\n          return;\n        }\n\n        const mathFunction = valueParser.stringify(node);\n\n        if (!isStandardSyntaxMathFunction(mathFunction)) {\n          return;\n        }\n\n        if (checked.includes(node)) {\n          return;\n        }\n\n        checked.push(...getCalcNodes(node));\n        checked.push(...node.nodes);\n        let ast;\n\n        try {\n          ast = parseCalcExpression(mathFunction);\n        } catch (e) {\n          if (e.hash && e.hash.loc) {\n            complain(messages.expectedExpression(), node.sourceIndex + e.hash.loc.range[0]);\n            return;\n          }\n\n          throw e;\n        }\n\n        verifyMathExpressions(ast, node);\n      });\n\n      function complain(message, valueIndex) {\n        report({\n          message,\n          node: decl,\n          index: declarationValueIndex(decl) + valueIndex,\n          result,\n          ruleName\n        });\n      }\n      /**\n       * Verify that each operation expression is valid.\n       * Reports when a invalid operation expression is found.\n       * @param {object} expression expression node.\n       * @param {object} node calc function node.\n       * @returns {void}\n       */\n\n\n      function verifyMathExpressions(expression, node) {\n        if (expression.type === 'MathExpression') {\n          const {\n            operator,\n            left,\n            right\n          } = expression;\n\n          if (operator === '+' || operator === '-') {\n            if (expression.source.operator.end.index === right.source.start.index) {\n              complain(messages.expectedSpaceAfterOperator(operator), node.sourceIndex + expression.source.operator.end.index);\n            }\n\n            if (expression.source.operator.start.index === left.source.end.index) {\n              complain(messages.expectedSpaceBeforeOperator(operator), node.sourceIndex + expression.source.operator.start.index);\n            }\n          } else if (operator === '/') {\n            if (right.type === 'Value' && right.value === 0 || right.type === 'MathExpression' && getNumber(right) === 0) {\n              complain(messages.rejectedDivisionByZero(), node.sourceIndex + expression.source.operator.end.index);\n            }\n          }\n\n          if (getResolvedType(expression) === 'invalid') {\n            complain(messages.expectedValidResolvedType(operator), node.sourceIndex + expression.source.operator.start.index);\n          }\n\n          verifyMathExpressions(expression.left, node);\n          verifyMathExpressions(expression.right, node);\n        }\n      }\n    });\n  };\n}\n\nfunction getCalcNodes(node) {\n  if (node.type !== 'function') {\n    return [];\n  }\n\n  const functionName = node.value.toLowerCase();\n  const result = [];\n\n  if (functionName === 'calc') {\n    result.push(node);\n  }\n\n  if (!functionName || functionName === 'calc') {\n    // find nested calc\n    for (const c of node.nodes) {\n      result.push(...getCalcNodes(c));\n    }\n  }\n\n  return result;\n}\n\nfunction getNumber(mathExpression) {\n  const {\n    left,\n    right\n  } = mathExpression;\n  const leftValue = left.type === 'Value' ? left.value : left.type === 'MathExpression' ? getNumber(left) : null;\n  const rightValue = right.type === 'Value' ? right.value : right.type === 'MathExpression' ? getNumber(right) : null;\n\n  if (leftValue == null || rightValue == null) {\n    return null;\n  }\n\n  switch (mathExpression.operator) {\n    case '+':\n      return leftValue + rightValue;\n\n    case '-':\n      return leftValue - rightValue;\n\n    case '*':\n      return leftValue * rightValue;\n\n    case '/':\n      return leftValue / rightValue;\n  }\n\n  return null;\n}\n\nfunction getResolvedType(mathExpression) {\n  const {\n    left: leftExpression,\n    operator,\n    right: rightExpression\n  } = mathExpression;\n  let left = leftExpression.type === 'MathExpression' ? getResolvedType(leftExpression) : leftExpression.type;\n  let right = rightExpression.type === 'MathExpression' ? getResolvedType(rightExpression) : rightExpression.type;\n\n  if (left === 'Function' || left === 'invalid') {\n    left = 'UnknownValue';\n  }\n\n  if (right === 'Function' || right === 'invalid') {\n    right = 'UnknownValue';\n  }\n\n  switch (operator) {\n    case '+':\n    case '-':\n      if (left === 'UnknownValue' || right === 'UnknownValue') {\n        return 'UnknownValue';\n      }\n\n      if (left === right) {\n        return left;\n      }\n\n      if (left === 'Value' || right === 'Value') {\n        return 'invalid';\n      }\n\n      if (left === 'PercentageValue') {\n        return right;\n      }\n\n      if (right === 'PercentageValue') {\n        return left;\n      }\n\n      return 'invalid';\n\n    case '*':\n      if (left === 'UnknownValue' || right === 'UnknownValue') {\n        return 'UnknownValue';\n      }\n\n      if (left === 'Value') {\n        return right;\n      }\n\n      if (right === 'Value') {\n        return left;\n      }\n\n      return 'invalid';\n\n    case '/':\n      if (right === 'UnknownValue') {\n        return 'UnknownValue';\n      }\n\n      if (right === 'Value') {\n        return left;\n      }\n\n      return 'invalid';\n  }\n\n  return 'UnknownValue';\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/function-calc-no-invalid/index.js"],"names":["declarationValueIndex","require","isStandardSyntaxMathFunction","parseCalcExpression","report","ruleMessages","validateOptions","valueParser","ruleName","messages","expectedExpression","expectedSpaceBeforeOperator","operator","expectedSpaceAfterOperator","rejectedDivisionByZero","expectedValidResolvedType","rule","actual","root","result","validOptions","walkDecls","decl","checked","value","walk","node","type","toLowerCase","mathFunction","stringify","includes","push","getCalcNodes","nodes","ast","e","hash","loc","complain","sourceIndex","range","verifyMathExpressions","message","valueIndex","index","expression","left","right","source","end","start","getNumber","getResolvedType","functionName","c","mathExpression","leftValue","rightValue","leftExpression","rightExpression","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxMathFunction = require('../../utils/isStandardSyntaxMathFunction');\nconst parseCalcExpression = require('../../utils/parseCalcExpression');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-calc-no-invalid';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedExpression: () => 'Expected a valid expression',\n\texpectedSpaceBeforeOperator: (operator) => `Expected space before \"${operator}\" operator`,\n\texpectedSpaceAfterOperator: (operator) => `Expected space after \"${operator}\" operator`,\n\trejectedDivisionByZero: () => 'Unexpected division by zero',\n\texpectedValidResolvedType: (operator) =>\n\t\t`Expected to be compatible with the left and right argument types of \"${operator}\" operation.`,\n});\n\nfunction rule(actual) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, { actual });\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst checked = [];\n\n\t\t\tvalueParser(decl.value).walk((node) => {\n\t\t\t\tif (node.type !== 'function' || node.value.toLowerCase() !== 'calc') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst mathFunction = valueParser.stringify(node);\n\n\t\t\t\tif (!isStandardSyntaxMathFunction(mathFunction)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checked.includes(node)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tchecked.push(...getCalcNodes(node));\n\n\t\t\t\tchecked.push(...node.nodes);\n\n\t\t\t\tlet ast;\n\n\t\t\t\ttry {\n\t\t\t\t\tast = parseCalcExpression(mathFunction);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.hash && e.hash.loc) {\n\t\t\t\t\t\tcomplain(messages.expectedExpression(), node.sourceIndex + e.hash.loc.range[0]);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\tverifyMathExpressions(ast, node);\n\t\t\t});\n\n\t\t\tfunction complain(message, valueIndex) {\n\t\t\t\treport({\n\t\t\t\t\tmessage,\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + valueIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Verify that each operation expression is valid.\n\t\t\t * Reports when a invalid operation expression is found.\n\t\t\t * @param {object} expression expression node.\n\t\t\t * @param {object} node calc function node.\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tfunction verifyMathExpressions(expression, node) {\n\t\t\t\tif (expression.type === 'MathExpression') {\n\t\t\t\t\tconst { operator, left, right } = expression;\n\n\t\t\t\t\tif (operator === '+' || operator === '-') {\n\t\t\t\t\t\tif (expression.source.operator.end.index === right.source.start.index) {\n\t\t\t\t\t\t\tcomplain(\n\t\t\t\t\t\t\t\tmessages.expectedSpaceAfterOperator(operator),\n\t\t\t\t\t\t\t\tnode.sourceIndex + expression.source.operator.end.index,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expression.source.operator.start.index === left.source.end.index) {\n\t\t\t\t\t\t\tcomplain(\n\t\t\t\t\t\t\t\tmessages.expectedSpaceBeforeOperator(operator),\n\t\t\t\t\t\t\t\tnode.sourceIndex + expression.source.operator.start.index,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator === '/') {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(right.type === 'Value' && right.value === 0) ||\n\t\t\t\t\t\t\t(right.type === 'MathExpression' && getNumber(right) === 0)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcomplain(\n\t\t\t\t\t\t\t\tmessages.rejectedDivisionByZero(),\n\t\t\t\t\t\t\t\tnode.sourceIndex + expression.source.operator.end.index,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (getResolvedType(expression) === 'invalid') {\n\t\t\t\t\t\tcomplain(\n\t\t\t\t\t\t\tmessages.expectedValidResolvedType(operator),\n\t\t\t\t\t\t\tnode.sourceIndex + expression.source.operator.start.index,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tverifyMathExpressions(expression.left, node);\n\t\t\t\t\tverifyMathExpressions(expression.right, node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction getCalcNodes(node) {\n\tif (node.type !== 'function') {\n\t\treturn [];\n\t}\n\n\tconst functionName = node.value.toLowerCase();\n\tconst result = [];\n\n\tif (functionName === 'calc') {\n\t\tresult.push(node);\n\t}\n\n\tif (!functionName || functionName === 'calc') {\n\t\t// find nested calc\n\t\tfor (const c of node.nodes) {\n\t\t\tresult.push(...getCalcNodes(c));\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction getNumber(mathExpression) {\n\tconst { left, right } = mathExpression;\n\n\tconst leftValue =\n\t\tleft.type === 'Value' ? left.value : left.type === 'MathExpression' ? getNumber(left) : null;\n\tconst rightValue =\n\t\tright.type === 'Value'\n\t\t\t? right.value\n\t\t\t: right.type === 'MathExpression'\n\t\t\t? getNumber(right)\n\t\t\t: null;\n\n\tif (leftValue == null || rightValue == null) {\n\t\treturn null;\n\t}\n\n\tswitch (mathExpression.operator) {\n\t\tcase '+':\n\t\t\treturn leftValue + rightValue;\n\t\tcase '-':\n\t\t\treturn leftValue - rightValue;\n\t\tcase '*':\n\t\t\treturn leftValue * rightValue;\n\t\tcase '/':\n\t\t\treturn leftValue / rightValue;\n\t}\n\n\treturn null;\n}\n\nfunction getResolvedType(mathExpression) {\n\tconst { left: leftExpression, operator, right: rightExpression } = mathExpression;\n\tlet left =\n\t\tleftExpression.type === 'MathExpression'\n\t\t\t? getResolvedType(leftExpression)\n\t\t\t: leftExpression.type;\n\tlet right =\n\t\trightExpression.type === 'MathExpression'\n\t\t\t? getResolvedType(rightExpression)\n\t\t\t: rightExpression.type;\n\n\tif (left === 'Function' || left === 'invalid') {\n\t\tleft = 'UnknownValue';\n\t}\n\n\tif (right === 'Function' || right === 'invalid') {\n\t\tright = 'UnknownValue';\n\t}\n\n\tswitch (operator) {\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tif (left === 'UnknownValue' || right === 'UnknownValue') {\n\t\t\t\treturn 'UnknownValue';\n\t\t\t}\n\n\t\t\tif (left === right) {\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\tif (left === 'Value' || right === 'Value') {\n\t\t\t\treturn 'invalid';\n\t\t\t}\n\n\t\t\tif (left === 'PercentageValue') {\n\t\t\t\treturn right;\n\t\t\t}\n\n\t\t\tif (right === 'PercentageValue') {\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\treturn 'invalid';\n\t\tcase '*':\n\t\t\tif (left === 'UnknownValue' || right === 'UnknownValue') {\n\t\t\t\treturn 'UnknownValue';\n\t\t\t}\n\n\t\t\tif (left === 'Value') {\n\t\t\t\treturn right;\n\t\t\t}\n\n\t\t\tif (right === 'Value') {\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\treturn 'invalid';\n\t\tcase '/':\n\t\t\tif (right === 'UnknownValue') {\n\t\t\t\treturn 'UnknownValue';\n\t\t\t}\n\n\t\t\tif (right === 'Value') {\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\treturn 'invalid';\n\t}\n\n\treturn 'UnknownValue';\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}