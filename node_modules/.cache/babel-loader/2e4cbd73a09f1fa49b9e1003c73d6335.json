{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst COMMAND_PREFIX = 'stylelint-';\nconst disableCommand = `${COMMAND_PREFIX}disable`;\nconst enableCommand = `${COMMAND_PREFIX}enable`;\nconst disableLineCommand = `${COMMAND_PREFIX}disable-line`;\nconst disableNextLineCommand = `${COMMAND_PREFIX}disable-next-line`;\nconst ALL_RULES = 'all';\n/** @typedef {import('postcss/lib/comment')} PostcssComment */\n\n/** @typedef {import('postcss').Root} PostcssRoot */\n\n/** @typedef {import('stylelint').PostcssResult} PostcssResult */\n\n/** @typedef {import('stylelint').DisabledRangeObject} DisabledRangeObject */\n\n/** @typedef {import('stylelint').DisabledRange} DisabledRange */\n\n/**\n * @param {PostcssComment} comment\n * @param {number} start\n * @param {boolean} strictStart\n * @param {string|undefined} description\n * @param {number} [end]\n * @param {boolean} [strictEnd]\n * @returns {DisabledRange}\n */\n\nfunction createDisableRange(comment, start, strictStart, description, end, strictEnd) {\n  return {\n    comment,\n    start,\n    end: end || undefined,\n    strictStart,\n    strictEnd: typeof strictEnd === 'boolean' ? strictEnd : undefined,\n    description\n  };\n}\n/**\n * Run it like a plugin ...\n * @param {PostcssRoot} root\n * @param {PostcssResult} result\n * @returns {PostcssResult}\n */\n\n\nmodule.exports = function (root, result) {\n  result.stylelint = result.stylelint || {\n    disabledRanges: {},\n    ruleSeverities: {},\n    customMessages: {}\n  };\n  /**\n   * Most of the functions below work via side effects mutating this object\n   * @type {DisabledRangeObject}\n   */\n\n  const disabledRanges = {\n    all: []\n  };\n  result.stylelint.disabledRanges = disabledRanges; // Work around postcss/postcss-scss#109 by merging adjacent `//` comments\n  // into a single node before passing to `checkComment`.\n\n  /** @type {PostcssComment?} */\n\n  let inlineEnd;\n  root.walkComments(\n  /** @type {PostcssComment} */\n  comment => {\n    if (inlineEnd) {\n      // Ignore comments already processed by grouping with a previous one.\n      if (inlineEnd === comment) inlineEnd = null;\n      return;\n    }\n\n    const next = comment.next(); // If any of these conditions are not met, do not merge comments.\n\n    if (!(isInlineComment(comment) && isStylelintCommand(comment) && next && next.type === 'comment' && (comment.text.includes('--') || next.text.startsWith('--')))) {\n      checkComment(comment);\n      return;\n    }\n\n    let lastLine = comment.source && comment.source.end && comment.source.end.line || 0;\n    const fullComment = comment.clone();\n    /** @type {PostcssComment} */\n\n    let current = next;\n\n    while (isInlineComment(current) && !isStylelintCommand(current)) {\n      const currentLine = current.source && current.source.end && current.source.end.line || 0;\n      if (lastLine + 1 !== currentLine) break;\n      fullComment.text += `\\n${current.text}`;\n\n      if (fullComment.source && current.source) {\n        fullComment.source.end = current.source.end;\n      }\n\n      inlineEnd = current; // TODO: Issue #4985\n      // eslint-disable-next-line no-shadow\n\n      const next = current.next();\n      if (!next || next.type !== 'comment') break;\n      current = next;\n      lastLine = currentLine;\n    }\n\n    checkComment(fullComment);\n  });\n  return result;\n  /**\n   * @param {PostcssComment} comment\n   */\n\n  function isInlineComment(comment) {\n    // We check both here because the Sass parser uses `raws.inline` to indicate\n    // inline comments, while the Less parser uses `inline`.\n    return comment.inline || comment.raws.inline;\n  }\n  /**\n   * @param {PostcssComment} comment\n   */\n\n\n  function isStylelintCommand(comment) {\n    return comment.text.startsWith(disableCommand) || comment.text.startsWith(enableCommand);\n  }\n  /**\n   * @param {PostcssComment} comment\n   */\n\n\n  function processDisableLineCommand(comment) {\n    if (comment.source && comment.source.start) {\n      const line = comment.source.start.line;\n      const description = getDescription(comment.text);\n      getCommandRules(disableLineCommand, comment.text).forEach(ruleName => {\n        disableLine(comment, line, ruleName, description);\n      });\n    }\n  }\n  /**\n   * @param {PostcssComment} comment\n   */\n\n\n  function processDisableNextLineCommand(comment) {\n    if (comment.source && comment.source.end) {\n      const line = comment.source.end.line;\n      const description = getDescription(comment.text);\n      getCommandRules(disableNextLineCommand, comment.text).forEach(ruleName => {\n        disableLine(comment, line + 1, ruleName, description);\n      });\n    }\n  }\n  /**\n   * @param {PostcssComment} comment\n   * @param {number} line\n   * @param {string} ruleName\n   * @param {string|undefined} description\n   */\n\n\n  function disableLine(comment, line, ruleName, description) {\n    if (ruleIsDisabled(ALL_RULES)) {\n      throw comment.error('All rules have already been disabled', {\n        plugin: 'stylelint'\n      });\n    }\n\n    if (ruleName === ALL_RULES) {\n      Object.keys(disabledRanges).forEach(disabledRuleName => {\n        if (ruleIsDisabled(disabledRuleName)) return;\n        const strict = disabledRuleName === ALL_RULES;\n        startDisabledRange(comment, line, disabledRuleName, strict, description);\n        endDisabledRange(line, disabledRuleName, strict);\n      });\n    } else {\n      if (ruleIsDisabled(ruleName)) {\n        throw comment.error(`\"${ruleName}\" has already been disabled`, {\n          plugin: 'stylelint'\n        });\n      }\n\n      startDisabledRange(comment, line, ruleName, true, description);\n      endDisabledRange(line, ruleName, true);\n    }\n  }\n  /**\n   * @param {PostcssComment} comment\n   */\n\n\n  function processDisableCommand(comment) {\n    const description = getDescription(comment.text);\n    getCommandRules(disableCommand, comment.text).forEach(ruleToDisable => {\n      const isAllRules = ruleToDisable === ALL_RULES;\n\n      if (ruleIsDisabled(ruleToDisable)) {\n        throw comment.error(isAllRules ? 'All rules have already been disabled' : `\"${ruleToDisable}\" has already been disabled`, {\n          plugin: 'stylelint'\n        });\n      }\n\n      if (comment.source && comment.source.start) {\n        const line = comment.source.start.line;\n\n        if (isAllRules) {\n          Object.keys(disabledRanges).forEach(ruleName => {\n            startDisabledRange(comment, line, ruleName, ruleName === ALL_RULES, description);\n          });\n        } else {\n          startDisabledRange(comment, line, ruleToDisable, true, description);\n        }\n      }\n    });\n  }\n  /**\n   * @param {PostcssComment} comment\n   */\n\n\n  function processEnableCommand(comment) {\n    getCommandRules(enableCommand, comment.text).forEach(ruleToEnable => {\n      // TODO TYPES\n      // need fallback if endLine will be undefined\n      const endLine =\n      /** @type {number} */\n      comment.source && comment.source.end && comment.source.end.line;\n\n      if (ruleToEnable === ALL_RULES) {\n        if (Object.values(disabledRanges).every(ranges => ranges.length === 0 || typeof ranges[ranges.length - 1].end === 'number')) {\n          throw comment.error('No rules have been disabled', {\n            plugin: 'stylelint'\n          });\n        }\n\n        Object.keys(disabledRanges).forEach(ruleName => {\n          if (!_.get(_.last(disabledRanges[ruleName]), 'end')) {\n            endDisabledRange(endLine, ruleName, ruleName === ALL_RULES);\n          }\n        });\n        return;\n      }\n\n      if (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {\n        // Get a starting point from the where all rules were disabled\n        if (!disabledRanges[ruleToEnable]) {\n          disabledRanges[ruleToEnable] = disabledRanges.all.map(({\n            start,\n            end,\n            description\n          }) => createDisableRange(comment, start, false, description, end, false));\n        } else {\n          const range = _.last(disabledRanges[ALL_RULES]);\n\n          if (range) {\n            disabledRanges[ruleToEnable].push({ ...range\n            });\n          }\n        }\n\n        endDisabledRange(endLine, ruleToEnable, true);\n        return;\n      }\n\n      if (ruleIsDisabled(ruleToEnable)) {\n        endDisabledRange(endLine, ruleToEnable, true);\n        return;\n      }\n\n      throw comment.error(`\"${ruleToEnable}\" has not been disabled`, {\n        plugin: 'stylelint'\n      });\n    });\n  }\n  /**\n   * @param {PostcssComment} comment\n   */\n\n\n  function checkComment(comment) {\n    const text = comment.text; // Ignore comments that are not relevant commands\n\n    if (text.indexOf(COMMAND_PREFIX) !== 0) {\n      return result;\n    }\n\n    if (text.startsWith(disableLineCommand)) {\n      processDisableLineCommand(comment);\n    } else if (text.startsWith(disableNextLineCommand)) {\n      processDisableNextLineCommand(comment);\n    } else if (text.startsWith(disableCommand)) {\n      processDisableCommand(comment);\n    } else if (text.startsWith(enableCommand)) {\n      processEnableCommand(comment);\n    }\n  }\n  /**\n   * @param {string} command\n   * @param {string} fullText\n   * @returns {string[]}\n   */\n\n\n  function getCommandRules(command, fullText) {\n    const rules = fullText.slice(command.length).split(/\\s-{2,}\\s/u)[0] // Allow for description (f.e. /* stylelint-disable a, b -- Description */).\n    .trim().split(',').filter(Boolean).map(r => r.trim());\n\n    if (_.isEmpty(rules)) {\n      return [ALL_RULES];\n    }\n\n    return rules;\n  }\n  /**\n   * @param {string} fullText\n   * @returns {string|undefined}\n   */\n\n\n  function getDescription(fullText) {\n    const descriptionStart = fullText.indexOf('--');\n    if (descriptionStart === -1) return;\n    return fullText.slice(descriptionStart + 2).trim();\n  }\n  /**\n   * @param {PostcssComment} comment\n   * @param {number} line\n   * @param {string} ruleName\n   * @param {boolean} strict\n   * @param {string|undefined} description\n   */\n\n\n  function startDisabledRange(comment, line, ruleName, strict, description) {\n    const rangeObj = createDisableRange(comment, line, strict, description);\n    ensureRuleRanges(ruleName);\n    disabledRanges[ruleName].push(rangeObj);\n  }\n  /**\n   * @param {number} line\n   * @param {string} ruleName\n   * @param {boolean} strict\n   */\n\n\n  function endDisabledRange(line, ruleName, strict) {\n    const lastRangeForRule = _.last(disabledRanges[ruleName]);\n\n    if (!lastRangeForRule) {\n      return;\n    } // Add an `end` prop to the last range of that rule\n\n\n    lastRangeForRule.end = line;\n    lastRangeForRule.strictEnd = strict;\n  }\n  /**\n   * @param {string} ruleName\n   */\n\n\n  function ensureRuleRanges(ruleName) {\n    if (!disabledRanges[ruleName]) {\n      disabledRanges[ruleName] = disabledRanges.all.map(({\n        comment,\n        start,\n        end,\n        description\n      }) => createDisableRange(comment, start, false, description, end, false));\n    }\n  }\n  /**\n   * @param {string} ruleName\n   * @returns {boolean}\n   */\n\n\n  function ruleIsDisabled(ruleName) {\n    if (disabledRanges[ruleName] === undefined) return false;\n    if (_.last(disabledRanges[ruleName]) === undefined) return false;\n    if (_.get(_.last(disabledRanges[ruleName]), 'end') === undefined) return true;\n    return false;\n  }\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/assignDisabledRanges.js"],"names":["_","require","COMMAND_PREFIX","disableCommand","enableCommand","disableLineCommand","disableNextLineCommand","ALL_RULES","createDisableRange","comment","start","strictStart","description","end","strictEnd","undefined","module","exports","root","result","stylelint","disabledRanges","ruleSeverities","customMessages","all","inlineEnd","walkComments","next","isInlineComment","isStylelintCommand","type","text","includes","startsWith","checkComment","lastLine","source","line","fullComment","clone","current","currentLine","inline","raws","processDisableLineCommand","getDescription","getCommandRules","forEach","ruleName","disableLine","processDisableNextLineCommand","ruleIsDisabled","error","plugin","Object","keys","disabledRuleName","strict","startDisabledRange","endDisabledRange","processDisableCommand","ruleToDisable","isAllRules","processEnableCommand","ruleToEnable","endLine","values","every","ranges","length","get","last","map","range","push","indexOf","command","fullText","rules","slice","split","trim","filter","Boolean","r","isEmpty","descriptionStart","rangeObj","ensureRuleRanges","lastRangeForRule"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst COMMAND_PREFIX = 'stylelint-';\nconst disableCommand = `${COMMAND_PREFIX}disable`;\nconst enableCommand = `${COMMAND_PREFIX}enable`;\nconst disableLineCommand = `${COMMAND_PREFIX}disable-line`;\nconst disableNextLineCommand = `${COMMAND_PREFIX}disable-next-line`;\nconst ALL_RULES = 'all';\n\n/** @typedef {import('postcss/lib/comment')} PostcssComment */\n/** @typedef {import('postcss').Root} PostcssRoot */\n/** @typedef {import('stylelint').PostcssResult} PostcssResult */\n/** @typedef {import('stylelint').DisabledRangeObject} DisabledRangeObject */\n/** @typedef {import('stylelint').DisabledRange} DisabledRange */\n\n/**\n * @param {PostcssComment} comment\n * @param {number} start\n * @param {boolean} strictStart\n * @param {string|undefined} description\n * @param {number} [end]\n * @param {boolean} [strictEnd]\n * @returns {DisabledRange}\n */\nfunction createDisableRange(comment, start, strictStart, description, end, strictEnd) {\n\treturn {\n\t\tcomment,\n\t\tstart,\n\t\tend: end || undefined,\n\t\tstrictStart,\n\t\tstrictEnd: typeof strictEnd === 'boolean' ? strictEnd : undefined,\n\t\tdescription,\n\t};\n}\n\n/**\n * Run it like a plugin ...\n * @param {PostcssRoot} root\n * @param {PostcssResult} result\n * @returns {PostcssResult}\n */\nmodule.exports = function (root, result) {\n\tresult.stylelint = result.stylelint || {\n\t\tdisabledRanges: {},\n\t\truleSeverities: {},\n\t\tcustomMessages: {},\n\t};\n\n\t/**\n\t * Most of the functions below work via side effects mutating this object\n\t * @type {DisabledRangeObject}\n\t */\n\tconst disabledRanges = {\n\t\tall: [],\n\t};\n\n\tresult.stylelint.disabledRanges = disabledRanges;\n\n\t// Work around postcss/postcss-scss#109 by merging adjacent `//` comments\n\t// into a single node before passing to `checkComment`.\n\n\t/** @type {PostcssComment?} */\n\tlet inlineEnd;\n\n\troot.walkComments((/** @type {PostcssComment} */ comment) => {\n\t\tif (inlineEnd) {\n\t\t\t// Ignore comments already processed by grouping with a previous one.\n\t\t\tif (inlineEnd === comment) inlineEnd = null;\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = comment.next();\n\n\t\t// If any of these conditions are not met, do not merge comments.\n\t\tif (\n\t\t\t!(\n\t\t\t\tisInlineComment(comment) &&\n\t\t\t\tisStylelintCommand(comment) &&\n\t\t\t\tnext &&\n\t\t\t\tnext.type === 'comment' &&\n\t\t\t\t(comment.text.includes('--') || next.text.startsWith('--'))\n\t\t\t)\n\t\t) {\n\t\t\tcheckComment(comment);\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet lastLine = (comment.source && comment.source.end && comment.source.end.line) || 0;\n\t\tconst fullComment = comment.clone();\n\n\t\t/** @type {PostcssComment} */\n\t\tlet current = next;\n\n\t\twhile (isInlineComment(current) && !isStylelintCommand(current)) {\n\t\t\tconst currentLine = (current.source && current.source.end && current.source.end.line) || 0;\n\n\t\t\tif (lastLine + 1 !== currentLine) break;\n\n\t\t\tfullComment.text += `\\n${current.text}`;\n\n\t\t\tif (fullComment.source && current.source) {\n\t\t\t\tfullComment.source.end = current.source.end;\n\t\t\t}\n\n\t\t\tinlineEnd = current;\n\t\t\t// TODO: Issue #4985\n\t\t\t// eslint-disable-next-line no-shadow\n\t\t\tconst next = current.next();\n\n\t\t\tif (!next || next.type !== 'comment') break;\n\n\t\t\tcurrent = next;\n\t\t\tlastLine = currentLine;\n\t\t}\n\t\tcheckComment(fullComment);\n\t});\n\n\treturn result;\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction isInlineComment(comment) {\n\t\t// We check both here because the Sass parser uses `raws.inline` to indicate\n\t\t// inline comments, while the Less parser uses `inline`.\n\t\treturn comment.inline || comment.raws.inline;\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction isStylelintCommand(comment) {\n\t\treturn comment.text.startsWith(disableCommand) || comment.text.startsWith(enableCommand);\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction processDisableLineCommand(comment) {\n\t\tif (comment.source && comment.source.start) {\n\t\t\tconst line = comment.source.start.line;\n\t\t\tconst description = getDescription(comment.text);\n\n\t\t\tgetCommandRules(disableLineCommand, comment.text).forEach((ruleName) => {\n\t\t\t\tdisableLine(comment, line, ruleName, description);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction processDisableNextLineCommand(comment) {\n\t\tif (comment.source && comment.source.end) {\n\t\t\tconst line = comment.source.end.line;\n\t\t\tconst description = getDescription(comment.text);\n\n\t\t\tgetCommandRules(disableNextLineCommand, comment.text).forEach((ruleName) => {\n\t\t\t\tdisableLine(comment, line + 1, ruleName, description);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t * @param {number} line\n\t * @param {string} ruleName\n\t * @param {string|undefined} description\n\t */\n\tfunction disableLine(comment, line, ruleName, description) {\n\t\tif (ruleIsDisabled(ALL_RULES)) {\n\t\t\tthrow comment.error('All rules have already been disabled', {\n\t\t\t\tplugin: 'stylelint',\n\t\t\t});\n\t\t}\n\n\t\tif (ruleName === ALL_RULES) {\n\t\t\tObject.keys(disabledRanges).forEach((disabledRuleName) => {\n\t\t\t\tif (ruleIsDisabled(disabledRuleName)) return;\n\n\t\t\t\tconst strict = disabledRuleName === ALL_RULES;\n\n\t\t\t\tstartDisabledRange(comment, line, disabledRuleName, strict, description);\n\t\t\t\tendDisabledRange(line, disabledRuleName, strict);\n\t\t\t});\n\t\t} else {\n\t\t\tif (ruleIsDisabled(ruleName)) {\n\t\t\t\tthrow comment.error(`\"${ruleName}\" has already been disabled`, {\n\t\t\t\t\tplugin: 'stylelint',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tstartDisabledRange(comment, line, ruleName, true, description);\n\t\t\tendDisabledRange(line, ruleName, true);\n\t\t}\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction processDisableCommand(comment) {\n\t\tconst description = getDescription(comment.text);\n\n\t\tgetCommandRules(disableCommand, comment.text).forEach((ruleToDisable) => {\n\t\t\tconst isAllRules = ruleToDisable === ALL_RULES;\n\n\t\t\tif (ruleIsDisabled(ruleToDisable)) {\n\t\t\t\tthrow comment.error(\n\t\t\t\t\tisAllRules\n\t\t\t\t\t\t? 'All rules have already been disabled'\n\t\t\t\t\t\t: `\"${ruleToDisable}\" has already been disabled`,\n\t\t\t\t\t{\n\t\t\t\t\t\tplugin: 'stylelint',\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (comment.source && comment.source.start) {\n\t\t\t\tconst line = comment.source.start.line;\n\n\t\t\t\tif (isAllRules) {\n\t\t\t\t\tObject.keys(disabledRanges).forEach((ruleName) => {\n\t\t\t\t\t\tstartDisabledRange(comment, line, ruleName, ruleName === ALL_RULES, description);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tstartDisabledRange(comment, line, ruleToDisable, true, description);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction processEnableCommand(comment) {\n\t\tgetCommandRules(enableCommand, comment.text).forEach((ruleToEnable) => {\n\t\t\t// TODO TYPES\n\t\t\t// need fallback if endLine will be undefined\n\t\t\tconst endLine = /** @type {number} */ (comment.source &&\n\t\t\t\tcomment.source.end &&\n\t\t\t\tcomment.source.end.line);\n\n\t\t\tif (ruleToEnable === ALL_RULES) {\n\t\t\t\tif (\n\t\t\t\t\tObject.values(disabledRanges).every(\n\t\t\t\t\t\t(ranges) => ranges.length === 0 || typeof ranges[ranges.length - 1].end === 'number',\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrow comment.error('No rules have been disabled', {\n\t\t\t\t\t\tplugin: 'stylelint',\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tObject.keys(disabledRanges).forEach((ruleName) => {\n\t\t\t\t\tif (!_.get(_.last(disabledRanges[ruleName]), 'end')) {\n\t\t\t\t\t\tendDisabledRange(endLine, ruleName, ruleName === ALL_RULES);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {\n\t\t\t\t// Get a starting point from the where all rules were disabled\n\t\t\t\tif (!disabledRanges[ruleToEnable]) {\n\t\t\t\t\tdisabledRanges[ruleToEnable] = disabledRanges.all.map(({ start, end, description }) =>\n\t\t\t\t\t\tcreateDisableRange(comment, start, false, description, end, false),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst range = _.last(disabledRanges[ALL_RULES]);\n\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tdisabledRanges[ruleToEnable].push({ ...range });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendDisabledRange(endLine, ruleToEnable, true);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ruleIsDisabled(ruleToEnable)) {\n\t\t\t\tendDisabledRange(endLine, ruleToEnable, true);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthrow comment.error(`\"${ruleToEnable}\" has not been disabled`, {\n\t\t\t\tplugin: 'stylelint',\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t */\n\tfunction checkComment(comment) {\n\t\tconst text = comment.text;\n\n\t\t// Ignore comments that are not relevant commands\n\n\t\tif (text.indexOf(COMMAND_PREFIX) !== 0) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (text.startsWith(disableLineCommand)) {\n\t\t\tprocessDisableLineCommand(comment);\n\t\t} else if (text.startsWith(disableNextLineCommand)) {\n\t\t\tprocessDisableNextLineCommand(comment);\n\t\t} else if (text.startsWith(disableCommand)) {\n\t\t\tprocessDisableCommand(comment);\n\t\t} else if (text.startsWith(enableCommand)) {\n\t\t\tprocessEnableCommand(comment);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} command\n\t * @param {string} fullText\n\t * @returns {string[]}\n\t */\n\tfunction getCommandRules(command, fullText) {\n\t\tconst rules = fullText\n\t\t\t.slice(command.length)\n\t\t\t.split(/\\s-{2,}\\s/u)[0] // Allow for description (f.e. /* stylelint-disable a, b -- Description */).\n\t\t\t.trim()\n\t\t\t.split(',')\n\t\t\t.filter(Boolean)\n\t\t\t.map((r) => r.trim());\n\n\t\tif (_.isEmpty(rules)) {\n\t\t\treturn [ALL_RULES];\n\t\t}\n\n\t\treturn rules;\n\t}\n\n\t/**\n\t * @param {string} fullText\n\t * @returns {string|undefined}\n\t */\n\tfunction getDescription(fullText) {\n\t\tconst descriptionStart = fullText.indexOf('--');\n\n\t\tif (descriptionStart === -1) return;\n\n\t\treturn fullText.slice(descriptionStart + 2).trim();\n\t}\n\n\t/**\n\t * @param {PostcssComment} comment\n\t * @param {number} line\n\t * @param {string} ruleName\n\t * @param {boolean} strict\n\t * @param {string|undefined} description\n\t */\n\tfunction startDisabledRange(comment, line, ruleName, strict, description) {\n\t\tconst rangeObj = createDisableRange(comment, line, strict, description);\n\n\t\tensureRuleRanges(ruleName);\n\t\tdisabledRanges[ruleName].push(rangeObj);\n\t}\n\n\t/**\n\t * @param {number} line\n\t * @param {string} ruleName\n\t * @param {boolean} strict\n\t */\n\tfunction endDisabledRange(line, ruleName, strict) {\n\t\tconst lastRangeForRule = _.last(disabledRanges[ruleName]);\n\n\t\tif (!lastRangeForRule) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Add an `end` prop to the last range of that rule\n\t\tlastRangeForRule.end = line;\n\t\tlastRangeForRule.strictEnd = strict;\n\t}\n\n\t/**\n\t * @param {string} ruleName\n\t */\n\tfunction ensureRuleRanges(ruleName) {\n\t\tif (!disabledRanges[ruleName]) {\n\t\t\tdisabledRanges[ruleName] = disabledRanges.all.map(({ comment, start, end, description }) =>\n\t\t\t\tcreateDisableRange(comment, start, false, description, end, false),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} ruleName\n\t * @returns {boolean}\n\t */\n\tfunction ruleIsDisabled(ruleName) {\n\t\tif (disabledRanges[ruleName] === undefined) return false;\n\n\t\tif (_.last(disabledRanges[ruleName]) === undefined) return false;\n\n\t\tif (_.get(_.last(disabledRanges[ruleName]), 'end') === undefined) return true;\n\n\t\treturn false;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}