{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-list-comma-newline-before';\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => 'Expected newline before \",\"',\n  expectedBeforeMultiLine: () => 'Expected newline before \",\" in a multi-line list',\n  rejectedBeforeMultiLine: () => 'Unexpected whitespace before \",\" in a multi-line list'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    let fixData;\n    selectorListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.beforeAllowingIndentation,\n      checkedRuleName: ruleName,\n      fix: context.fix ? (ruleNode, index) => {\n        fixData = fixData || new Map();\n        const commaIndices = fixData.get(ruleNode) || [];\n        commaIndices.push(index);\n        fixData.set(ruleNode, commaIndices);\n        return true;\n      } : null\n    });\n\n    if (fixData) {\n      fixData.forEach((commaIndices, ruleNode) => {\n        let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;\n        commaIndices.sort((a, b) => b - a).forEach(index => {\n          let beforeSelector = selector.slice(0, index);\n          const afterSelector = selector.slice(index);\n\n          if (expectation.startsWith('always')) {\n            const spaceIndex = beforeSelector.search(/\\s+$/);\n\n            if (spaceIndex >= 0) {\n              beforeSelector = beforeSelector.slice(0, spaceIndex) + context.newline + beforeSelector.slice(spaceIndex);\n            } else {\n              beforeSelector += context.newline;\n            }\n          } else if (expectation === 'never-multi-line') {\n            beforeSelector = beforeSelector.replace(/\\s*$/, '');\n          }\n\n          selector = beforeSelector + afterSelector;\n        });\n\n        if (ruleNode.raws.selector) {\n          ruleNode.raws.selector.raw = selector;\n        } else {\n          ruleNode.selector = selector;\n        }\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-list-comma-newline-before/index.js"],"names":["ruleMessages","require","selectorListCommaWhitespaceChecker","validateOptions","whitespaceChecker","ruleName","messages","expectedBefore","expectedBeforeMultiLine","rejectedBeforeMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","fixData","locationChecker","beforeAllowingIndentation","checkedRuleName","fix","ruleNode","index","Map","commaIndices","get","push","set","forEach","selector","raws","raw","sort","a","b","beforeSelector","slice","afterSelector","startsWith","spaceIndex","search","newline","replace","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst ruleMessages = require('../../utils/ruleMessages');\nconst selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-list-comma-newline-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedBefore: () => 'Expected newline before \",\"',\n\texpectedBeforeMultiLine: () => 'Expected newline before \",\" in a multi-line list',\n\trejectedBeforeMultiLine: () => 'Unexpected whitespace before \",\" in a multi-line list',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet fixData;\n\n\t\tselectorListCommaWhitespaceChecker({\n\t\t\troot,\n\t\t\tresult,\n\t\t\tlocationChecker: checker.beforeAllowingIndentation,\n\t\t\tcheckedRuleName: ruleName,\n\t\t\tfix: context.fix\n\t\t\t\t? (ruleNode, index) => {\n\t\t\t\t\t\tfixData = fixData || new Map();\n\t\t\t\t\t\tconst commaIndices = fixData.get(ruleNode) || [];\n\n\t\t\t\t\t\tcommaIndices.push(index);\n\t\t\t\t\t\tfixData.set(ruleNode, commaIndices);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t  }\n\t\t\t\t: null,\n\t\t});\n\n\t\tif (fixData) {\n\t\t\tfixData.forEach((commaIndices, ruleNode) => {\n\t\t\t\tlet selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;\n\n\t\t\t\tcommaIndices\n\t\t\t\t\t.sort((a, b) => b - a)\n\t\t\t\t\t.forEach((index) => {\n\t\t\t\t\t\tlet beforeSelector = selector.slice(0, index);\n\t\t\t\t\t\tconst afterSelector = selector.slice(index);\n\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tconst spaceIndex = beforeSelector.search(/\\s+$/);\n\n\t\t\t\t\t\t\tif (spaceIndex >= 0) {\n\t\t\t\t\t\t\t\tbeforeSelector =\n\t\t\t\t\t\t\t\t\tbeforeSelector.slice(0, spaceIndex) +\n\t\t\t\t\t\t\t\t\tcontext.newline +\n\t\t\t\t\t\t\t\t\tbeforeSelector.slice(spaceIndex);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbeforeSelector += context.newline;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (expectation === 'never-multi-line') {\n\t\t\t\t\t\t\tbeforeSelector = beforeSelector.replace(/\\s*$/, '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tselector = beforeSelector + afterSelector;\n\t\t\t\t\t});\n\n\t\t\t\tif (ruleNode.raws.selector) {\n\t\t\t\t\truleNode.raws.selector.raw = selector;\n\t\t\t\t} else {\n\t\t\t\t\truleNode.selector = selector;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}