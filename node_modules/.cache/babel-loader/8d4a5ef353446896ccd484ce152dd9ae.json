{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  _createClass(Range, null, [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }]);\n\n  return Range;\n}();\n/** Root class of all nodes */\n\n\nvar Node = /*#__PURE__*/function () {\n  _createClass(Node, null, [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3),\n                _ = _tag$match2[0],\n                handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\n\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\n\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\n\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/yaml/browser/dist/PlainValue-ff5147c6.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","value","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","call","e","_construct","Parent","args","Class","a","push","apply","Function","bind","arguments","_isNativeFunction","fn","indexOf","_wrapNativeSuper","_cache","Map","undefined","has","get","set","Wrapper","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","Super","result","NewTarget","_superPropBase","object","property","hasOwnProperty","_get","receiver","base","desc","getOwnPropertyDescriptor","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toArray","_iterableToArray","Array","isArray","iter","from","_arr","_n","_d","_e","_i","_s","next","done","err","minLen","_arrayLikeToArray","n","slice","name","test","len","arr2","_createForOfIteratorHelper","F","s","f","it","normalCompletion","didErr","step","return","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","defaultTagPrefix","defaultTags","STR","findLineStarts","src","ls","offset","getSrcInfo","cst","lineStarts","context","getLinePos","_getSrcInfo","start","line","col","getLine","_getSrcInfo2","end","getPrettyContext","_ref","maxWidth","substr","halfWidth","Math","round","errLen","errEnd","min","repeat","concat","Range","copy","orig","isEmpty","setOrigRange","cr","origStart","origEnd","nextOffset","Node","addStringTerminator","str","endOfWhiteSpace","atDocumentBoundary","sep","ch0","prev","ch1","ch2","ch3","endOfIdentifier","ch","isVerbatim","notOk","endOfIndent","endOfLine","startOfLine","endOfBlockIndent","indent","lineStart","inEnd","wsEnd","atBlank","endAsBlank","nextNodeIsIndented","indentDiff","indicatorAsIndent","normalizeOffset","foldNewline","inCount","error","fold","type","range","valueRange","getPropValue","idx","skipKey","prop","commentHasRequiredWhitespace","header","parseComment","commentRange","setOrigRanges","forEach","anchor","comments","comment","join","jsonLikeTypes","root","_this$valueRange","tag","verbatim","_tag$match","match","_tag$match2","_","handle","suffix","_this$valueRange2","YAMLError","_Error","_super","source","message","_this","Error","makePretty","nodeType","linePos","rangeAsLinePos","_this$linePos$start","ctx","YAMLReferenceError","_YAMLError","_super2","YAMLSemanticError","_YAMLError2","_super3","YAMLSyntaxError","_YAMLError3","_super4","YAMLWarning","_YAMLError4","_super5","PlainValue","_Node","parseBlockValue","_this$context","inFlow","valueEnd","parse","hasComment","_ch","_Node$foldNewline","wsStart","msg","errors","_msg","_errors","C","N","P","R","T","Y","b","c","d","g","h","j","k","l","m","q","r"],"mappings":"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","sourcesContent":["function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  _createClass(Range, null, [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  _createClass(Node, null, [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3),\n                _ = _tag$match2[0],\n                handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };\n"]},"metadata":{},"sourceType":"module"}