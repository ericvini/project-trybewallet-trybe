{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'hue-degree-notation';\nconst messages = ruleMessages(ruleName, {\n  expected: (unfixed, fixed) => `Expected \"${unfixed}\" to be \"${fixed}\"`\n});\nconst HUE_FIRST_ARG_FUNCS = ['hsl', 'hsla', 'hwb'];\nconst HUE_THIRD_ARG_FUNCS = ['lch'];\nconst HUE_FUNCS = [...HUE_FIRST_ARG_FUNCS, ...HUE_THIRD_ARG_FUNCS];\n\nfunction rule(primary, secondary, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: primary,\n      possible: ['angle', 'number']\n    });\n    if (!validOptions) return;\n    root.walkDecls(decl => {\n      let needsFix = false;\n      const parsedValue = valueParser(getValue(decl));\n      parsedValue.walk(node => {\n        if (node.type !== 'function') return;\n        if (!HUE_FUNCS.includes(node.value.toLowerCase())) return;\n        const hue = findHue(node);\n        if (!hue) return;\n        const {\n          value\n        } = hue;\n        if (!isStandardSyntaxValue(value)) return;\n        if (!isDegree(value) && !isNumber(value)) return;\n        if (primary === 'angle' && isDegree(value)) return;\n        if (primary === 'number' && isNumber(value)) return;\n        const fixed = primary === 'angle' ? asDegree(value) : asNumber(value);\n        const unfixed = value;\n\n        if (context.fix) {\n          hue.value = fixed;\n          needsFix = true;\n          return;\n        }\n\n        report({\n          message: messages.expected(unfixed, fixed),\n          node: decl,\n          index: declarationValueIndex(decl) + hue.sourceIndex,\n          result,\n          ruleName\n        });\n      });\n\n      if (needsFix) {\n        setValue(decl, parsedValue.toString());\n      }\n    });\n  };\n}\n\nfunction asDegree(value) {\n  return `${value}deg`;\n}\n\nfunction asNumber(value) {\n  const {\n    number\n  } = valueParser.unit(value);\n  return number;\n}\n\nfunction findHue(node) {\n  const args = node.nodes.filter(({\n    type\n  }) => type === 'word' || type === 'function');\n  const value = node.value.toLowerCase();\n\n  if (HUE_FIRST_ARG_FUNCS.includes(value)) {\n    return args[0];\n  }\n\n  if (HUE_THIRD_ARG_FUNCS.includes(value)) {\n    return args[2];\n  }\n\n  return false;\n}\n\nfunction isDegree(value) {\n  const {\n    unit\n  } = valueParser.unit(value);\n  return unit && unit.toLowerCase() === 'deg';\n}\n\nfunction isNumber(value) {\n  const {\n    unit\n  } = valueParser.unit(value);\n  return unit === '';\n}\n\nfunction getValue(decl) {\n  return decl.raws.value ? decl.raws.value.raw : decl.value;\n}\n\nfunction setValue(decl, value) {\n  if (decl.raws.value) decl.raws.value.raw = value;else decl.value = value;\n  return decl;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/hue-degree-notation/index.js"],"names":["valueParser","require","declarationValueIndex","isStandardSyntaxValue","report","ruleMessages","validateOptions","ruleName","messages","expected","unfixed","fixed","HUE_FIRST_ARG_FUNCS","HUE_THIRD_ARG_FUNCS","HUE_FUNCS","rule","primary","secondary","context","root","result","validOptions","actual","possible","walkDecls","decl","needsFix","parsedValue","getValue","walk","node","type","includes","value","toLowerCase","hue","findHue","isDegree","isNumber","asDegree","asNumber","fix","message","index","sourceIndex","setValue","toString","number","unit","args","nodes","filter","raws","raw","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'hue-degree-notation';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (unfixed, fixed) => `Expected \"${unfixed}\" to be \"${fixed}\"`,\n});\n\nconst HUE_FIRST_ARG_FUNCS = ['hsl', 'hsla', 'hwb'];\nconst HUE_THIRD_ARG_FUNCS = ['lch'];\nconst HUE_FUNCS = [...HUE_FIRST_ARG_FUNCS, ...HUE_THIRD_ARG_FUNCS];\n\nfunction rule(primary, secondary, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: primary,\n\t\t\tpossible: ['angle', 'number'],\n\t\t});\n\n\t\tif (!validOptions) return;\n\n\t\troot.walkDecls((decl) => {\n\t\t\tlet needsFix = false;\n\t\t\tconst parsedValue = valueParser(getValue(decl));\n\n\t\t\tparsedValue.walk((node) => {\n\t\t\t\tif (node.type !== 'function') return;\n\n\t\t\t\tif (!HUE_FUNCS.includes(node.value.toLowerCase())) return;\n\n\t\t\t\tconst hue = findHue(node);\n\n\t\t\t\tif (!hue) return;\n\n\t\t\t\tconst { value } = hue;\n\n\t\t\t\tif (!isStandardSyntaxValue(value)) return;\n\n\t\t\t\tif (!isDegree(value) && !isNumber(value)) return;\n\n\t\t\t\tif (primary === 'angle' && isDegree(value)) return;\n\n\t\t\t\tif (primary === 'number' && isNumber(value)) return;\n\n\t\t\t\tconst fixed = primary === 'angle' ? asDegree(value) : asNumber(value);\n\t\t\t\tconst unfixed = value;\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\thue.value = fixed;\n\t\t\t\t\tneedsFix = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(unfixed, fixed),\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + hue.sourceIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (needsFix) {\n\t\t\t\tsetValue(decl, parsedValue.toString());\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction asDegree(value) {\n\treturn `${value}deg`;\n}\n\nfunction asNumber(value) {\n\tconst { number } = valueParser.unit(value);\n\n\treturn number;\n}\n\nfunction findHue(node) {\n\tconst args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');\n\tconst value = node.value.toLowerCase();\n\n\tif (HUE_FIRST_ARG_FUNCS.includes(value)) {\n\t\treturn args[0];\n\t}\n\n\tif (HUE_THIRD_ARG_FUNCS.includes(value)) {\n\t\treturn args[2];\n\t}\n\n\treturn false;\n}\n\nfunction isDegree(value) {\n\tconst { unit } = valueParser.unit(value);\n\n\treturn unit && unit.toLowerCase() === 'deg';\n}\n\nfunction isNumber(value) {\n\tconst { unit } = valueParser.unit(value);\n\n\treturn unit === '';\n}\n\nfunction getValue(decl) {\n\treturn decl.raws.value ? decl.raws.value.raw : decl.value;\n}\n\nfunction setValue(decl, value) {\n\tif (decl.raws.value) decl.raws.value.raw = value;\n\telse decl.value = value;\n\n\treturn decl;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}