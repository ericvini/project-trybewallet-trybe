{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst ignoredOptions = ['severity', 'message', 'reportDisables'];\n/** @typedef {{possible: any, actual: any, optional: boolean}} Options */\n\n/**\n * Validate a rule's options.\n *\n * See existing rules for examples.\n *\n * @param {import('stylelint').PostcssResult} result - postcss result\n * @param {string} ruleName\n * @param {...Options} optionDescriptions - Each optionDescription can\n *   have the following properties:\n *   \t- `actual` (required): the actual passed option value or object.\n *   \t- `possible` (required): a schema representation of what values are\n *      valid for those options. `possible` should be an object if the\n *      options are an object, with corresponding keys; if the options are not an\n *      object, `possible` isn't, either. All `possible` value representations\n *      should be **arrays of either values or functions**. Values are === checked\n *      against `actual`. Functions are fed `actual` as an argument and their\n *      return value is interpreted: truthy = valid, falsy = invalid.\n *    - `optional` (optional): If this is `true`, `actual` can be undefined.\n * @return {boolean} Whether or not the options are valid (true = valid)\n */\n\nmodule.exports = function (result, ruleName, ...optionDescriptions) {\n  let noErrors = true;\n  optionDescriptions.forEach(optionDescription => {\n    validate(optionDescription, ruleName, complain);\n  });\n  /**\n   * @param {string} message\n   */\n\n  function complain(message) {\n    noErrors = false;\n    result.warn(message, {\n      stylelintType: 'invalidOption'\n    });\n\n    _.set(result, 'stylelint.stylelintError', true);\n  }\n\n  return noErrors;\n};\n/**\n * @param {Options} opts\n * @param {string} ruleName\n * @param {(s: string) => void} complain\n */\n\n\nfunction validate(opts, ruleName, complain) {\n  const possible = opts.possible;\n  const actual = opts.actual;\n  const optional = opts.optional;\n\n  if (actual === null || _.isEqual(actual, [null])) {\n    return;\n  }\n\n  const nothingPossible = possible === undefined || Array.isArray(possible) && possible.length === 0;\n\n  if (nothingPossible && actual === true) {\n    return;\n  }\n\n  if (actual === undefined) {\n    if (nothingPossible || optional) {\n      return;\n    }\n\n    complain(`Expected option value for rule \"${ruleName}\"`);\n    return;\n  }\n\n  if (nothingPossible) {\n    if (optional) {\n      complain(`Incorrect configuration for rule \"${ruleName}\". Rule should have \"possible\" values for options validation`);\n      return;\n    }\n\n    complain(`Unexpected option value \"${String(actual)}\" for rule \"${ruleName}\"`);\n    return;\n  } // If `possible` is a function ...\n\n\n  if (_.isFunction(possible)) {\n    if (!possible(actual)) {\n      complain(`Invalid option \"${JSON.stringify(actual)}\" for rule ${ruleName}`);\n    }\n\n    return;\n  } // If `possible` is an array instead of an object ...\n\n\n  if (!_.isPlainObject(possible)) {\n    [].concat(actual).forEach(a => {\n      if (isValid(possible, a)) {\n        return;\n      }\n\n      complain(`Invalid option value \"${String(a)}\" for rule \"${ruleName}\"`);\n    });\n    return;\n  } // If actual is NOT an object ...\n\n\n  if (typeof actual !== 'object') {\n    complain(`Invalid option value ${JSON.stringify(actual)} for rule \"${ruleName}\": should be an object`);\n    return;\n  }\n\n  Object.keys(actual).forEach(optionName => {\n    if (ignoredOptions.includes(optionName)) {\n      return;\n    }\n\n    if (!possible[optionName]) {\n      complain(`Invalid option name \"${optionName}\" for rule \"${ruleName}\"`);\n      return;\n    }\n\n    const actualOptionValue = actual[optionName];\n    [].concat(actualOptionValue).forEach(a => {\n      if (isValid(possible[optionName], a)) {\n        return;\n      }\n\n      complain(`Invalid value \"${a}\" for option \"${optionName}\" of rule \"${ruleName}\"`);\n    });\n  });\n}\n/**\n * @param {any|Function} possible\n * @param {any} actual\n * @returns {boolean}\n */\n\n\nfunction isValid(possible, actual) {\n  const possibleList =\n  /** @type {Array<any|Function>} */\n  [].concat(possible);\n\n  for (let i = 0, l = possibleList.length; i < l; i++) {\n    const possibility = possibleList[i];\n\n    if (typeof possibility === 'function' && possibility(actual)) {\n      return true;\n    }\n\n    if (actual === possibility) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/validateOptions.js"],"names":["_","require","ignoredOptions","module","exports","result","ruleName","optionDescriptions","noErrors","forEach","optionDescription","validate","complain","message","warn","stylelintType","set","opts","possible","actual","optional","isEqual","nothingPossible","undefined","Array","isArray","length","String","isFunction","JSON","stringify","isPlainObject","concat","a","isValid","Object","keys","optionName","includes","actualOptionValue","possibleList","i","l","possibility"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst ignoredOptions = ['severity', 'message', 'reportDisables'];\n\n/** @typedef {{possible: any, actual: any, optional: boolean}} Options */\n\n/**\n * Validate a rule's options.\n *\n * See existing rules for examples.\n *\n * @param {import('stylelint').PostcssResult} result - postcss result\n * @param {string} ruleName\n * @param {...Options} optionDescriptions - Each optionDescription can\n *   have the following properties:\n *   \t- `actual` (required): the actual passed option value or object.\n *   \t- `possible` (required): a schema representation of what values are\n *      valid for those options. `possible` should be an object if the\n *      options are an object, with corresponding keys; if the options are not an\n *      object, `possible` isn't, either. All `possible` value representations\n *      should be **arrays of either values or functions**. Values are === checked\n *      against `actual`. Functions are fed `actual` as an argument and their\n *      return value is interpreted: truthy = valid, falsy = invalid.\n *    - `optional` (optional): If this is `true`, `actual` can be undefined.\n * @return {boolean} Whether or not the options are valid (true = valid)\n */\n\nmodule.exports = function (result, ruleName, ...optionDescriptions) {\n\tlet noErrors = true;\n\n\toptionDescriptions.forEach((optionDescription) => {\n\t\tvalidate(optionDescription, ruleName, complain);\n\t});\n\n\t/**\n\t * @param {string} message\n\t */\n\tfunction complain(message) {\n\t\tnoErrors = false;\n\t\tresult.warn(message, {\n\t\t\tstylelintType: 'invalidOption',\n\t\t});\n\t\t_.set(result, 'stylelint.stylelintError', true);\n\t}\n\n\treturn noErrors;\n};\n\n/**\n * @param {Options} opts\n * @param {string} ruleName\n * @param {(s: string) => void} complain\n */\nfunction validate(opts, ruleName, complain) {\n\tconst possible = opts.possible;\n\tconst actual = opts.actual;\n\tconst optional = opts.optional;\n\n\tif (actual === null || _.isEqual(actual, [null])) {\n\t\treturn;\n\t}\n\n\tconst nothingPossible =\n\t\tpossible === undefined || (Array.isArray(possible) && possible.length === 0);\n\n\tif (nothingPossible && actual === true) {\n\t\treturn;\n\t}\n\n\tif (actual === undefined) {\n\t\tif (nothingPossible || optional) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomplain(`Expected option value for rule \"${ruleName}\"`);\n\n\t\treturn;\n\t}\n\n\tif (nothingPossible) {\n\t\tif (optional) {\n\t\t\tcomplain(\n\t\t\t\t`Incorrect configuration for rule \"${ruleName}\". Rule should have \"possible\" values for options validation`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tcomplain(`Unexpected option value \"${String(actual)}\" for rule \"${ruleName}\"`);\n\n\t\treturn;\n\t}\n\n\t// If `possible` is a function ...\n\tif (_.isFunction(possible)) {\n\t\tif (!possible(actual)) {\n\t\t\tcomplain(`Invalid option \"${JSON.stringify(actual)}\" for rule ${ruleName}`);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// If `possible` is an array instead of an object ...\n\tif (!_.isPlainObject(possible)) {\n\t\t[].concat(actual).forEach((a) => {\n\t\t\tif (isValid(possible, a)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomplain(`Invalid option value \"${String(a)}\" for rule \"${ruleName}\"`);\n\t\t});\n\n\t\treturn;\n\t}\n\n\t// If actual is NOT an object ...\n\tif (typeof actual !== 'object') {\n\t\tcomplain(\n\t\t\t`Invalid option value ${JSON.stringify(actual)} for rule \"${ruleName}\": should be an object`,\n\t\t);\n\n\t\treturn;\n\t}\n\n\tObject.keys(actual).forEach((optionName) => {\n\t\tif (ignoredOptions.includes(optionName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!possible[optionName]) {\n\t\t\tcomplain(`Invalid option name \"${optionName}\" for rule \"${ruleName}\"`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst actualOptionValue = actual[optionName];\n\n\t\t[].concat(actualOptionValue).forEach((a) => {\n\t\t\tif (isValid(possible[optionName], a)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomplain(`Invalid value \"${a}\" for option \"${optionName}\" of rule \"${ruleName}\"`);\n\t\t});\n\t});\n}\n\n/**\n * @param {any|Function} possible\n * @param {any} actual\n * @returns {boolean}\n */\nfunction isValid(possible, actual) {\n\tconst possibleList = /** @type {Array<any|Function>} */ ([]).concat(possible);\n\n\tfor (let i = 0, l = possibleList.length; i < l; i++) {\n\t\tconst possibility = possibleList[i];\n\n\t\tif (typeof possibility === 'function' && possibility(actual)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (actual === possibility) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"]},"metadata":{},"sourceType":"script"}