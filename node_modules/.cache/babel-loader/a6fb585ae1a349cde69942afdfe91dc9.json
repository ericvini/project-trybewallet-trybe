{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\n\nconst isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');\n\nconst keywordSets = require('../../reference/keywordSets');\n\nconst namedColorDataHex = require('../../reference/namedColorData');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst propertySets = require('../../reference/propertySets');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst generateColorFuncs = require('./generateColorFuncs');\n\nconst ruleName = 'color-named';\nconst messages = ruleMessages(ruleName, {\n  expected: (named, original) => `Expected \"${original}\" to be \"${named}\"`,\n  rejected: named => `Unexpected named color \"${named}\"`\n}); // Todo tested on case insensivity\n\nconst NODE_TYPES = ['word', 'function'];\n\nfunction rule(expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['never', 'always-where-possible']\n    }, {\n      actual: options,\n      possible: {\n        ignoreProperties: [_.isString, _.isRegExp],\n        ignore: ['inside-function']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const namedColors = Object.keys(namedColorDataHex);\n    const namedColorData = {};\n    namedColors.forEach(name => {\n      const hex = namedColorDataHex[name];\n      namedColorData[name] = {\n        hex,\n        func: generateColorFuncs(hex[0])\n      };\n    });\n    root.walkDecls(decl => {\n      if (propertySets.acceptCustomIdents.has(decl.prop)) {\n        return;\n      } // Return early if the property is to be ignored\n\n\n      if (optionsMatches(options, 'ignoreProperties', decl.prop)) {\n        return;\n      }\n\n      valueParser(decl.value).walk(node => {\n        const value = node.value;\n        const type = node.type;\n        const sourceIndex = node.sourceIndex;\n\n        if (optionsMatches(options, 'ignore', 'inside-function') && type === 'function') {\n          return false;\n        }\n\n        if (!isStandardSyntaxFunction(node)) {\n          return false;\n        }\n\n        if (!isStandardSyntaxValue(value)) {\n          return;\n        } // Return early if neither a word nor a function\n\n\n        if (!NODE_TYPES.includes(type)) {\n          return;\n        } // Check for named colors for \"never\" option\n\n\n        if (expectation === 'never' && type === 'word' && namedColors.includes(value.toLowerCase())) {\n          complain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex);\n          return;\n        } // Check \"always-where-possible\" option ...\n\n\n        if (expectation !== 'always-where-possible') {\n          return;\n        } // First by checking for alternative color function representations ...\n\n\n        if (type === 'function' && keywordSets.colorFunctionNames.has(value.toLowerCase())) {\n          // Remove all spaces to match what's in `representations`\n          const normalizedFunctionString = valueParser.stringify(node).replace(/\\s+/g, '');\n          let namedColor;\n\n          for (let i = 0, l = namedColors.length; i < l; i++) {\n            namedColor = namedColors[i];\n\n            if (namedColorData[namedColor].func.includes(normalizedFunctionString.toLowerCase())) {\n              complain(messages.expected(namedColor, normalizedFunctionString), decl, declarationValueIndex(decl) + sourceIndex);\n              return; // Exit as soon as a problem is found\n            }\n          }\n\n          return;\n        } // Then by checking for alternative hex representations\n\n\n        let namedColor;\n\n        for (let i = 0, l = namedColors.length; i < l; i++) {\n          namedColor = namedColors[i];\n\n          if (namedColorData[namedColor].hex.includes(value.toLowerCase())) {\n            complain(messages.expected(namedColor, value), decl, declarationValueIndex(decl) + sourceIndex);\n            return; // Exit as soon as a problem is found\n          }\n        }\n      });\n    });\n\n    function complain(message, node, index) {\n      report({\n        result,\n        ruleName,\n        message,\n        node,\n        index\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/color-named/index.js"],"names":["_","require","declarationValueIndex","isStandardSyntaxFunction","isStandardSyntaxValue","keywordSets","namedColorDataHex","optionsMatches","propertySets","report","ruleMessages","validateOptions","valueParser","generateColorFuncs","ruleName","messages","expected","named","original","rejected","NODE_TYPES","rule","expectation","options","root","result","validOptions","actual","possible","ignoreProperties","isString","isRegExp","ignore","optional","namedColors","Object","keys","namedColorData","forEach","name","hex","func","walkDecls","decl","acceptCustomIdents","has","prop","value","walk","node","type","sourceIndex","includes","toLowerCase","complain","colorFunctionNames","normalizedFunctionString","stringify","replace","namedColor","i","l","length","message","index","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\nconst isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');\nconst keywordSets = require('../../reference/keywordSets');\nconst namedColorDataHex = require('../../reference/namedColorData');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst propertySets = require('../../reference/propertySets');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst generateColorFuncs = require('./generateColorFuncs');\n\nconst ruleName = 'color-named';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (named, original) => `Expected \"${original}\" to be \"${named}\"`,\n\trejected: (named) => `Unexpected named color \"${named}\"`,\n});\n\n// Todo tested on case insensivity\nconst NODE_TYPES = ['word', 'function'];\n\nfunction rule(expectation, options) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['never', 'always-where-possible'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignoreProperties: [_.isString, _.isRegExp],\n\t\t\t\t\tignore: ['inside-function'],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst namedColors = Object.keys(namedColorDataHex);\n\t\tconst namedColorData = {};\n\n\t\tnamedColors.forEach((name) => {\n\t\t\tconst hex = namedColorDataHex[name];\n\n\t\t\tnamedColorData[name] = {\n\t\t\t\thex,\n\t\t\t\tfunc: generateColorFuncs(hex[0]),\n\t\t\t};\n\t\t});\n\n\t\troot.walkDecls((decl) => {\n\t\t\tif (propertySets.acceptCustomIdents.has(decl.prop)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return early if the property is to be ignored\n\t\t\tif (optionsMatches(options, 'ignoreProperties', decl.prop)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalueParser(decl.value).walk((node) => {\n\t\t\t\tconst value = node.value;\n\t\t\t\tconst type = node.type;\n\t\t\t\tconst sourceIndex = node.sourceIndex;\n\n\t\t\t\tif (optionsMatches(options, 'ignore', 'inside-function') && type === 'function') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (!isStandardSyntaxFunction(node)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (!isStandardSyntaxValue(value)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Return early if neither a word nor a function\n\t\t\t\tif (!NODE_TYPES.includes(type)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check for named colors for \"never\" option\n\t\t\t\tif (\n\t\t\t\t\texpectation === 'never' &&\n\t\t\t\t\ttype === 'word' &&\n\t\t\t\t\tnamedColors.includes(value.toLowerCase())\n\t\t\t\t) {\n\t\t\t\t\tcomplain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check \"always-where-possible\" option ...\n\t\t\t\tif (expectation !== 'always-where-possible') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// First by checking for alternative color function representations ...\n\t\t\t\tif (type === 'function' && keywordSets.colorFunctionNames.has(value.toLowerCase())) {\n\t\t\t\t\t// Remove all spaces to match what's in `representations`\n\t\t\t\t\tconst normalizedFunctionString = valueParser.stringify(node).replace(/\\s+/g, '');\n\t\t\t\t\tlet namedColor;\n\n\t\t\t\t\tfor (let i = 0, l = namedColors.length; i < l; i++) {\n\t\t\t\t\t\tnamedColor = namedColors[i];\n\n\t\t\t\t\t\tif (namedColorData[namedColor].func.includes(normalizedFunctionString.toLowerCase())) {\n\t\t\t\t\t\t\tcomplain(\n\t\t\t\t\t\t\t\tmessages.expected(namedColor, normalizedFunctionString),\n\t\t\t\t\t\t\t\tdecl,\n\t\t\t\t\t\t\t\tdeclarationValueIndex(decl) + sourceIndex,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\treturn; // Exit as soon as a problem is found\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Then by checking for alternative hex representations\n\t\t\t\tlet namedColor;\n\n\t\t\t\tfor (let i = 0, l = namedColors.length; i < l; i++) {\n\t\t\t\t\tnamedColor = namedColors[i];\n\n\t\t\t\t\tif (namedColorData[namedColor].hex.includes(value.toLowerCase())) {\n\t\t\t\t\t\tcomplain(\n\t\t\t\t\t\t\tmessages.expected(namedColor, value),\n\t\t\t\t\t\t\tdecl,\n\t\t\t\t\t\t\tdeclarationValueIndex(decl) + sourceIndex,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn; // Exit as soon as a problem is found\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tfunction complain(message, node, index) {\n\t\t\treport({\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t\tmessage,\n\t\t\t\tnode,\n\t\t\t\tindex,\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}