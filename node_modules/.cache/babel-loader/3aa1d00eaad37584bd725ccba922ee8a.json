{"ast":null,"code":"'use strict';\n/** @typedef {import('postcss-value-parser').Node} ValueNode */\n\n/**\n * @param {ValueNode | undefined} valueNode\n * @returns {boolean}\n */\n\nmodule.exports = function (valueNode) {\n  if (!valueNode) {\n    return false;\n  }\n\n  if (valueNode.type !== 'function' || !valueNode.nodes || valueNode.value) {\n    return false;\n  } // It's necessary to remove comments and spaces if they are present\n\n\n  const cleanNodes = valueNode.nodes.filter(node => node.type !== 'comment' && node.type !== 'space'); // Map without comments and spaces will have the structure like $map (prop: value, prop2: value)\n  //                                                                     ↑  ↑   ↑  ↑\n  //                                                                     0  1   2  3\n\n  if (cleanNodes[0] && cleanNodes[0].type !== 'word' && cleanNodes[0].type !== 'string') {\n    return false;\n  }\n\n  if (cleanNodes[1] && cleanNodes[1].value !== ':') {\n    return false;\n  } // There is no need to check type or value of this node since it could be anything\n\n\n  if (!cleanNodes[2]) {\n    return false;\n  }\n\n  if (cleanNodes[3] && cleanNodes[3].value !== ',') {\n    return false;\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/isMap.js"],"names":["module","exports","valueNode","type","nodes","value","cleanNodes","filter","node"],"mappings":"AAAA;AAEA;;AAEA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,SAAV,EAAqB;AACrC,MAAI,CAACA,SAAL,EAAgB;AACf,WAAO,KAAP;AACA;;AAED,MAAIA,SAAS,CAACC,IAAV,KAAmB,UAAnB,IAAiC,CAACD,SAAS,CAACE,KAA5C,IAAqDF,SAAS,CAACG,KAAnE,EAA0E;AACzE,WAAO,KAAP;AACA,GAPoC,CASrC;;;AACA,QAAMC,UAAU,GAAGJ,SAAS,CAACE,KAAV,CAAgBG,MAAhB,CACjBC,IAAD,IAAUA,IAAI,CAACL,IAAL,KAAc,SAAd,IAA2BK,IAAI,CAACL,IAAL,KAAc,OADjC,CAAnB,CAVqC,CAcrC;AACA;AACA;;AACA,MAAIG,UAAU,CAAC,CAAD,CAAV,IAAiBA,UAAU,CAAC,CAAD,CAAV,CAAcH,IAAd,KAAuB,MAAxC,IAAkDG,UAAU,CAAC,CAAD,CAAV,CAAcH,IAAd,KAAuB,QAA7E,EAAuF;AACtF,WAAO,KAAP;AACA;;AAED,MAAIG,UAAU,CAAC,CAAD,CAAV,IAAiBA,UAAU,CAAC,CAAD,CAAV,CAAcD,KAAd,KAAwB,GAA7C,EAAkD;AACjD,WAAO,KAAP;AACA,GAvBoC,CAyBrC;;;AACA,MAAI,CAACC,UAAU,CAAC,CAAD,CAAf,EAAoB;AACnB,WAAO,KAAP;AACA;;AAED,MAAIA,UAAU,CAAC,CAAD,CAAV,IAAiBA,UAAU,CAAC,CAAD,CAAV,CAAcD,KAAd,KAAwB,GAA7C,EAAkD;AACjD,WAAO,KAAP;AACA;;AAED,SAAO,IAAP;AACA,CAnCD","sourcesContent":["'use strict';\n\n/** @typedef {import('postcss-value-parser').Node} ValueNode */\n\n/**\n * @param {ValueNode | undefined} valueNode\n * @returns {boolean}\n */\nmodule.exports = function (valueNode) {\n\tif (!valueNode) {\n\t\treturn false;\n\t}\n\n\tif (valueNode.type !== 'function' || !valueNode.nodes || valueNode.value) {\n\t\treturn false;\n\t}\n\n\t// It's necessary to remove comments and spaces if they are present\n\tconst cleanNodes = valueNode.nodes.filter(\n\t\t(node) => node.type !== 'comment' && node.type !== 'space',\n\t);\n\n\t// Map without comments and spaces will have the structure like $map (prop: value, prop2: value)\n\t//                                                                     ↑  ↑   ↑  ↑\n\t//                                                                     0  1   2  3\n\tif (cleanNodes[0] && cleanNodes[0].type !== 'word' && cleanNodes[0].type !== 'string') {\n\t\treturn false;\n\t}\n\n\tif (cleanNodes[1] && cleanNodes[1].value !== ':') {\n\t\treturn false;\n\t}\n\n\t// There is no need to check type or value of this node since it could be anything\n\tif (!cleanNodes[2]) {\n\t\treturn false;\n\t}\n\n\tif (cleanNodes[3] && cleanNodes[3].value !== ',') {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n"]},"metadata":{},"sourceType":"script"}