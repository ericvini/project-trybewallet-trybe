{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst blockString = require('../../utils/blockString');\n\nconst nextNonCommentNode = require('../../utils/nextNonCommentNode');\n\nconst rawNodeString = require('../../utils/rawNodeString');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'declaration-block-semicolon-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \";\"',\n  expectedAfterMultiLine: () => 'Expected newline after \";\" in a multi-line declaration block',\n  rejectedAfterMultiLine: () => 'Unexpected newline after \";\" in a multi-line declaration block'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      // Ignore last declaration if there's no trailing semicolon\n      const parentRule = decl.parent;\n\n      if (!parentRule.raws.semicolon && parentRule.last === decl) {\n        return;\n      }\n\n      const nextNode = decl.next();\n\n      if (!nextNode) {\n        return;\n      } // Allow end-of-line comment\n\n\n      const nodeToCheck = nextNonCommentNode(nextNode);\n\n      if (!nodeToCheck) {\n        return;\n      }\n\n      checker.afterOneOnly({\n        source: rawNodeString(nodeToCheck),\n        index: -1,\n        lineCheckStr: blockString(parentRule),\n        err: m => {\n          if (context.fix) {\n            if (expectation.startsWith('always')) {\n              const index = nodeToCheck.raws.before.search(/\\r?\\n/);\n\n              if (index >= 0) {\n                nodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);\n              } else {\n                nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n              }\n\n              return;\n            }\n\n            if (expectation === 'never-multi-line') {\n              nodeToCheck.raws.before = '';\n              return;\n            }\n          }\n\n          report({\n            message: m,\n            node: decl,\n            index: decl.toString().length + 1,\n            result,\n            ruleName\n          });\n        }\n      });\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/declaration-block-semicolon-newline-after/index.js"],"names":["blockString","require","nextNonCommentNode","rawNodeString","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","walkDecls","decl","parentRule","parent","raws","semicolon","last","nextNode","next","nodeToCheck","afterOneOnly","source","index","lineCheckStr","err","m","fix","startsWith","before","search","slice","newline","message","node","toString","length","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst blockString = require('../../utils/blockString');\nconst nextNonCommentNode = require('../../utils/nextNonCommentNode');\nconst rawNodeString = require('../../utils/rawNodeString');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'declaration-block-semicolon-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \";\"',\n\texpectedAfterMultiLine: () => 'Expected newline after \";\" in a multi-line declaration block',\n\trejectedAfterMultiLine: () => 'Unexpected newline after \";\" in a multi-line declaration block',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\t// Ignore last declaration if there's no trailing semicolon\n\t\t\tconst parentRule = decl.parent;\n\n\t\t\tif (!parentRule.raws.semicolon && parentRule.last === decl) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextNode = decl.next();\n\n\t\t\tif (!nextNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Allow end-of-line comment\n\t\t\tconst nodeToCheck = nextNonCommentNode(nextNode);\n\n\t\t\tif (!nodeToCheck) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchecker.afterOneOnly({\n\t\t\t\tsource: rawNodeString(nodeToCheck),\n\t\t\t\tindex: -1,\n\t\t\t\tlineCheckStr: blockString(parentRule),\n\t\t\t\terr: (m) => {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tconst index = nodeToCheck.raws.before.search(/\\r?\\n/);\n\n\t\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\t\tnodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expectation === 'never-multi-line') {\n\t\t\t\t\t\t\tnodeToCheck.raws.before = '';\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\tnode: decl,\n\t\t\t\t\t\tindex: decl.toString().length + 1,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}