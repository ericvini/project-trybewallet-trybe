{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n/** @typedef {import('stylelint').RangeType} RangeType */\n\n/** @typedef {import('stylelint').DisableReportRange} DisabledRange */\n\n/**\n * Returns a report describing which `results` (if any) contain disabled ranges\n * for rules that disallow disables via `reportDisables: true`.\n *\n * @param {import('stylelint').StylelintResult[]} results\n */\n\n\nmodule.exports = function (results) {\n  results.forEach(result => {\n    // File with `CssSyntaxError` don't have `_postcssResult`s.\n    if (!result._postcssResult) {\n      return;\n    }\n    /** @type {{[ruleName: string]: Array<RangeType>}} */\n\n\n    const rangeData = result._postcssResult.stylelint.disabledRanges;\n    if (!rangeData) return;\n    const config = result._postcssResult.stylelint.config; // If no rules actually disallow disables, don't bother looking for ranges\n    // that correspond to disabled rules.\n\n    if (!Object.values(_.get(config, 'rules', {})).some(reportDisablesForRule)) {\n      return [];\n    }\n\n    Object.keys(rangeData).forEach(rule => {\n      rangeData[rule].forEach(range => {\n        if (!reportDisablesForRule(_.get(config, ['rules', rule], []))) return; // If the comment doesn't have a location, we can't report a useful error.\n        // In practice we expect all comments to have locations, though.\n\n        if (!range.comment.source || !range.comment.source.start) return;\n        result.warnings.push({\n          text: `Rule \"${rule}\" may not be disabled`,\n          rule: 'reportDisables',\n          line: range.comment.source.start.line,\n          column: range.comment.source.start.column,\n          severity: 'error'\n        });\n      });\n    });\n  });\n};\n/**\n * @param {[any, object]|null} options\n * @return {boolean}\n */\n\n\nfunction reportDisablesForRule(options) {\n  if (!options) return false;\n  return _.get(options[1], 'reportDisables', false);\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/reportDisables.js"],"names":["_","require","module","exports","results","forEach","result","_postcssResult","rangeData","stylelint","disabledRanges","config","Object","values","get","some","reportDisablesForRule","keys","rule","range","comment","source","start","warnings","push","text","line","column","severity","options"],"mappings":"AAAA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,OAAV,EAAmB;AACnCA,EAAAA,OAAO,CAACC,OAAR,CAAiBC,MAAD,IAAY;AAC3B;AACA,QAAI,CAACA,MAAM,CAACC,cAAZ,EAA4B;AAC3B;AACA;AAED;;;AACA,UAAMC,SAAS,GAAGF,MAAM,CAACC,cAAP,CAAsBE,SAAtB,CAAgCC,cAAlD;AAEA,QAAI,CAACF,SAAL,EAAgB;AAEhB,UAAMG,MAAM,GAAGL,MAAM,CAACC,cAAP,CAAsBE,SAAtB,CAAgCE,MAA/C,CAX2B,CAa3B;AACA;;AACA,QAAI,CAACC,MAAM,CAACC,MAAP,CAAcb,CAAC,CAACc,GAAF,CAAMH,MAAN,EAAc,OAAd,EAAuB,EAAvB,CAAd,EAA0CI,IAA1C,CAA+CC,qBAA/C,CAAL,EAA4E;AAC3E,aAAO,EAAP;AACA;;AAEDJ,IAAAA,MAAM,CAACK,IAAP,CAAYT,SAAZ,EAAuBH,OAAvB,CAAgCa,IAAD,IAAU;AACxCV,MAAAA,SAAS,CAACU,IAAD,CAAT,CAAgBb,OAAhB,CAAyBc,KAAD,IAAW;AAClC,YAAI,CAACH,qBAAqB,CAAChB,CAAC,CAACc,GAAF,CAAMH,MAAN,EAAc,CAAC,OAAD,EAAUO,IAAV,CAAd,EAA+B,EAA/B,CAAD,CAA1B,EAAgE,OAD9B,CAGlC;AACA;;AACA,YAAI,CAACC,KAAK,CAACC,OAAN,CAAcC,MAAf,IAAyB,CAACF,KAAK,CAACC,OAAN,CAAcC,MAAd,CAAqBC,KAAnD,EAA0D;AAE1DhB,QAAAA,MAAM,CAACiB,QAAP,CAAgBC,IAAhB,CAAqB;AACpBC,UAAAA,IAAI,EAAG,SAAQP,IAAK,uBADA;AAEpBA,UAAAA,IAAI,EAAE,gBAFc;AAGpBQ,UAAAA,IAAI,EAAEP,KAAK,CAACC,OAAN,CAAcC,MAAd,CAAqBC,KAArB,CAA2BI,IAHb;AAIpBC,UAAAA,MAAM,EAAER,KAAK,CAACC,OAAN,CAAcC,MAAd,CAAqBC,KAArB,CAA2BK,MAJf;AAKpBC,UAAAA,QAAQ,EAAE;AALU,SAArB;AAOA,OAdD;AAeA,KAhBD;AAiBA,GApCD;AAqCA,CAtCD;AAwCA;AACA;AACA;AACA;;;AACA,SAASZ,qBAAT,CAA+Ba,OAA/B,EAAwC;AACvC,MAAI,CAACA,OAAL,EAAc,OAAO,KAAP;AAEd,SAAO7B,CAAC,CAACc,GAAF,CAAMe,OAAO,CAAC,CAAD,CAAb,EAAkB,gBAAlB,EAAoC,KAApC,CAAP;AACA","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\n/** @typedef {import('stylelint').RangeType} RangeType */\n/** @typedef {import('stylelint').DisableReportRange} DisabledRange */\n\n/**\n * Returns a report describing which `results` (if any) contain disabled ranges\n * for rules that disallow disables via `reportDisables: true`.\n *\n * @param {import('stylelint').StylelintResult[]} results\n */\nmodule.exports = function (results) {\n\tresults.forEach((result) => {\n\t\t// File with `CssSyntaxError` don't have `_postcssResult`s.\n\t\tif (!result._postcssResult) {\n\t\t\treturn;\n\t\t}\n\n\t\t/** @type {{[ruleName: string]: Array<RangeType>}} */\n\t\tconst rangeData = result._postcssResult.stylelint.disabledRanges;\n\n\t\tif (!rangeData) return;\n\n\t\tconst config = result._postcssResult.stylelint.config;\n\n\t\t// If no rules actually disallow disables, don't bother looking for ranges\n\t\t// that correspond to disabled rules.\n\t\tif (!Object.values(_.get(config, 'rules', {})).some(reportDisablesForRule)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tObject.keys(rangeData).forEach((rule) => {\n\t\t\trangeData[rule].forEach((range) => {\n\t\t\t\tif (!reportDisablesForRule(_.get(config, ['rules', rule], []))) return;\n\n\t\t\t\t// If the comment doesn't have a location, we can't report a useful error.\n\t\t\t\t// In practice we expect all comments to have locations, though.\n\t\t\t\tif (!range.comment.source || !range.comment.source.start) return;\n\n\t\t\t\tresult.warnings.push({\n\t\t\t\t\ttext: `Rule \"${rule}\" may not be disabled`,\n\t\t\t\t\trule: 'reportDisables',\n\t\t\t\t\tline: range.comment.source.start.line,\n\t\t\t\t\tcolumn: range.comment.source.start.column,\n\t\t\t\t\tseverity: 'error',\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n};\n\n/**\n * @param {[any, object]|null} options\n * @return {boolean}\n */\nfunction reportDisablesForRule(options) {\n\tif (!options) return false;\n\n\treturn _.get(options[1], 'reportDisables', false);\n}\n"]},"metadata":{},"sourceType":"script"}