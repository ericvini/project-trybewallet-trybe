{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst beforeBlockString = require('../../utils/beforeBlockString');\n\nconst blockString = require('../../utils/blockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\n\nconst rawNodeString = require('../../utils/rawNodeString');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-opening-brace-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \"{\"',\n  expectedAfterMultiLine: () => 'Expected newline after \"{\" of a multi-line block',\n  rejectedAfterMultiLine: () => 'Unexpected whitespace after \"{\" of a multi-line block'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    } // Check both kinds of statement: rules and at-rules\n\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      // Return early if blockless or has an empty block\n      if (!hasBlock(statement) || hasEmptyBlock(statement)) {\n        return;\n      }\n\n      const backupCommentNextBefores = new Map(); // next node with checking newlines after comment\n\n      function nextNode(startNode) {\n        if (!startNode || !startNode.next) return null;\n\n        if (startNode.type === 'comment') {\n          const reNewLine = /\\r?\\n/;\n          const newLineMatch = reNewLine.test(startNode.raws.before);\n          const next = startNode.next();\n\n          if (next && newLineMatch && !reNewLine.test(next.raws.before)) {\n            backupCommentNextBefores.set(next, next.raws.before);\n            next.raws.before = startNode.raws.before;\n          }\n\n          return nextNode(next);\n        }\n\n        return startNode;\n      } // Allow an end-of-line comment\n\n\n      const nodeToCheck = nextNode(statement.first);\n\n      if (!nodeToCheck) {\n        return;\n      }\n\n      checker.afterOneOnly({\n        source: rawNodeString(nodeToCheck),\n        index: -1,\n        lineCheckStr: blockString(statement),\n        err: m => {\n          if (context.fix) {\n            if (expectation.startsWith('always')) {\n              const index = nodeToCheck.raws.before.search(/\\r?\\n/);\n\n              if (index >= 0) {\n                nodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);\n              } else {\n                nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n              }\n\n              backupCommentNextBefores.delete(nodeToCheck);\n              return;\n            }\n\n            if (expectation === 'never-multi-line') {\n              // Restore the `before` of the node next to the comment node.\n              backupCommentNextBefores.forEach((before, node) => {\n                node.raws.before = before;\n              });\n              backupCommentNextBefores.clear(); // Fix\n\n              const reNewLine = /\\r?\\n/;\n              let fixTarget = statement.first;\n\n              while (fixTarget) {\n                if (reNewLine.test(fixTarget.raws.before)) {\n                  fixTarget.raws.before = fixTarget.raws.before.replace(/\\r?\\n/g, '');\n                }\n\n                if (fixTarget.type !== 'comment') {\n                  break;\n                }\n\n                fixTarget = fixTarget.next();\n              }\n\n              nodeToCheck.raws.before = '';\n              return;\n            }\n          }\n\n          report({\n            message: m,\n            node: statement,\n            index: beforeBlockString(statement, {\n              noRawBefore: true\n            }).length + 1,\n            result,\n            ruleName\n          });\n        }\n      }); // Restore the `before` of the node next to the comment node.\n\n      backupCommentNextBefores.forEach((before, node) => {\n        node.raws.before = before;\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-opening-brace-newline-after/index.js"],"names":["beforeBlockString","require","blockString","hasBlock","hasEmptyBlock","rawNodeString","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","walkRules","check","walkAtRules","statement","backupCommentNextBefores","Map","nextNode","startNode","next","type","reNewLine","newLineMatch","test","raws","before","set","nodeToCheck","first","afterOneOnly","source","index","lineCheckStr","err","m","fix","startsWith","search","slice","newline","delete","forEach","node","clear","fixTarget","replace","message","noRawBefore","length","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst beforeBlockString = require('../../utils/beforeBlockString');\nconst blockString = require('../../utils/blockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\nconst rawNodeString = require('../../utils/rawNodeString');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-opening-brace-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \"{\"',\n\texpectedAfterMultiLine: () => 'Expected newline after \"{\" of a multi-line block',\n\trejectedAfterMultiLine: () => 'Unexpected whitespace after \"{\" of a multi-line block',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check both kinds of statement: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\t// Return early if blockless or has an empty block\n\t\t\tif (!hasBlock(statement) || hasEmptyBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst backupCommentNextBefores = new Map();\n\n\t\t\t// next node with checking newlines after comment\n\t\t\tfunction nextNode(startNode) {\n\t\t\t\tif (!startNode || !startNode.next) return null;\n\n\t\t\t\tif (startNode.type === 'comment') {\n\t\t\t\t\tconst reNewLine = /\\r?\\n/;\n\t\t\t\t\tconst newLineMatch = reNewLine.test(startNode.raws.before);\n\n\t\t\t\t\tconst next = startNode.next();\n\n\t\t\t\t\tif (next && newLineMatch && !reNewLine.test(next.raws.before)) {\n\t\t\t\t\t\tbackupCommentNextBefores.set(next, next.raws.before);\n\t\t\t\t\t\tnext.raws.before = startNode.raws.before;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nextNode(next);\n\t\t\t\t}\n\n\t\t\t\treturn startNode;\n\t\t\t}\n\n\t\t\t// Allow an end-of-line comment\n\t\t\tconst nodeToCheck = nextNode(statement.first);\n\n\t\t\tif (!nodeToCheck) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchecker.afterOneOnly({\n\t\t\t\tsource: rawNodeString(nodeToCheck),\n\t\t\t\tindex: -1,\n\t\t\t\tlineCheckStr: blockString(statement),\n\t\t\t\terr: (m) => {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tconst index = nodeToCheck.raws.before.search(/\\r?\\n/);\n\n\t\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\t\tnodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbackupCommentNextBefores.delete(nodeToCheck);\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expectation === 'never-multi-line') {\n\t\t\t\t\t\t\t// Restore the `before` of the node next to the comment node.\n\t\t\t\t\t\t\tbackupCommentNextBefores.forEach((before, node) => {\n\t\t\t\t\t\t\t\tnode.raws.before = before;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbackupCommentNextBefores.clear();\n\n\t\t\t\t\t\t\t// Fix\n\t\t\t\t\t\t\tconst reNewLine = /\\r?\\n/;\n\t\t\t\t\t\t\tlet fixTarget = statement.first;\n\n\t\t\t\t\t\t\twhile (fixTarget) {\n\t\t\t\t\t\t\t\tif (reNewLine.test(fixTarget.raws.before)) {\n\t\t\t\t\t\t\t\t\tfixTarget.raws.before = fixTarget.raws.before.replace(/\\r?\\n/g, '');\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (fixTarget.type !== 'comment') {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfixTarget = fixTarget.next();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnodeToCheck.raws.before = '';\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\tnode: statement,\n\t\t\t\t\t\tindex: beforeBlockString(statement, { noRawBefore: true }).length + 1,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Restore the `before` of the node next to the comment node.\n\t\t\tbackupCommentNextBefores.forEach((before, node) => {\n\t\t\t\tnode.raws.before = before;\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}