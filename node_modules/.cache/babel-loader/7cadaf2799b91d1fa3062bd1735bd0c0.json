{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst parseSelector = require('../../utils/parseSelector');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-pseudo-class-parentheses-space-inside';\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: 'Expected single space after \"(\"',\n  rejectedOpening: 'Unexpected whitespace after \"(\"',\n  expectedClosing: 'Expected single space before \")\"',\n  rejectedClosing: 'Unexpected whitespace before \")\"'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    });\n\n    if (!validOptions) {\n      return;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      }\n\n      if (!rule.selector.includes('(')) {\n        return;\n      }\n\n      let hasFixed = false;\n      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n      const fixedSelector = parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          if (!pseudoNode.length) {\n            return;\n          }\n\n          const paramString = pseudoNode.map(String).join(',');\n          const nextCharIsSpace = paramString.startsWith(' ');\n          const openIndex = pseudoNode.sourceIndex + stringifyProperty(pseudoNode, 'value').length + 1;\n\n          if (nextCharIsSpace && expectation === 'never') {\n            if (context.fix) {\n              hasFixed = true;\n              setFirstNodeSpaceBefore(pseudoNode, '');\n            } else {\n              complain(messages.rejectedOpening, openIndex);\n            }\n          }\n\n          if (!nextCharIsSpace && expectation === 'always') {\n            if (context.fix) {\n              hasFixed = true;\n              setFirstNodeSpaceBefore(pseudoNode, ' ');\n            } else {\n              complain(messages.expectedOpening, openIndex);\n            }\n          }\n\n          const prevCharIsSpace = paramString.endsWith(' ');\n          const closeIndex = openIndex + paramString.length - 1;\n\n          if (prevCharIsSpace && expectation === 'never') {\n            if (context.fix) {\n              hasFixed = true;\n              setLastNodeSpaceAfter(pseudoNode, '');\n            } else {\n              complain(messages.rejectedClosing, closeIndex);\n            }\n          }\n\n          if (!prevCharIsSpace && expectation === 'always') {\n            if (context.fix) {\n              hasFixed = true;\n              setLastNodeSpaceAfter(pseudoNode, ' ');\n            } else {\n              complain(messages.expectedClosing, closeIndex);\n            }\n          }\n        });\n      });\n\n      if (hasFixed) {\n        if (!rule.raws.selector) {\n          rule.selector = fixedSelector;\n        } else {\n          rule.raws.selector.raw = fixedSelector;\n        }\n      }\n\n      function complain(message, index) {\n        report({\n          message,\n          index,\n          result,\n          ruleName,\n          node: rule\n        });\n      }\n    });\n  };\n}\n\nfunction setFirstNodeSpaceBefore(node, value) {\n  const target = node.first;\n\n  if (target.type === 'selector') {\n    setFirstNodeSpaceBefore(target, value);\n  } else {\n    target.spaces.before = value;\n  }\n}\n\nfunction setLastNodeSpaceAfter(node, value) {\n  const target = node.last;\n\n  if (target.type === 'selector') {\n    setLastNodeSpaceAfter(target, value);\n  } else {\n    target.spaces.after = value;\n  }\n}\n\nfunction stringifyProperty(node, propName) {\n  return node.raws && node.raws[propName] || node[propName];\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-pseudo-class-parentheses-space-inside/index.js"],"names":["isStandardSyntaxRule","require","parseSelector","report","ruleMessages","validateOptions","ruleName","messages","expectedOpening","rejectedOpening","expectedClosing","rejectedClosing","rule","expectation","options","context","root","result","validOptions","actual","possible","walkRules","selector","includes","hasFixed","raws","raw","fixedSelector","selectorTree","walkPseudos","pseudoNode","length","paramString","map","String","join","nextCharIsSpace","startsWith","openIndex","sourceIndex","stringifyProperty","fix","setFirstNodeSpaceBefore","complain","prevCharIsSpace","endsWith","closeIndex","setLastNodeSpaceAfter","message","index","node","value","target","first","type","spaces","before","last","after","propName","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst parseSelector = require('../../utils/parseSelector');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-pseudo-class-parentheses-space-inside';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedOpening: 'Expected single space after \"(\"',\n\trejectedOpening: 'Unexpected whitespace after \"(\"',\n\texpectedClosing: 'Expected single space before \")\"',\n\trejectedClosing: 'Unexpected whitespace before \")\"',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!rule.selector.includes('(')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet hasFixed = false;\n\t\t\tconst selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\t\t\tconst fixedSelector = parseSelector(selector, result, rule, (selectorTree) => {\n\t\t\t\tselectorTree.walkPseudos((pseudoNode) => {\n\t\t\t\t\tif (!pseudoNode.length) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst paramString = pseudoNode.map(String).join(',');\n\t\t\t\t\tconst nextCharIsSpace = paramString.startsWith(' ');\n\t\t\t\t\tconst openIndex =\n\t\t\t\t\t\tpseudoNode.sourceIndex + stringifyProperty(pseudoNode, 'value').length + 1;\n\n\t\t\t\t\tif (nextCharIsSpace && expectation === 'never') {\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\tsetFirstNodeSpaceBefore(pseudoNode, '');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomplain(messages.rejectedOpening, openIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextCharIsSpace && expectation === 'always') {\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\tsetFirstNodeSpaceBefore(pseudoNode, ' ');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomplain(messages.expectedOpening, openIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst prevCharIsSpace = paramString.endsWith(' ');\n\t\t\t\t\tconst closeIndex = openIndex + paramString.length - 1;\n\n\t\t\t\t\tif (prevCharIsSpace && expectation === 'never') {\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\tsetLastNodeSpaceAfter(pseudoNode, '');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomplain(messages.rejectedClosing, closeIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!prevCharIsSpace && expectation === 'always') {\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\tsetLastNodeSpaceAfter(pseudoNode, ' ');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomplain(messages.expectedClosing, closeIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (hasFixed) {\n\t\t\t\tif (!rule.raws.selector) {\n\t\t\t\t\trule.selector = fixedSelector;\n\t\t\t\t} else {\n\t\t\t\t\trule.raws.selector.raw = fixedSelector;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction complain(message, index) {\n\t\t\t\treport({\n\t\t\t\t\tmessage,\n\t\t\t\t\tindex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t\tnode: rule,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction setFirstNodeSpaceBefore(node, value) {\n\tconst target = node.first;\n\n\tif (target.type === 'selector') {\n\t\tsetFirstNodeSpaceBefore(target, value);\n\t} else {\n\t\ttarget.spaces.before = value;\n\t}\n}\n\nfunction setLastNodeSpaceAfter(node, value) {\n\tconst target = node.last;\n\n\tif (target.type === 'selector') {\n\t\tsetLastNodeSpaceAfter(target, value);\n\t} else {\n\t\ttarget.spaces.after = value;\n\t}\n}\n\nfunction stringifyProperty(node, propName) {\n\treturn (node.raws && node.raws[propName]) || node[propName];\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}