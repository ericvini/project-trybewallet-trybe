{"ast":null,"code":"'use strict';\n\nconst autoprefixer = require('autoprefixer');\n\nconst Browsers = require('autoprefixer/lib/browsers');\n\nconst Prefixes = require('autoprefixer/lib/prefixes');\n/**\n * Use Autoprefixer's secret powers to determine whether or\n * not a certain CSS identifier contains a vendor prefix that\n * Autoprefixer, given the standardized identifier, could add itself.\n *\n * Used by `*-no-vendor-prefix-*` rules to find superfluous\n * vendor prefixes.\n */\n\n\nconst prefixes = new Prefixes(autoprefixer.data.prefixes, new Browsers(autoprefixer.data.browsers, []));\n/**\n * Most identifier types have to be looked up in a unique way,\n * so we're exposing special functions for each.\n */\n\nmodule.exports = {\n  /**\n   * @param {string} identifier\n   * @returns {boolean}\n   */\n  atRuleName(identifier) {\n    return Boolean(prefixes.remove[`@${identifier.toLowerCase()}`]);\n  },\n\n  /**\n   * @param {string} identifier\n   * @returns {boolean}\n   */\n  selector(identifier) {\n    return prefixes.remove.selectors.some(\n    /** @type {{ prefixed: string}} */\n    selectorObj => {\n      return identifier.toLowerCase() === selectorObj.prefixed;\n    });\n  },\n\n  /**\n   * @param {string} identifier\n   * @returns {boolean}\n   */\n  mediaFeatureName(identifier) {\n    return identifier.toLowerCase().includes('device-pixel-ratio');\n  },\n\n  /**\n   * @param {string} identifier\n   * @returns {boolean}\n   */\n  property(identifier) {\n    return Boolean(autoprefixer.data.prefixes[prefixes.unprefixed(identifier.toLowerCase())]);\n  },\n\n  /**\n   *\n   * @param {string} prop\n   * @param {string} value\n   * @returns {boolean}\n   */\n  propertyValue(prop, value) {\n    const possiblePrefixableValues = prefixes.remove[prop.toLowerCase()] && prefixes.remove[prop.toLowerCase()].values || false;\n    return possiblePrefixableValues && possiblePrefixableValues.some(\n    /** @type {{ prefixed: string}} */\n    valueObj => {\n      return value.toLowerCase() === valueObj.prefixed;\n    });\n  },\n\n  /**\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  unprefix(value) {\n    return value.replace(/-\\w+-/, '');\n  }\n\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/isAutoprefixable.js"],"names":["autoprefixer","require","Browsers","Prefixes","prefixes","data","browsers","module","exports","atRuleName","identifier","Boolean","remove","toLowerCase","selector","selectors","some","selectorObj","prefixed","mediaFeatureName","includes","property","unprefixed","propertyValue","prop","value","possiblePrefixableValues","values","valueObj","unprefix","replace"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,2BAAD,CAAxB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,2BAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMG,QAAQ,GAAG,IAAID,QAAJ,CAChBH,YAAY,CAACK,IAAb,CAAkBD,QADF,EAEhB,IAAIF,QAAJ,CAAaF,YAAY,CAACK,IAAb,CAAkBC,QAA/B,EAAyC,EAAzC,CAFgB,CAAjB;AAKA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB;AAChB;AACD;AACA;AACA;AACCC,EAAAA,UAAU,CAACC,UAAD,EAAa;AACtB,WAAOC,OAAO,CAACP,QAAQ,CAACQ,MAAT,CAAiB,IAAGF,UAAU,CAACG,WAAX,EAAyB,EAA7C,CAAD,CAAd;AACA,GAPe;;AAShB;AACD;AACA;AACA;AACCC,EAAAA,QAAQ,CAACJ,UAAD,EAAa;AACpB,WAAON,QAAQ,CAACQ,MAAT,CAAgBG,SAAhB,CAA0BC,IAA1B;AAAgC;AAAmCC,IAAAA,WAApC,IAAoD;AACzF,aAAOP,UAAU,CAACG,WAAX,OAA6BI,WAAW,CAACC,QAAhD;AACA,KAFM,CAAP;AAGA,GAjBe;;AAmBhB;AACD;AACA;AACA;AACCC,EAAAA,gBAAgB,CAACT,UAAD,EAAa;AAC5B,WAAOA,UAAU,CAACG,WAAX,GAAyBO,QAAzB,CAAkC,oBAAlC,CAAP;AACA,GAzBe;;AA2BhB;AACD;AACA;AACA;AACCC,EAAAA,QAAQ,CAACX,UAAD,EAAa;AACpB,WAAOC,OAAO,CAACX,YAAY,CAACK,IAAb,CAAkBD,QAAlB,CAA2BA,QAAQ,CAACkB,UAAT,CAAoBZ,UAAU,CAACG,WAAX,EAApB,CAA3B,CAAD,CAAd;AACA,GAjCe;;AAmChB;AACD;AACA;AACA;AACA;AACA;AACCU,EAAAA,aAAa,CAACC,IAAD,EAAOC,KAAP,EAAc;AAC1B,UAAMC,wBAAwB,GAC5BtB,QAAQ,CAACQ,MAAT,CAAgBY,IAAI,CAACX,WAAL,EAAhB,KAAuCT,QAAQ,CAACQ,MAAT,CAAgBY,IAAI,CAACX,WAAL,EAAhB,EAAoCc,MAA5E,IAAuF,KADxF;AAGA,WACCD,wBAAwB,IACxBA,wBAAwB,CAACV,IAAzB;AAA+B;AAAmCY,IAAAA,QAApC,IAAiD;AAC9E,aAAOH,KAAK,CAACZ,WAAN,OAAwBe,QAAQ,CAACV,QAAxC;AACA,KAFD,CAFD;AAMA,GAnDe;;AAqDhB;AACD;AACA;AACA;AACA;AACCW,EAAAA,QAAQ,CAACJ,KAAD,EAAQ;AACf,WAAOA,KAAK,CAACK,OAAN,CAAc,OAAd,EAAuB,EAAvB,CAAP;AACA;;AA5De,CAAjB","sourcesContent":["'use strict';\n\nconst autoprefixer = require('autoprefixer');\nconst Browsers = require('autoprefixer/lib/browsers');\nconst Prefixes = require('autoprefixer/lib/prefixes');\n\n/**\n * Use Autoprefixer's secret powers to determine whether or\n * not a certain CSS identifier contains a vendor prefix that\n * Autoprefixer, given the standardized identifier, could add itself.\n *\n * Used by `*-no-vendor-prefix-*` rules to find superfluous\n * vendor prefixes.\n */\n\nconst prefixes = new Prefixes(\n\tautoprefixer.data.prefixes,\n\tnew Browsers(autoprefixer.data.browsers, []),\n);\n\n/**\n * Most identifier types have to be looked up in a unique way,\n * so we're exposing special functions for each.\n */\nmodule.exports = {\n\t/**\n\t * @param {string} identifier\n\t * @returns {boolean}\n\t */\n\tatRuleName(identifier) {\n\t\treturn Boolean(prefixes.remove[`@${identifier.toLowerCase()}`]);\n\t},\n\n\t/**\n\t * @param {string} identifier\n\t * @returns {boolean}\n\t */\n\tselector(identifier) {\n\t\treturn prefixes.remove.selectors.some((/** @type {{ prefixed: string}} */ selectorObj) => {\n\t\t\treturn identifier.toLowerCase() === selectorObj.prefixed;\n\t\t});\n\t},\n\n\t/**\n\t * @param {string} identifier\n\t * @returns {boolean}\n\t */\n\tmediaFeatureName(identifier) {\n\t\treturn identifier.toLowerCase().includes('device-pixel-ratio');\n\t},\n\n\t/**\n\t * @param {string} identifier\n\t * @returns {boolean}\n\t */\n\tproperty(identifier) {\n\t\treturn Boolean(autoprefixer.data.prefixes[prefixes.unprefixed(identifier.toLowerCase())]);\n\t},\n\n\t/**\n\t *\n\t * @param {string} prop\n\t * @param {string} value\n\t * @returns {boolean}\n\t */\n\tpropertyValue(prop, value) {\n\t\tconst possiblePrefixableValues =\n\t\t\t(prefixes.remove[prop.toLowerCase()] && prefixes.remove[prop.toLowerCase()].values) || false;\n\n\t\treturn (\n\t\t\tpossiblePrefixableValues &&\n\t\t\tpossiblePrefixableValues.some((/** @type {{ prefixed: string}} */ valueObj) => {\n\t\t\t\treturn value.toLowerCase() === valueObj.prefixed;\n\t\t\t})\n\t\t);\n\t},\n\n\t/**\n\t *\n\t * @param {string} value\n\t * @returns {string}\n\t */\n\tunprefix(value) {\n\t\treturn value.replace(/-\\w+-/, '');\n\t},\n};\n"]},"metadata":{},"sourceType":"script"}