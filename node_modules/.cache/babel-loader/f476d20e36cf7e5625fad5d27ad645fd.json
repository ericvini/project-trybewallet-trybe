{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst addEmptyLineAfter = require('../../utils/addEmptyLineAfter');\n\nconst blockString = require('../../utils/blockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\n\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst removeEmptyLineAfter = require('../../utils/removeEmptyLinesAfter');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'block-closing-brace-empty-line-before';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected empty line before closing brace',\n  rejected: 'Unexpected empty line before closing brace'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always-multi-line', 'never']\n    }, {\n      actual: options,\n      possible: {\n        except: ['after-closing-brace']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    } // Check both kinds of statements: rules and at-rules\n\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      // Return early if blockless or has empty block\n      if (!hasBlock(statement) || hasEmptyBlock(statement)) {\n        return;\n      } // Get whitespace after \"\"}\", ignoring extra semicolon\n\n\n      const before = (statement.raws.after || '').replace(/;+/, ''); // Calculate index\n\n      const statementString = statement.toString();\n      let index = statementString.length - 1;\n\n      if (statementString[index - 1] === '\\r') {\n        index -= 1;\n      } // Set expectation\n\n\n      const expectEmptyLineBefore = (() => {\n        const childNodeTypes = statement.nodes.map(item => item.type); // Reverse the primary options if `after-closing-brace` is set\n\n        if (optionsMatches(options, 'except', 'after-closing-brace') && statement.type === 'atrule' && !childNodeTypes.includes('decl')) {\n          return expectation === 'never';\n        }\n\n        return Boolean(expectation === 'always-multi-line' && !isSingleLineString(blockString(statement)));\n      })(); // Check for at least one empty line\n\n\n      const hasEmptyLineBefore = hasEmptyLine(before); // Return if the expectation is met\n\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      }\n\n      if (context.fix) {\n        if (expectEmptyLineBefore) {\n          addEmptyLineAfter(statement, context.newline);\n        } else {\n          removeEmptyLineAfter(statement, context.newline);\n        }\n\n        return;\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n      report({\n        message,\n        result,\n        ruleName,\n        node: statement,\n        index\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-closing-brace-empty-line-before/index.js"],"names":["addEmptyLineAfter","require","blockString","hasBlock","hasEmptyBlock","hasEmptyLine","isSingleLineString","optionsMatches","removeEmptyLineAfter","report","ruleMessages","validateOptions","ruleName","messages","expected","rejected","rule","expectation","options","context","root","result","validOptions","actual","possible","except","optional","walkRules","check","walkAtRules","statement","before","raws","after","replace","statementString","toString","index","length","expectEmptyLineBefore","childNodeTypes","nodes","map","item","type","includes","Boolean","hasEmptyLineBefore","fix","newline","message","node","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst addEmptyLineAfter = require('../../utils/addEmptyLineAfter');\nconst blockString = require('../../utils/blockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst removeEmptyLineAfter = require('../../utils/removeEmptyLinesAfter');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'block-closing-brace-empty-line-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected empty line before closing brace',\n\trejected: 'Unexpected empty line before closing brace',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['always-multi-line', 'never'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\texcept: ['after-closing-brace'],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check both kinds of statements: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\t// Return early if blockless or has empty block\n\t\t\tif (!hasBlock(statement) || hasEmptyBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get whitespace after \"\"}\", ignoring extra semicolon\n\t\t\tconst before = (statement.raws.after || '').replace(/;+/, '');\n\n\t\t\t// Calculate index\n\t\t\tconst statementString = statement.toString();\n\t\t\tlet index = statementString.length - 1;\n\n\t\t\tif (statementString[index - 1] === '\\r') {\n\t\t\t\tindex -= 1;\n\t\t\t}\n\n\t\t\t// Set expectation\n\t\t\tconst expectEmptyLineBefore = (() => {\n\t\t\t\tconst childNodeTypes = statement.nodes.map((item) => item.type);\n\n\t\t\t\t// Reverse the primary options if `after-closing-brace` is set\n\t\t\t\tif (\n\t\t\t\t\toptionsMatches(options, 'except', 'after-closing-brace') &&\n\t\t\t\t\tstatement.type === 'atrule' &&\n\t\t\t\t\t!childNodeTypes.includes('decl')\n\t\t\t\t) {\n\t\t\t\t\treturn expectation === 'never';\n\t\t\t\t}\n\n\t\t\t\treturn Boolean(\n\t\t\t\t\texpectation === 'always-multi-line' && !isSingleLineString(blockString(statement)),\n\t\t\t\t);\n\t\t\t})();\n\n\t\t\t// Check for at least one empty line\n\t\t\tconst hasEmptyLineBefore = hasEmptyLine(before);\n\n\t\t\t// Return if the expectation is met\n\t\t\tif (expectEmptyLineBefore === hasEmptyLineBefore) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (context.fix) {\n\t\t\t\tif (expectEmptyLineBefore) {\n\t\t\t\t\taddEmptyLineAfter(statement, context.newline);\n\t\t\t\t} else {\n\t\t\t\t\tremoveEmptyLineAfter(statement, context.newline);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n\t\t\treport({\n\t\t\t\tmessage,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t\tnode: statement,\n\t\t\t\tindex,\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}