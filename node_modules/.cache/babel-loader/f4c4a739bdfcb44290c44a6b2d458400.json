{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst keywordSets = require('../../reference/keywordSets');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-pseudo-element-colon-notation';\nconst messages = ruleMessages(ruleName, {\n  expected: q => `Expected ${q} colon pseudo-element notation`\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['single', 'double']\n    });\n\n    if (!validOptions) {\n      return;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      }\n\n      const selector = rule.selector; // get out early if no pseudo elements or classes\n\n      if (!selector.includes(':')) {\n        return;\n      }\n\n      const fixPositions = []; // match only level 1 and 2 pseudo elements\n\n      const pseudoElementsWithColons = Array.from(keywordSets.levelOneAndTwoPseudoElements).map(x => `:${x}`);\n      styleSearch({\n        source: selector.toLowerCase(),\n        target: pseudoElementsWithColons\n      }, match => {\n        const prevCharIsColon = selector[match.startIndex - 1] === ':';\n\n        if (expectation === 'single' && !prevCharIsColon) {\n          return;\n        }\n\n        if (expectation === 'double' && prevCharIsColon) {\n          return;\n        }\n\n        if (context.fix) {\n          fixPositions.unshift({\n            rule,\n            startIndex: match.startIndex\n          });\n          return;\n        }\n\n        report({\n          message: messages.expected(expectation),\n          node: rule,\n          index: match.startIndex,\n          result,\n          ruleName\n        });\n      });\n\n      if (fixPositions.length) {\n        // If expecting : then we found :: so remove one of the colons\n        // If expecting :: then we found : so add one extra colon\n        const expectedSingle = expectation === 'single';\n        const offset = expectedSingle ? 1 : 0;\n        const extraColon = expectedSingle ? '' : ':';\n        fixPositions.forEach(fixPosition => {\n          rule.selector = rule.selector.substring(0, fixPosition.startIndex - offset) + extraColon + rule.selector.substring(fixPosition.startIndex);\n        });\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-pseudo-element-colon-notation/index.js"],"names":["isStandardSyntaxRule","require","keywordSets","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","expected","q","rule","expectation","options","context","root","result","validOptions","actual","possible","walkRules","selector","includes","fixPositions","pseudoElementsWithColons","Array","from","levelOneAndTwoPseudoElements","map","x","source","toLowerCase","target","match","prevCharIsColon","startIndex","fix","unshift","message","node","index","length","expectedSingle","offset","extraColon","forEach","fixPosition","substring","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst keywordSets = require('../../reference/keywordSets');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-pseudo-element-colon-notation';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (q) => `Expected ${q} colon pseudo-element notation`,\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['single', 'double'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selector = rule.selector;\n\n\t\t\t// get out early if no pseudo elements or classes\n\t\t\tif (!selector.includes(':')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fixPositions = [];\n\n\t\t\t// match only level 1 and 2 pseudo elements\n\t\t\tconst pseudoElementsWithColons = Array.from(keywordSets.levelOneAndTwoPseudoElements).map(\n\t\t\t\t(x) => `:${x}`,\n\t\t\t);\n\n\t\t\tstyleSearch({ source: selector.toLowerCase(), target: pseudoElementsWithColons }, (match) => {\n\t\t\t\tconst prevCharIsColon = selector[match.startIndex - 1] === ':';\n\n\t\t\t\tif (expectation === 'single' && !prevCharIsColon) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (expectation === 'double' && prevCharIsColon) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tfixPositions.unshift({ rule, startIndex: match.startIndex });\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(expectation),\n\t\t\t\t\tnode: rule,\n\t\t\t\t\tindex: match.startIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (fixPositions.length) {\n\t\t\t\t// If expecting : then we found :: so remove one of the colons\n\t\t\t\t// If expecting :: then we found : so add one extra colon\n\t\t\t\tconst expectedSingle = expectation === 'single';\n\t\t\t\tconst offset = expectedSingle ? 1 : 0;\n\t\t\t\tconst extraColon = expectedSingle ? '' : ':';\n\n\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\trule.selector =\n\t\t\t\t\t\trule.selector.substring(0, fixPosition.startIndex - offset) +\n\t\t\t\t\t\textraColon +\n\t\t\t\t\t\trule.selector.substring(fixPosition.startIndex);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}