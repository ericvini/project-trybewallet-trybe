{"ast":null,"code":"'use strict';\n\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\n\nconst astralRegex = require('astral-regex');\n\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = ['\\u001B', '\\u009B'];\n\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\n\nconst checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {\n  let output = [];\n  ansiCodes = [...ansiCodes];\n\n  for (let ansiCode of ansiCodes) {\n    const ansiCodeOrigin = ansiCode;\n\n    if (ansiCode.includes(';')) {\n      ansiCode = ansiCode.split(';')[0][0] + '0';\n    }\n\n    const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));\n\n    if (item) {\n      const indexEscape = ansiCodes.indexOf(item.toString());\n\n      if (indexEscape === -1) {\n        output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));\n      } else {\n        ansiCodes.splice(indexEscape, 1);\n      }\n    } else if (isEscapes) {\n      output.push(wrapAnsi(0));\n      break;\n    } else {\n      output.push(wrapAnsi(ansiCodeOrigin));\n    }\n  }\n\n  if (isEscapes) {\n    output = output.filter((element, index) => output.indexOf(element) === index);\n\n    if (endAnsiCode !== undefined) {\n      const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));\n      output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);\n    }\n  }\n\n  return output.join('');\n};\n\nmodule.exports = (string, begin, end) => {\n  const characters = [...string];\n  const ansiCodes = [];\n  let stringEnd = typeof end === 'number' ? end : characters.length;\n  let isInsideEscape = false;\n  let ansiCode;\n  let visible = 0;\n  let output = '';\n\n  for (const [index, character] of characters.entries()) {\n    let leftEscape = false;\n\n    if (ESCAPES.includes(character)) {\n      const code = /\\d[^m]*/.exec(string.slice(index, index + 18));\n      ansiCode = code && code.length > 0 ? code[0] : undefined;\n\n      if (visible < stringEnd) {\n        isInsideEscape = true;\n\n        if (ansiCode !== undefined) {\n          ansiCodes.push(ansiCode);\n        }\n      }\n    } else if (isInsideEscape && character === 'm') {\n      isInsideEscape = false;\n      leftEscape = true;\n    }\n\n    if (!isInsideEscape && !leftEscape) {\n      visible++;\n    }\n\n    if (!astralRegex({\n      exact: true\n    }).test(character) && isFullwidthCodePoint(character.codePointAt())) {\n      visible++;\n\n      if (typeof end !== 'number') {\n        stringEnd++;\n      }\n    }\n\n    if (visible > begin && visible <= stringEnd) {\n      output += character;\n    } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {\n      output = checkAnsi(ansiCodes);\n    } else if (visible >= stringEnd) {\n      output += checkAnsi(ansiCodes, true, ansiCode);\n      break;\n    }\n  }\n\n  return output;\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/node_modules/slice-ansi/index.js"],"names":["isFullwidthCodePoint","require","astralRegex","ansiStyles","ESCAPES","wrapAnsi","code","checkAnsi","ansiCodes","isEscapes","endAnsiCode","output","ansiCode","ansiCodeOrigin","includes","split","item","codes","get","Number","parseInt","indexEscape","indexOf","toString","push","splice","filter","element","index","undefined","fistEscapeCode","reduce","current","next","join","module","exports","string","begin","end","characters","stringEnd","length","isInsideEscape","visible","character","entries","leftEscape","exec","slice","exact","test","codePointAt"],"mappings":"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","sourcesContent":["'use strict';\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst astralRegex = require('astral-regex');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = [\n\t'\\u001B',\n\t'\\u009B'\n];\n\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\n\nconst checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {\n\tlet output = [];\n\tansiCodes = [...ansiCodes];\n\n\tfor (let ansiCode of ansiCodes) {\n\t\tconst ansiCodeOrigin = ansiCode;\n\t\tif (ansiCode.includes(';')) {\n\t\t\tansiCode = ansiCode.split(';')[0][0] + '0';\n\t\t}\n\n\t\tconst item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));\n\t\tif (item) {\n\t\t\tconst indexEscape = ansiCodes.indexOf(item.toString());\n\t\t\tif (indexEscape === -1) {\n\t\t\t\toutput.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));\n\t\t\t} else {\n\t\t\t\tansiCodes.splice(indexEscape, 1);\n\t\t\t}\n\t\t} else if (isEscapes) {\n\t\t\toutput.push(wrapAnsi(0));\n\t\t\tbreak;\n\t\t} else {\n\t\t\toutput.push(wrapAnsi(ansiCodeOrigin));\n\t\t}\n\t}\n\n\tif (isEscapes) {\n\t\toutput = output.filter((element, index) => output.indexOf(element) === index);\n\n\t\tif (endAnsiCode !== undefined) {\n\t\t\tconst fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));\n\t\t\toutput = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);\n\t\t}\n\t}\n\n\treturn output.join('');\n};\n\nmodule.exports = (string, begin, end) => {\n\tconst characters = [...string];\n\tconst ansiCodes = [];\n\n\tlet stringEnd = typeof end === 'number' ? end : characters.length;\n\tlet isInsideEscape = false;\n\tlet ansiCode;\n\tlet visible = 0;\n\tlet output = '';\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tlet leftEscape = false;\n\n\t\tif (ESCAPES.includes(character)) {\n\t\t\tconst code = /\\d[^m]*/.exec(string.slice(index, index + 18));\n\t\t\tansiCode = code && code.length > 0 ? code[0] : undefined;\n\n\t\t\tif (visible < stringEnd) {\n\t\t\t\tisInsideEscape = true;\n\n\t\t\t\tif (ansiCode !== undefined) {\n\t\t\t\t\tansiCodes.push(ansiCode);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isInsideEscape && character === 'm') {\n\t\t\tisInsideEscape = false;\n\t\t\tleftEscape = true;\n\t\t}\n\n\t\tif (!isInsideEscape && !leftEscape) {\n\t\t\tvisible++;\n\t\t}\n\n\t\tif (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {\n\t\t\tvisible++;\n\n\t\t\tif (typeof end !== 'number') {\n\t\t\t\tstringEnd++;\n\t\t\t}\n\t\t}\n\n\t\tif (visible > begin && visible <= stringEnd) {\n\t\t\toutput += character;\n\t\t} else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {\n\t\t\toutput = checkAnsi(ansiCodes);\n\t\t} else if (visible >= stringEnd) {\n\t\t\toutput += checkAnsi(ansiCodes, true, ansiCode);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"script"}