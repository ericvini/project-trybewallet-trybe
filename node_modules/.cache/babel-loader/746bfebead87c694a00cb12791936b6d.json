{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'max-empty-lines';\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`\n});\n\nfunction rule(max, options, context) {\n  let emptyLines = 0;\n  let lastIndex = -1;\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber\n    }, {\n      actual: options,\n      possible: {\n        ignore: ['comments']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const ignoreComments = optionsMatches(options, 'ignore', 'comments');\n\n    const getChars = _.partial(replaceEmptyLines, max);\n    /**\n     * 1. walk nodes & replace enterchar\n     * 2. deal with special case.\n     */\n\n\n    if (context.fix) {\n      root.walk(node => {\n        if (node.type === 'comment') {\n          // for inline comments\n          if (node.raws.inline) {\n            node.raws.before = getChars(node.raws.before);\n          }\n\n          if (!ignoreComments) {\n            node.raws.left = getChars(node.raws.left);\n            node.raws.right = getChars(node.raws.right);\n          }\n        } else {\n          if (node.raws.before) {\n            node.raws.before = getChars(node.raws.before);\n          }\n\n          if (node.raws.after) {\n            node.raws.after = getChars(node.raws.after);\n          }\n        }\n      }); // first node\n\n      const firstNodeRawsBefore = _.get(root, 'first.raws.before'); // root raws\n\n\n      const rootRawsAfter = _.get(root, 'raws.after'); // not document node\n\n\n      if (_.get(root, 'document.constructor.name') !== 'Document') {\n        if (firstNodeRawsBefore) {\n          _.set(root, 'first.raws.before', getChars(firstNodeRawsBefore, true));\n        }\n\n        if (rootRawsAfter) {\n          // when max setted 0, should be treated as 1 in this situation.\n          _.set(root, 'raws.after', replaceEmptyLines(max === 0 ? 1 : max, rootRawsAfter, true));\n        }\n      } else if (rootRawsAfter) {\n        // `css in js` or `html`\n        _.set(root, 'raws.after', replaceEmptyLines(max === 0 ? 1 : max, rootRawsAfter));\n      }\n\n      return;\n    }\n\n    emptyLines = 0;\n    lastIndex = -1;\n    const rootString = root.toString();\n    styleSearch({\n      source: rootString,\n      target: /\\r\\n/.test(rootString) ? '\\r\\n' : '\\n',\n      comments: ignoreComments ? 'skip' : 'check'\n    }, match => {\n      checkMatch(rootString, match.startIndex, match.endIndex, root);\n    });\n\n    function checkMatch(source, matchStartIndex, matchEndIndex, node) {\n      const eof = matchEndIndex === source.length;\n      let violation = false; // Additional check for beginning of file\n\n      if (!matchStartIndex || lastIndex === matchStartIndex) {\n        emptyLines++;\n      } else {\n        emptyLines = 0;\n      }\n\n      lastIndex = matchEndIndex;\n      if (emptyLines > max) violation = true;\n      if (!eof && !violation) return;\n\n      if (violation) {\n        report({\n          message: messages.expected(max),\n          node,\n          index: matchStartIndex,\n          result,\n          ruleName\n        });\n      } // Additional check for end of file\n\n\n      if (eof && max) {\n        emptyLines++;\n\n        if (emptyLines > max && isEofNode(result.root, node)) {\n          report({\n            message: messages.expected(max),\n            node,\n            index: matchEndIndex,\n            result,\n            ruleName\n          });\n        }\n      }\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function replaceEmptyLines(max, str, isSpecialCase = false) {\n      const repeatTimes = isSpecialCase ? max : max + 1;\n\n      if (repeatTimes === 0 || typeof str !== 'string') {\n        return '';\n      }\n\n      const emptyLFLines = '\\n'.repeat(repeatTimes);\n      const emptyCRLFLines = '\\r\\n'.repeat(repeatTimes); // TODO: Issue #4985\n      // eslint-disable-next-line no-shadow\n\n      let result;\n\n      if (/(\\r\\n)+/g.test(str)) {\n        result = str.replace(/(\\r\\n)+/g, $1 => {\n          if ($1.length / 2 > repeatTimes) {\n            return emptyCRLFLines;\n          }\n\n          return $1;\n        });\n      } else {\n        result = str.replace(/(\\n)+/g, $1 => {\n          if ($1.length > repeatTimes) {\n            return emptyLFLines;\n          }\n\n          return $1;\n        });\n      }\n\n      return result;\n    }\n  };\n}\n/**\n * Checks whether the given node is the last node of file.\n * @param {Document|null} document the document node with `postcss-html` and `postcss-jsx`.\n * @param {Root} root the root node of css\n */\n\n\nfunction isEofNode(document, root) {\n  if (!document || document.constructor.name !== 'Document') {\n    return true;\n  } // In the `postcss-html` and `postcss-jsx` syntax, checks that there is text after the given node.\n\n\n  let after;\n\n  if (root === document.last) {\n    after = _.get(document, 'raws.afterEnd');\n  } else {\n    const rootIndex = document.index(root);\n    after = _.get(document.nodes[rootIndex + 1], 'raws.beforeStart');\n  }\n\n  return !String(after).trim();\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/max-empty-lines/index.js"],"names":["_","require","optionsMatches","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","expected","max","rule","options","context","emptyLines","lastIndex","root","result","validOptions","actual","possible","isNumber","ignore","optional","ignoreComments","getChars","partial","replaceEmptyLines","fix","walk","node","type","raws","inline","before","left","right","after","firstNodeRawsBefore","get","rootRawsAfter","set","rootString","toString","source","target","test","comments","match","checkMatch","startIndex","endIndex","matchStartIndex","matchEndIndex","eof","length","violation","message","index","isEofNode","str","isSpecialCase","repeatTimes","emptyLFLines","repeat","emptyCRLFLines","replace","$1","document","constructor","name","last","rootIndex","nodes","String","trim","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,4BAAD,CAA9B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMK,eAAe,GAAGL,OAAO,CAAC,6BAAD,CAA/B;;AAEA,MAAMM,QAAQ,GAAG,iBAAjB;AAEA,MAAMC,QAAQ,GAAGJ,YAAY,CAACG,QAAD,EAAW;AACvCE,EAAAA,QAAQ,EAAGC,GAAD,IAAU,yBAAwBA,GAAI,UAASA,GAAG,KAAK,CAAR,GAAY,MAAZ,GAAqB,OAAQ;AAD/C,CAAX,CAA7B;;AAIA,SAASC,IAAT,CAAcD,GAAd,EAAmBE,OAAnB,EAA4BC,OAA5B,EAAqC;AACpC,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAIC,SAAS,GAAG,CAAC,CAAjB;AAEA,SAAO,CAACC,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGZ,eAAe,CACnCW,MADmC,EAEnCV,QAFmC,EAGnC;AACCY,MAAAA,MAAM,EAAET,GADT;AAECU,MAAAA,QAAQ,EAAEpB,CAAC,CAACqB;AAFb,KAHmC,EAOnC;AACCF,MAAAA,MAAM,EAAEP,OADT;AAECQ,MAAAA,QAAQ,EAAE;AACTE,QAAAA,MAAM,EAAE,CAAC,UAAD;AADC,OAFX;AAKCC,MAAAA,QAAQ,EAAE;AALX,KAPmC,CAApC;;AAgBA,QAAI,CAACL,YAAL,EAAmB;AAClB;AACA;;AAED,UAAMM,cAAc,GAAGtB,cAAc,CAACU,OAAD,EAAU,QAAV,EAAoB,UAApB,CAArC;;AACA,UAAMa,QAAQ,GAAGzB,CAAC,CAAC0B,OAAF,CAAUC,iBAAV,EAA6BjB,GAA7B,CAAjB;AAEA;AACF;AACA;AACA;;;AACE,QAAIG,OAAO,CAACe,GAAZ,EAAiB;AAChBZ,MAAAA,IAAI,CAACa,IAAL,CAAWC,IAAD,IAAU;AACnB,YAAIA,IAAI,CAACC,IAAL,KAAc,SAAlB,EAA6B;AAC5B;AACA,cAAID,IAAI,CAACE,IAAL,CAAUC,MAAd,EAAsB;AACrBH,YAAAA,IAAI,CAACE,IAAL,CAAUE,MAAV,GAAmBT,QAAQ,CAACK,IAAI,CAACE,IAAL,CAAUE,MAAX,CAA3B;AACA;;AAED,cAAI,CAACV,cAAL,EAAqB;AACpBM,YAAAA,IAAI,CAACE,IAAL,CAAUG,IAAV,GAAiBV,QAAQ,CAACK,IAAI,CAACE,IAAL,CAAUG,IAAX,CAAzB;AACAL,YAAAA,IAAI,CAACE,IAAL,CAAUI,KAAV,GAAkBX,QAAQ,CAACK,IAAI,CAACE,IAAL,CAAUI,KAAX,CAA1B;AACA;AACD,SAVD,MAUO;AACN,cAAIN,IAAI,CAACE,IAAL,CAAUE,MAAd,EAAsB;AACrBJ,YAAAA,IAAI,CAACE,IAAL,CAAUE,MAAV,GAAmBT,QAAQ,CAACK,IAAI,CAACE,IAAL,CAAUE,MAAX,CAA3B;AACA;;AAED,cAAIJ,IAAI,CAACE,IAAL,CAAUK,KAAd,EAAqB;AACpBP,YAAAA,IAAI,CAACE,IAAL,CAAUK,KAAV,GAAkBZ,QAAQ,CAACK,IAAI,CAACE,IAAL,CAAUK,KAAX,CAA1B;AACA;AACD;AACD,OApBD,EADgB,CAuBhB;;AACA,YAAMC,mBAAmB,GAAGtC,CAAC,CAACuC,GAAF,CAAMvB,IAAN,EAAY,mBAAZ,CAA5B,CAxBgB,CAyBhB;;;AACA,YAAMwB,aAAa,GAAGxC,CAAC,CAACuC,GAAF,CAAMvB,IAAN,EAAY,YAAZ,CAAtB,CA1BgB,CA4BhB;;;AACA,UAAIhB,CAAC,CAACuC,GAAF,CAAMvB,IAAN,EAAY,2BAAZ,MAA6C,UAAjD,EAA6D;AAC5D,YAAIsB,mBAAJ,EAAyB;AACxBtC,UAAAA,CAAC,CAACyC,GAAF,CAAMzB,IAAN,EAAY,mBAAZ,EAAiCS,QAAQ,CAACa,mBAAD,EAAsB,IAAtB,CAAzC;AACA;;AAED,YAAIE,aAAJ,EAAmB;AAClB;AACAxC,UAAAA,CAAC,CAACyC,GAAF,CAAMzB,IAAN,EAAY,YAAZ,EAA0BW,iBAAiB,CAACjB,GAAG,KAAK,CAAR,GAAY,CAAZ,GAAgBA,GAAjB,EAAsB8B,aAAtB,EAAqC,IAArC,CAA3C;AACA;AACD,OATD,MASO,IAAIA,aAAJ,EAAmB;AACzB;AACAxC,QAAAA,CAAC,CAACyC,GAAF,CAAMzB,IAAN,EAAY,YAAZ,EAA0BW,iBAAiB,CAACjB,GAAG,KAAK,CAAR,GAAY,CAAZ,GAAgBA,GAAjB,EAAsB8B,aAAtB,CAA3C;AACA;;AAED;AACA;;AAED1B,IAAAA,UAAU,GAAG,CAAb;AACAC,IAAAA,SAAS,GAAG,CAAC,CAAb;AACA,UAAM2B,UAAU,GAAG1B,IAAI,CAAC2B,QAAL,EAAnB;AAEAtC,IAAAA,WAAW,CACV;AACCuC,MAAAA,MAAM,EAAEF,UADT;AAECG,MAAAA,MAAM,EAAE,OAAOC,IAAP,CAAYJ,UAAZ,IAA0B,MAA1B,GAAmC,IAF5C;AAGCK,MAAAA,QAAQ,EAAEvB,cAAc,GAAG,MAAH,GAAY;AAHrC,KADU,EAMTwB,KAAD,IAAW;AACVC,MAAAA,UAAU,CAACP,UAAD,EAAaM,KAAK,CAACE,UAAnB,EAA+BF,KAAK,CAACG,QAArC,EAA+CnC,IAA/C,CAAV;AACA,KARS,CAAX;;AAWA,aAASiC,UAAT,CAAoBL,MAApB,EAA4BQ,eAA5B,EAA6CC,aAA7C,EAA4DvB,IAA5D,EAAkE;AACjE,YAAMwB,GAAG,GAAGD,aAAa,KAAKT,MAAM,CAACW,MAArC;AACA,UAAIC,SAAS,GAAG,KAAhB,CAFiE,CAIjE;;AACA,UAAI,CAACJ,eAAD,IAAoBrC,SAAS,KAAKqC,eAAtC,EAAuD;AACtDtC,QAAAA,UAAU;AACV,OAFD,MAEO;AACNA,QAAAA,UAAU,GAAG,CAAb;AACA;;AAEDC,MAAAA,SAAS,GAAGsC,aAAZ;AAEA,UAAIvC,UAAU,GAAGJ,GAAjB,EAAsB8C,SAAS,GAAG,IAAZ;AAEtB,UAAI,CAACF,GAAD,IAAQ,CAACE,SAAb,EAAwB;;AAExB,UAAIA,SAAJ,EAAe;AACdrD,QAAAA,MAAM,CAAC;AACNsD,UAAAA,OAAO,EAAEjD,QAAQ,CAACC,QAAT,CAAkBC,GAAlB,CADH;AAENoB,UAAAA,IAFM;AAGN4B,UAAAA,KAAK,EAAEN,eAHD;AAINnC,UAAAA,MAJM;AAKNV,UAAAA;AALM,SAAD,CAAN;AAOA,OAzBgE,CA2BjE;;;AACA,UAAI+C,GAAG,IAAI5C,GAAX,EAAgB;AACfI,QAAAA,UAAU;;AAEV,YAAIA,UAAU,GAAGJ,GAAb,IAAoBiD,SAAS,CAAC1C,MAAM,CAACD,IAAR,EAAcc,IAAd,CAAjC,EAAsD;AACrD3B,UAAAA,MAAM,CAAC;AACNsD,YAAAA,OAAO,EAAEjD,QAAQ,CAACC,QAAT,CAAkBC,GAAlB,CADH;AAENoB,YAAAA,IAFM;AAGN4B,YAAAA,KAAK,EAAEL,aAHD;AAINpC,YAAAA,MAJM;AAKNV,YAAAA;AALM,WAAD,CAAN;AAOA;AACD;AACD,KAlIuB,CAoIxB;AACA;;;AACA,aAASoB,iBAAT,CAA2BjB,GAA3B,EAAgCkD,GAAhC,EAAqCC,aAAa,GAAG,KAArD,EAA4D;AAC3D,YAAMC,WAAW,GAAGD,aAAa,GAAGnD,GAAH,GAASA,GAAG,GAAG,CAAhD;;AAEA,UAAIoD,WAAW,KAAK,CAAhB,IAAqB,OAAOF,GAAP,KAAe,QAAxC,EAAkD;AACjD,eAAO,EAAP;AACA;;AAED,YAAMG,YAAY,GAAG,KAAKC,MAAL,CAAYF,WAAZ,CAArB;AACA,YAAMG,cAAc,GAAG,OAAOD,MAAP,CAAcF,WAAd,CAAvB,CAR2D,CAU3D;AACA;;AACA,UAAI7C,MAAJ;;AAEA,UAAI,WAAW6B,IAAX,CAAgBc,GAAhB,CAAJ,EAA0B;AACzB3C,QAAAA,MAAM,GAAG2C,GAAG,CAACM,OAAJ,CAAY,UAAZ,EAAyBC,EAAD,IAAQ;AACxC,cAAIA,EAAE,CAACZ,MAAH,GAAY,CAAZ,GAAgBO,WAApB,EAAiC;AAChC,mBAAOG,cAAP;AACA;;AAED,iBAAOE,EAAP;AACA,SANQ,CAAT;AAOA,OARD,MAQO;AACNlD,QAAAA,MAAM,GAAG2C,GAAG,CAACM,OAAJ,CAAY,QAAZ,EAAuBC,EAAD,IAAQ;AACtC,cAAIA,EAAE,CAACZ,MAAH,GAAYO,WAAhB,EAA6B;AAC5B,mBAAOC,YAAP;AACA;;AAED,iBAAOI,EAAP;AACA,SANQ,CAAT;AAOA;;AAED,aAAOlD,MAAP;AACA;AACD,GAxKD;AAyKA;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAS0C,SAAT,CAAmBS,QAAnB,EAA6BpD,IAA7B,EAAmC;AAClC,MAAI,CAACoD,QAAD,IAAaA,QAAQ,CAACC,WAAT,CAAqBC,IAArB,KAA8B,UAA/C,EAA2D;AAC1D,WAAO,IAAP;AACA,GAHiC,CAKlC;;;AACA,MAAIjC,KAAJ;;AAEA,MAAIrB,IAAI,KAAKoD,QAAQ,CAACG,IAAtB,EAA4B;AAC3BlC,IAAAA,KAAK,GAAGrC,CAAC,CAACuC,GAAF,CAAM6B,QAAN,EAAgB,eAAhB,CAAR;AACA,GAFD,MAEO;AACN,UAAMI,SAAS,GAAGJ,QAAQ,CAACV,KAAT,CAAe1C,IAAf,CAAlB;AAEAqB,IAAAA,KAAK,GAAGrC,CAAC,CAACuC,GAAF,CAAM6B,QAAQ,CAACK,KAAT,CAAeD,SAAS,GAAG,CAA3B,CAAN,EAAqC,kBAArC,CAAR;AACA;;AAED,SAAO,CAACE,MAAM,CAACrC,KAAD,CAAN,CAAcsC,IAAd,EAAR;AACA;;AAEDhE,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAI,IAAI,CAACH,QAAL,GAAgBA,QAAhB;AACAoE,MAAM,CAACC,OAAP,GAAiBlE,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'max-empty-lines';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (max) => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`,\n});\n\nfunction rule(max, options, context) {\n\tlet emptyLines = 0;\n\tlet lastIndex = -1;\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: max,\n\t\t\t\tpossible: _.isNumber,\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['comments'],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ignoreComments = optionsMatches(options, 'ignore', 'comments');\n\t\tconst getChars = _.partial(replaceEmptyLines, max);\n\n\t\t/**\n\t\t * 1. walk nodes & replace enterchar\n\t\t * 2. deal with special case.\n\t\t */\n\t\tif (context.fix) {\n\t\t\troot.walk((node) => {\n\t\t\t\tif (node.type === 'comment') {\n\t\t\t\t\t// for inline comments\n\t\t\t\t\tif (node.raws.inline) {\n\t\t\t\t\t\tnode.raws.before = getChars(node.raws.before);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ignoreComments) {\n\t\t\t\t\t\tnode.raws.left = getChars(node.raws.left);\n\t\t\t\t\t\tnode.raws.right = getChars(node.raws.right);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (node.raws.before) {\n\t\t\t\t\t\tnode.raws.before = getChars(node.raws.before);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node.raws.after) {\n\t\t\t\t\t\tnode.raws.after = getChars(node.raws.after);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// first node\n\t\t\tconst firstNodeRawsBefore = _.get(root, 'first.raws.before');\n\t\t\t// root raws\n\t\t\tconst rootRawsAfter = _.get(root, 'raws.after');\n\n\t\t\t// not document node\n\t\t\tif (_.get(root, 'document.constructor.name') !== 'Document') {\n\t\t\t\tif (firstNodeRawsBefore) {\n\t\t\t\t\t_.set(root, 'first.raws.before', getChars(firstNodeRawsBefore, true));\n\t\t\t\t}\n\n\t\t\t\tif (rootRawsAfter) {\n\t\t\t\t\t// when max setted 0, should be treated as 1 in this situation.\n\t\t\t\t\t_.set(root, 'raws.after', replaceEmptyLines(max === 0 ? 1 : max, rootRawsAfter, true));\n\t\t\t\t}\n\t\t\t} else if (rootRawsAfter) {\n\t\t\t\t// `css in js` or `html`\n\t\t\t\t_.set(root, 'raws.after', replaceEmptyLines(max === 0 ? 1 : max, rootRawsAfter));\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\temptyLines = 0;\n\t\tlastIndex = -1;\n\t\tconst rootString = root.toString();\n\n\t\tstyleSearch(\n\t\t\t{\n\t\t\t\tsource: rootString,\n\t\t\t\ttarget: /\\r\\n/.test(rootString) ? '\\r\\n' : '\\n',\n\t\t\t\tcomments: ignoreComments ? 'skip' : 'check',\n\t\t\t},\n\t\t\t(match) => {\n\t\t\t\tcheckMatch(rootString, match.startIndex, match.endIndex, root);\n\t\t\t},\n\t\t);\n\n\t\tfunction checkMatch(source, matchStartIndex, matchEndIndex, node) {\n\t\t\tconst eof = matchEndIndex === source.length;\n\t\t\tlet violation = false;\n\n\t\t\t// Additional check for beginning of file\n\t\t\tif (!matchStartIndex || lastIndex === matchStartIndex) {\n\t\t\t\temptyLines++;\n\t\t\t} else {\n\t\t\t\temptyLines = 0;\n\t\t\t}\n\n\t\t\tlastIndex = matchEndIndex;\n\n\t\t\tif (emptyLines > max) violation = true;\n\n\t\t\tif (!eof && !violation) return;\n\n\t\t\tif (violation) {\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(max),\n\t\t\t\t\tnode,\n\t\t\t\t\tindex: matchStartIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Additional check for end of file\n\t\t\tif (eof && max) {\n\t\t\t\temptyLines++;\n\n\t\t\t\tif (emptyLines > max && isEofNode(result.root, node)) {\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: messages.expected(max),\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tindex: matchEndIndex,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction replaceEmptyLines(max, str, isSpecialCase = false) {\n\t\t\tconst repeatTimes = isSpecialCase ? max : max + 1;\n\n\t\t\tif (repeatTimes === 0 || typeof str !== 'string') {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tconst emptyLFLines = '\\n'.repeat(repeatTimes);\n\t\t\tconst emptyCRLFLines = '\\r\\n'.repeat(repeatTimes);\n\n\t\t\t// TODO: Issue #4985\n\t\t\t// eslint-disable-next-line no-shadow\n\t\t\tlet result;\n\n\t\t\tif (/(\\r\\n)+/g.test(str)) {\n\t\t\t\tresult = str.replace(/(\\r\\n)+/g, ($1) => {\n\t\t\t\t\tif ($1.length / 2 > repeatTimes) {\n\t\t\t\t\t\treturn emptyCRLFLines;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn $1;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresult = str.replace(/(\\n)+/g, ($1) => {\n\t\t\t\t\tif ($1.length > repeatTimes) {\n\t\t\t\t\t\treturn emptyLFLines;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn $1;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n}\n\n/**\n * Checks whether the given node is the last node of file.\n * @param {Document|null} document the document node with `postcss-html` and `postcss-jsx`.\n * @param {Root} root the root node of css\n */\nfunction isEofNode(document, root) {\n\tif (!document || document.constructor.name !== 'Document') {\n\t\treturn true;\n\t}\n\n\t// In the `postcss-html` and `postcss-jsx` syntax, checks that there is text after the given node.\n\tlet after;\n\n\tif (root === document.last) {\n\t\tafter = _.get(document, 'raws.afterEnd');\n\t} else {\n\t\tconst rootIndex = document.index(root);\n\n\t\tafter = _.get(document.nodes[rootIndex + 1], 'raws.beforeStart');\n\t}\n\n\treturn !String(after).trim();\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}