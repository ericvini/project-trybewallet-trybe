{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'declaration-colon-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \":\"',\n  expectedAfterMultiLine: () => 'Expected newline after \":\" with a multi-line declaration'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return;\n      } // Get the raw prop, and only the prop\n\n\n      const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1; // The extra characters tacked onto the end ensure that there is a character to check\n      // after the colon. Otherwise, with `background:pink` the character after the\n\n      const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;\n\n      for (let i = 0, l = propPlusColon.length; i < l; i++) {\n        if (propPlusColon[i] !== ':') {\n          continue;\n        }\n\n        const indexToCheck = /^[^\\S\\r\\n]*\\/\\*/.test(propPlusColon.slice(i + 1)) ? propPlusColon.indexOf('*/', i) + 1 : i;\n        checker.afterOneOnly({\n          source: propPlusColon,\n          index: indexToCheck,\n          lineCheckStr: decl.value,\n          err: m => {\n            if (context.fix) {\n              const between = decl.raws.between;\n              const betweenStart = declarationValueIndex(decl) - between.length;\n              const sliceIndex = indexToCheck - betweenStart + 1;\n              const betweenBefore = between.slice(0, sliceIndex);\n              const betweenAfter = between.slice(sliceIndex);\n\n              if (/^\\s*\\r?\\n/.test(betweenAfter)) {\n                decl.raws.between = betweenBefore + betweenAfter.replace(/^[^\\S\\r\\n]*/, '');\n              } else {\n                decl.raws.between = betweenBefore + context.newline + betweenAfter;\n              }\n\n              return;\n            }\n\n            report({\n              message: m,\n              node: decl,\n              index: indexToCheck,\n              result,\n              ruleName\n            });\n          }\n        });\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/declaration-colon-newline-after/index.js"],"names":["declarationValueIndex","require","isStandardSyntaxDeclaration","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","walkDecls","decl","endOfPropIndex","raws","between","length","propPlusColon","toString","slice","i","l","indexToCheck","test","indexOf","afterOneOnly","source","index","lineCheckStr","value","err","m","fix","betweenStart","sliceIndex","betweenBefore","betweenAfter","replace","newline","message","node","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,qBAAqB,GAAGC,OAAO,CAAC,mCAAD,CAArC;;AACA,MAAMC,2BAA2B,GAAGD,OAAO,CAAC,yCAAD,CAA3C;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMI,eAAe,GAAGJ,OAAO,CAAC,6BAAD,CAA/B;;AACA,MAAMK,iBAAiB,GAAGL,OAAO,CAAC,+BAAD,CAAjC;;AAEA,MAAMM,QAAQ,GAAG,iCAAjB;AAEA,MAAMC,QAAQ,GAAGJ,YAAY,CAACG,QAAD,EAAW;AACvCE,EAAAA,aAAa,EAAE,MAAM,4BADkB;AAEvCC,EAAAA,sBAAsB,EAAE,MAAM;AAFS,CAAX,CAA7B;;AAKA,SAASC,IAAT,CAAcC,WAAd,EAA2BC,OAA3B,EAAoCC,OAApC,EAA6C;AAC5C,QAAMC,OAAO,GAAGT,iBAAiB,CAAC,SAAD,EAAYM,WAAZ,EAAyBJ,QAAzB,CAAjC;AAEA,SAAO,CAACQ,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGb,eAAe,CAACY,MAAD,EAASV,QAAT,EAAmB;AACtDY,MAAAA,MAAM,EAAEP,WAD8C;AAEtDQ,MAAAA,QAAQ,EAAE,CAAC,QAAD,EAAW,mBAAX;AAF4C,KAAnB,CAApC;;AAKA,QAAI,CAACF,YAAL,EAAmB;AAClB;AACA;;AAEDF,IAAAA,IAAI,CAACK,SAAL,CAAgBC,IAAD,IAAU;AACxB,UAAI,CAACpB,2BAA2B,CAACoB,IAAD,CAAhC,EAAwC;AACvC;AACA,OAHuB,CAKxB;;;AACA,YAAMC,cAAc,GAAGvB,qBAAqB,CAACsB,IAAD,CAArB,GAA8B,CAACA,IAAI,CAACE,IAAL,CAAUC,OAAV,IAAqB,EAAtB,EAA0BC,MAAxD,GAAiE,CAAxF,CANwB,CAQxB;AACA;;AACA,YAAMC,aAAa,GAAI,GAAEL,IAAI,CAACM,QAAL,GAAgBC,KAAhB,CAAsB,CAAtB,EAAyBN,cAAzB,CAAyC,KAAlE;;AAEA,WAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,aAAa,CAACD,MAAlC,EAA0CI,CAAC,GAAGC,CAA9C,EAAiDD,CAAC,EAAlD,EAAsD;AACrD,YAAIH,aAAa,CAACG,CAAD,CAAb,KAAqB,GAAzB,EAA8B;AAC7B;AACA;;AAED,cAAME,YAAY,GAAG,kBAAkBC,IAAlB,CAAuBN,aAAa,CAACE,KAAd,CAAoBC,CAAC,GAAG,CAAxB,CAAvB,IAClBH,aAAa,CAACO,OAAd,CAAsB,IAAtB,EAA4BJ,CAA5B,IAAiC,CADf,GAElBA,CAFH;AAIAf,QAAAA,OAAO,CAACoB,YAAR,CAAqB;AACpBC,UAAAA,MAAM,EAAET,aADY;AAEpBU,UAAAA,KAAK,EAAEL,YAFa;AAGpBM,UAAAA,YAAY,EAAEhB,IAAI,CAACiB,KAHC;AAIpBC,UAAAA,GAAG,EAAGC,CAAD,IAAO;AACX,gBAAI3B,OAAO,CAAC4B,GAAZ,EAAiB;AAChB,oBAAMjB,OAAO,GAAGH,IAAI,CAACE,IAAL,CAAUC,OAA1B;AACA,oBAAMkB,YAAY,GAAG3C,qBAAqB,CAACsB,IAAD,CAArB,GAA8BG,OAAO,CAACC,MAA3D;AACA,oBAAMkB,UAAU,GAAGZ,YAAY,GAAGW,YAAf,GAA8B,CAAjD;AACA,oBAAME,aAAa,GAAGpB,OAAO,CAACI,KAAR,CAAc,CAAd,EAAiBe,UAAjB,CAAtB;AACA,oBAAME,YAAY,GAAGrB,OAAO,CAACI,KAAR,CAAce,UAAd,CAArB;;AAEA,kBAAI,YAAYX,IAAZ,CAAiBa,YAAjB,CAAJ,EAAoC;AACnCxB,gBAAAA,IAAI,CAACE,IAAL,CAAUC,OAAV,GAAoBoB,aAAa,GAAGC,YAAY,CAACC,OAAb,CAAqB,aAArB,EAAoC,EAApC,CAApC;AACA,eAFD,MAEO;AACNzB,gBAAAA,IAAI,CAACE,IAAL,CAAUC,OAAV,GAAoBoB,aAAa,GAAG/B,OAAO,CAACkC,OAAxB,GAAkCF,YAAtD;AACA;;AAED;AACA;;AAED3C,YAAAA,MAAM,CAAC;AACN8C,cAAAA,OAAO,EAAER,CADH;AAENS,cAAAA,IAAI,EAAE5B,IAFA;AAGNe,cAAAA,KAAK,EAAEL,YAHD;AAINf,cAAAA,MAJM;AAKNV,cAAAA;AALM,aAAD,CAAN;AAOA;AA5BmB,SAArB;AA8BA;AACD,KApDD;AAqDA,GA/DD;AAgEA;;AAEDI,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAI,IAAI,CAACH,QAAL,GAAgBA,QAAhB;AACA2C,MAAM,CAACC,OAAP,GAAiBzC,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'declaration-colon-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \":\"',\n\texpectedAfterMultiLine: () => 'Expected newline after \":\" with a multi-line declaration',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tif (!isStandardSyntaxDeclaration(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the raw prop, and only the prop\n\t\t\tconst endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;\n\n\t\t\t// The extra characters tacked onto the end ensure that there is a character to check\n\t\t\t// after the colon. Otherwise, with `background:pink` the character after the\n\t\t\tconst propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;\n\n\t\t\tfor (let i = 0, l = propPlusColon.length; i < l; i++) {\n\t\t\t\tif (propPlusColon[i] !== ':') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst indexToCheck = /^[^\\S\\r\\n]*\\/\\*/.test(propPlusColon.slice(i + 1))\n\t\t\t\t\t? propPlusColon.indexOf('*/', i) + 1\n\t\t\t\t\t: i;\n\n\t\t\t\tchecker.afterOneOnly({\n\t\t\t\t\tsource: propPlusColon,\n\t\t\t\t\tindex: indexToCheck,\n\t\t\t\t\tlineCheckStr: decl.value,\n\t\t\t\t\terr: (m) => {\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\tconst between = decl.raws.between;\n\t\t\t\t\t\t\tconst betweenStart = declarationValueIndex(decl) - between.length;\n\t\t\t\t\t\t\tconst sliceIndex = indexToCheck - betweenStart + 1;\n\t\t\t\t\t\t\tconst betweenBefore = between.slice(0, sliceIndex);\n\t\t\t\t\t\t\tconst betweenAfter = between.slice(sliceIndex);\n\n\t\t\t\t\t\t\tif (/^\\s*\\r?\\n/.test(betweenAfter)) {\n\t\t\t\t\t\t\t\tdecl.raws.between = betweenBefore + betweenAfter.replace(/^[^\\S\\r\\n]*/, '');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdecl.raws.between = betweenBefore + context.newline + betweenAfter;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treport({\n\t\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\t\tnode: decl,\n\t\t\t\t\t\t\tindex: indexToCheck,\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}