{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isWhitespace = require('../../utils/isWhitespace');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'function-whitespace-after';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected whitespace after \")\"',\n  rejected: 'Unexpected whitespace after \")\"'\n});\nconst ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([')', ',', '}', ':', '/', undefined]);\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    function check(node, value, getIndex, fix) {\n      styleSearch({\n        source: value,\n        target: ')',\n        functionArguments: 'only'\n      }, match => {\n        checkClosingParen(value, match.startIndex + 1, node, getIndex, fix);\n      });\n    }\n\n    function checkClosingParen(source, index, node, getIndex, fix) {\n      const nextChar = source[index];\n\n      if (expectation === 'always') {\n        // Allow for the next character to be a single empty space,\n        // another closing parenthesis, a comma, or the end of the value\n        if (nextChar === ' ') {\n          return;\n        }\n\n        if (nextChar === '\\n') {\n          return;\n        }\n\n        if (source.substr(index, 2) === '\\r\\n') {\n          return;\n        }\n\n        if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {\n          return;\n        }\n\n        if (fix) {\n          fix(index);\n          return;\n        }\n\n        report({\n          message: messages.expected,\n          node,\n          index: getIndex(node) + index,\n          result,\n          ruleName\n        });\n      } else if (expectation === 'never') {\n        if (isWhitespace(nextChar)) {\n          if (fix) {\n            fix(index);\n            return;\n          }\n\n          report({\n            message: messages.rejected,\n            node,\n            index: getIndex(node) + index,\n            result,\n            ruleName\n          });\n        }\n      }\n    }\n\n    function createFixer(value) {\n      let fixed = '';\n      let lastIndex = 0;\n      let applyFix;\n\n      if (expectation === 'always') {\n        applyFix = index => {\n          // eslint-disable-next-line prefer-template\n          fixed += value.slice(lastIndex, index) + ' ';\n          lastIndex = index;\n        };\n      } else if (expectation === 'never') {\n        applyFix = index => {\n          let whitespaceEndIndex = index + 1;\n\n          while (whitespaceEndIndex < value.length && isWhitespace(value[whitespaceEndIndex])) {\n            whitespaceEndIndex++;\n          }\n\n          fixed += value.slice(lastIndex, index);\n          lastIndex = whitespaceEndIndex;\n        };\n      }\n\n      return {\n        applyFix,\n\n        get hasFixed() {\n          return Boolean(lastIndex);\n        },\n\n        get fixed() {\n          return fixed + value.slice(lastIndex);\n        }\n\n      };\n    }\n\n    root.walkAtRules(/^import$/i, atRule => {\n      const param = _.get(atRule, 'raws.params.raw', atRule.params);\n\n      const fixer = context.fix && createFixer(param);\n      check(atRule, param, atRuleParamIndex, fixer && fixer.applyFix);\n\n      if (fixer && fixer.hasFixed) {\n        if (atRule.raws.params) {\n          atRule.raws.params.raw = fixer.fixed;\n        } else {\n          atRule.params = fixer.fixed;\n        }\n      }\n    });\n    root.walkDecls(decl => {\n      const value = _.get(decl, 'raws.value.raw', decl.value);\n\n      const fixer = context.fix && createFixer(value);\n      check(decl, value, declarationValueIndex, fixer && fixer.applyFix);\n\n      if (fixer && fixer.hasFixed) {\n        if (decl.raws.value) {\n          decl.raws.value.raw = fixer.fixed;\n        } else {\n          decl.value = fixer.fixed;\n        }\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/function-whitespace-after/index.js"],"names":["_","require","atRuleParamIndex","declarationValueIndex","isWhitespace","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","expected","rejected","ACCEPTABLE_AFTER_CLOSING_PAREN","Set","undefined","rule","expectation","options","context","root","result","validOptions","actual","possible","check","node","value","getIndex","fix","source","target","functionArguments","match","checkClosingParen","startIndex","index","nextChar","substr","has","message","createFixer","fixed","lastIndex","applyFix","slice","whitespaceEndIndex","length","hasFixed","Boolean","walkAtRules","atRule","param","get","params","fixer","raws","raw","walkDecls","decl","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isWhitespace = require('../../utils/isWhitespace');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'function-whitespace-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected whitespace after \")\"',\n\trejected: 'Unexpected whitespace after \")\"',\n});\n\nconst ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([')', ',', '}', ':', '/', undefined]);\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction check(node, value, getIndex, fix) {\n\t\t\tstyleSearch(\n\t\t\t\t{\n\t\t\t\t\tsource: value,\n\t\t\t\t\ttarget: ')',\n\t\t\t\t\tfunctionArguments: 'only',\n\t\t\t\t},\n\t\t\t\t(match) => {\n\t\t\t\t\tcheckClosingParen(value, match.startIndex + 1, node, getIndex, fix);\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tfunction checkClosingParen(source, index, node, getIndex, fix) {\n\t\t\tconst nextChar = source[index];\n\n\t\t\tif (expectation === 'always') {\n\t\t\t\t// Allow for the next character to be a single empty space,\n\t\t\t\t// another closing parenthesis, a comma, or the end of the value\n\t\t\t\tif (nextChar === ' ') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (nextChar === '\\n') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (source.substr(index, 2) === '\\r\\n') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (fix) {\n\t\t\t\t\tfix(index);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected,\n\t\t\t\t\tnode,\n\t\t\t\t\tindex: getIndex(node) + index,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t} else if (expectation === 'never') {\n\t\t\t\tif (isWhitespace(nextChar)) {\n\t\t\t\t\tif (fix) {\n\t\t\t\t\t\tfix(index);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: messages.rejected,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tindex: getIndex(node) + index,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createFixer(value) {\n\t\t\tlet fixed = '';\n\t\t\tlet lastIndex = 0;\n\t\t\tlet applyFix;\n\n\t\t\tif (expectation === 'always') {\n\t\t\t\tapplyFix = (index) => {\n\t\t\t\t\t// eslint-disable-next-line prefer-template\n\t\t\t\t\tfixed += value.slice(lastIndex, index) + ' ';\n\t\t\t\t\tlastIndex = index;\n\t\t\t\t};\n\t\t\t} else if (expectation === 'never') {\n\t\t\t\tapplyFix = (index) => {\n\t\t\t\t\tlet whitespaceEndIndex = index + 1;\n\n\t\t\t\t\twhile (whitespaceEndIndex < value.length && isWhitespace(value[whitespaceEndIndex])) {\n\t\t\t\t\t\twhitespaceEndIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tfixed += value.slice(lastIndex, index);\n\t\t\t\t\tlastIndex = whitespaceEndIndex;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tapplyFix,\n\t\t\t\tget hasFixed() {\n\t\t\t\t\treturn Boolean(lastIndex);\n\t\t\t\t},\n\t\t\t\tget fixed() {\n\t\t\t\t\treturn fixed + value.slice(lastIndex);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\troot.walkAtRules(/^import$/i, (atRule) => {\n\t\t\tconst param = _.get(atRule, 'raws.params.raw', atRule.params);\n\t\t\tconst fixer = context.fix && createFixer(param);\n\n\t\t\tcheck(atRule, param, atRuleParamIndex, fixer && fixer.applyFix);\n\n\t\t\tif (fixer && fixer.hasFixed) {\n\t\t\t\tif (atRule.raws.params) {\n\t\t\t\t\tatRule.raws.params.raw = fixer.fixed;\n\t\t\t\t} else {\n\t\t\t\t\tatRule.params = fixer.fixed;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\troot.walkDecls((decl) => {\n\t\t\tconst value = _.get(decl, 'raws.value.raw', decl.value);\n\t\t\tconst fixer = context.fix && createFixer(value);\n\n\t\t\tcheck(decl, value, declarationValueIndex, fixer && fixer.applyFix);\n\n\t\t\tif (fixer && fixer.hasFixed) {\n\t\t\t\tif (decl.raws.value) {\n\t\t\t\t\tdecl.raws.value.raw = fixer.fixed;\n\t\t\t\t} else {\n\t\t\t\t\tdecl.value = fixer.fixed;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}