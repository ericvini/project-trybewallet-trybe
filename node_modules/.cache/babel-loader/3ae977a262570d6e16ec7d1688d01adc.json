{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');\n\nconst nextNonCommentNode = require('../../utils/nextNonCommentNode');\n\nconst rawNodeString = require('../../utils/rawNodeString');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'at-rule-semicolon-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \";\"'\n});\n\nfunction rule(actual, secondary, context) {\n  const checker = whitespaceChecker('newline', actual, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual,\n      possible: ['always']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(atRule => {\n      const nextNode = atRule.next();\n\n      if (!nextNode) {\n        return;\n      }\n\n      if (hasBlock(atRule)) {\n        return;\n      }\n\n      if (!isStandardSyntaxAtRule(atRule)) {\n        return;\n      } // Allow an end-of-line comment\n\n\n      const nodeToCheck = nextNonCommentNode(nextNode);\n\n      if (!nodeToCheck) {\n        return;\n      }\n\n      checker.afterOneOnly({\n        source: rawNodeString(nodeToCheck),\n        index: -1,\n        err: msg => {\n          if (context.fix) {\n            nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n          } else {\n            report({\n              message: msg,\n              node: atRule,\n              index: atRule.toString().length + 1,\n              result,\n              ruleName\n            });\n          }\n        }\n      });\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/at-rule-semicolon-newline-after/index.js"],"names":["hasBlock","require","isStandardSyntaxAtRule","nextNonCommentNode","rawNodeString","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","rule","actual","secondary","context","checker","root","result","validOptions","possible","walkAtRules","atRule","nextNode","next","nodeToCheck","afterOneOnly","source","index","err","msg","fix","raws","before","newline","message","node","toString","length","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMC,sBAAsB,GAAGD,OAAO,CAAC,oCAAD,CAAtC;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,gCAAD,CAAlC;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMM,eAAe,GAAGN,OAAO,CAAC,6BAAD,CAA/B;;AACA,MAAMO,iBAAiB,GAAGP,OAAO,CAAC,+BAAD,CAAjC;;AAEA,MAAMQ,QAAQ,GAAG,iCAAjB;AAEA,MAAMC,QAAQ,GAAGJ,YAAY,CAACG,QAAD,EAAW;AACvCE,EAAAA,aAAa,EAAE,MAAM;AADkB,CAAX,CAA7B;;AAIA,SAASC,IAAT,CAAcC,MAAd,EAAsBC,SAAtB,EAAiCC,OAAjC,EAA0C;AACzC,QAAMC,OAAO,GAAGR,iBAAiB,CAAC,SAAD,EAAYK,MAAZ,EAAoBH,QAApB,CAAjC;AAEA,SAAO,CAACO,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGZ,eAAe,CAACW,MAAD,EAAST,QAAT,EAAmB;AACtDI,MAAAA,MADsD;AAEtDO,MAAAA,QAAQ,EAAE,CAAC,QAAD;AAF4C,KAAnB,CAApC;;AAKA,QAAI,CAACD,YAAL,EAAmB;AAClB;AACA;;AAEDF,IAAAA,IAAI,CAACI,WAAL,CAAkBC,MAAD,IAAY;AAC5B,YAAMC,QAAQ,GAAGD,MAAM,CAACE,IAAP,EAAjB;;AAEA,UAAI,CAACD,QAAL,EAAe;AACd;AACA;;AAED,UAAIvB,QAAQ,CAACsB,MAAD,CAAZ,EAAsB;AACrB;AACA;;AAED,UAAI,CAACpB,sBAAsB,CAACoB,MAAD,CAA3B,EAAqC;AACpC;AACA,OAb2B,CAe5B;;;AACA,YAAMG,WAAW,GAAGtB,kBAAkB,CAACoB,QAAD,CAAtC;;AAEA,UAAI,CAACE,WAAL,EAAkB;AACjB;AACA;;AAEDT,MAAAA,OAAO,CAACU,YAAR,CAAqB;AACpBC,QAAAA,MAAM,EAAEvB,aAAa,CAACqB,WAAD,CADD;AAEpBG,QAAAA,KAAK,EAAE,CAAC,CAFY;AAGpBC,QAAAA,GAAG,EAAGC,GAAD,IAAS;AACb,cAAIf,OAAO,CAACgB,GAAZ,EAAiB;AAChBN,YAAAA,WAAW,CAACO,IAAZ,CAAiBC,MAAjB,GAA0BlB,OAAO,CAACmB,OAAR,GAAkBT,WAAW,CAACO,IAAZ,CAAiBC,MAA7D;AACA,WAFD,MAEO;AACN5B,YAAAA,MAAM,CAAC;AACN8B,cAAAA,OAAO,EAAEL,GADH;AAENM,cAAAA,IAAI,EAAEd,MAFA;AAGNM,cAAAA,KAAK,EAAEN,MAAM,CAACe,QAAP,GAAkBC,MAAlB,GAA2B,CAH5B;AAINpB,cAAAA,MAJM;AAKNT,cAAAA;AALM,aAAD,CAAN;AAOA;AACD;AAfmB,OAArB;AAiBA,KAvCD;AAwCA,GAlDD;AAmDA;;AAEDG,IAAI,CAACH,QAAL,GAAgBA,QAAhB;AACAG,IAAI,CAACF,QAAL,GAAgBA,QAAhB;AACA6B,MAAM,CAACC,OAAP,GAAiB5B,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst hasBlock = require('../../utils/hasBlock');\nconst isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');\nconst nextNonCommentNode = require('../../utils/nextNonCommentNode');\nconst rawNodeString = require('../../utils/rawNodeString');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'at-rule-semicolon-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \";\"',\n});\n\nfunction rule(actual, secondary, context) {\n\tconst checker = whitespaceChecker('newline', actual, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual,\n\t\t\tpossible: ['always'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkAtRules((atRule) => {\n\t\t\tconst nextNode = atRule.next();\n\n\t\t\tif (!nextNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (hasBlock(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isStandardSyntaxAtRule(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Allow an end-of-line comment\n\t\t\tconst nodeToCheck = nextNonCommentNode(nextNode);\n\n\t\t\tif (!nodeToCheck) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchecker.afterOneOnly({\n\t\t\t\tsource: rawNodeString(nodeToCheck),\n\t\t\t\tindex: -1,\n\t\t\t\terr: (msg) => {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tnodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treport({\n\t\t\t\t\t\t\tmessage: msg,\n\t\t\t\t\t\t\tnode: atRule,\n\t\t\t\t\t\t\tindex: atRule.toString().length + 1,\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}