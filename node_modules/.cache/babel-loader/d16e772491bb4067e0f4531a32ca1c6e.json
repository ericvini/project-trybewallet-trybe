{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseMediaFeature = parseMediaFeature;\nexports.parseMediaQuery = parseMediaQuery;\nexports.parseMediaList = parseMediaList;\n\nvar _Node = require('./nodes/Node');\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nvar _Container = require('./nodes/Container');\n\nvar _Container2 = _interopRequireDefault(_Container);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\r\n * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`\r\n *\r\n * @param {string} string - the source expression string, can be inside parens\r\n * @param {Number} index - the index of `string` in the overall input\r\n *\r\n * @return {Array} an array of Nodes, the first element being a media feature,\r\n *    the secont - its value (may be missing)\r\n */\n\n\nfunction parseMediaFeature(string) {\n  var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n  var modesEntered = [{\n    mode: 'normal',\n    character: null\n  }];\n  var result = [];\n  var lastModeIndex = 0;\n  var mediaFeature = '';\n  var colon = null;\n  var mediaFeatureValue = null;\n  var indexLocal = index;\n  var stringNormalized = string; // Strip trailing parens (if any), and correct the starting index\n\n  if (string[0] === '(' && string[string.length - 1] === ')') {\n    stringNormalized = string.substring(1, string.length - 1);\n    indexLocal++;\n  }\n\n  for (var i = 0; i < stringNormalized.length; i++) {\n    var character = stringNormalized[i]; // If entering/exiting a string\n\n    if (character === '\\'' || character === '\"') {\n      if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n        modesEntered.push({\n          mode: 'string',\n          isCalculationEnabled: false,\n          character: character\n        });\n        lastModeIndex++;\n      } else if (modesEntered[lastModeIndex].mode === 'string' && modesEntered[lastModeIndex].character === character && stringNormalized[i - 1] !== '\\\\') {\n        modesEntered.pop();\n        lastModeIndex--;\n      }\n    } // If entering/exiting interpolation\n\n\n    if (character === '{') {\n      modesEntered.push({\n        mode: 'interpolation',\n        isCalculationEnabled: true\n      });\n      lastModeIndex++;\n    } else if (character === '}') {\n      modesEntered.pop();\n      lastModeIndex--;\n    } // If a : is met outside of a string, function call or interpolation, than\n    // this : separates a media feature and a value\n\n\n    if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {\n      var mediaFeatureValueStr = stringNormalized.substring(i + 1);\n      mediaFeatureValue = {\n        type: 'value',\n        before: /^(\\s*)/.exec(mediaFeatureValueStr)[1],\n        after: /(\\s*)$/.exec(mediaFeatureValueStr)[1],\n        value: mediaFeatureValueStr.trim()\n      }; // +1 for the colon\n\n      mediaFeatureValue.sourceIndex = mediaFeatureValue.before.length + i + 1 + indexLocal;\n      colon = {\n        type: 'colon',\n        sourceIndex: i + indexLocal,\n        after: mediaFeatureValue.before,\n        value: ':'\n      };\n      break;\n    }\n\n    mediaFeature += character;\n  } // Forming a media feature node\n\n\n  mediaFeature = {\n    type: 'media-feature',\n    before: /^(\\s*)/.exec(mediaFeature)[1],\n    after: /(\\s*)$/.exec(mediaFeature)[1],\n    value: mediaFeature.trim()\n  };\n  mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal;\n  result.push(mediaFeature);\n\n  if (colon !== null) {\n    colon.before = mediaFeature.after;\n    result.push(colon);\n  }\n\n  if (mediaFeatureValue !== null) {\n    result.push(mediaFeatureValue);\n  }\n\n  return result;\n}\n/**\r\n * Parses a media query, e.g. `screen and (color)`, `only tv`\r\n *\r\n * @param {string} string - the source media query string\r\n * @param {Number} index - the index of `string` in the overall input\r\n *\r\n * @return {Array} an array of Nodes and Containers\r\n */\n\n\nfunction parseMediaQuery(string) {\n  var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n  var result = []; // How many timies the parser entered parens/curly braces\n\n  var localLevel = 0; // Has any keyword, media type, media feature expression or interpolation\n  // ('element' hereafter) started\n\n  var insideSomeValue = false;\n  var node = void 0;\n\n  function resetNode() {\n    return {\n      before: '',\n      after: '',\n      value: ''\n    };\n  }\n\n  node = resetNode();\n\n  for (var i = 0; i < string.length; i++) {\n    var character = string[i]; // If not yet entered any element\n\n    if (!insideSomeValue) {\n      if (character.search(/\\s/) !== -1) {\n        // A whitespace\n        // Don't form 'after' yet; will do it later\n        node.before += character;\n      } else {\n        // Not a whitespace - entering an element\n        // Expression start\n        if (character === '(') {\n          node.type = 'media-feature-expression';\n          localLevel++;\n        }\n\n        node.value = character;\n        node.sourceIndex = index + i;\n        insideSomeValue = true;\n      }\n    } else {\n      // Already in the middle of some alement\n      node.value += character; // Here parens just increase localLevel and don't trigger a start of\n      // a media feature expression (since they can't be nested)\n      // Interpolation start\n\n      if (character === '{' || character === '(') {\n        localLevel++;\n      } // Interpolation/function call/media feature expression end\n\n\n      if (character === ')' || character === '}') {\n        localLevel--;\n      }\n    } // If exited all parens/curlies and the next symbol\n\n\n    if (insideSomeValue && localLevel === 0 && (character === ')' || i === string.length - 1 || string[i + 1].search(/\\s/) !== -1)) {\n      if (['not', 'only', 'and'].indexOf(node.value) !== -1) {\n        node.type = 'keyword';\n      } // if it's an expression, parse its contents\n\n\n      if (node.type === 'media-feature-expression') {\n        node.nodes = parseMediaFeature(node.value, node.sourceIndex);\n      }\n\n      result.push(Array.isArray(node.nodes) ? new _Container2.default(node) : new _Node2.default(node));\n      node = resetNode();\n      insideSomeValue = false;\n    }\n  } // Now process the result array - to specify undefined types of the nodes\n  // and specify the `after` prop\n\n\n  for (var _i = 0; _i < result.length; _i++) {\n    node = result[_i];\n\n    if (_i > 0) {\n      result[_i - 1].after = node.before;\n    } // Node types. Might not be set because contains interpolation/function\n    // calls or fully consists of them\n\n\n    if (node.type === undefined) {\n      if (_i > 0) {\n        // only `and` can follow an expression\n        if (result[_i - 1].type === 'media-feature-expression') {\n          node.type = 'keyword';\n          continue;\n        } // Anything after 'only|not' is a media type\n\n\n        if (result[_i - 1].value === 'not' || result[_i - 1].value === 'only') {\n          node.type = 'media-type';\n          continue;\n        } // Anything after 'and' is an expression\n\n\n        if (result[_i - 1].value === 'and') {\n          node.type = 'media-feature-expression';\n          continue;\n        }\n\n        if (result[_i - 1].type === 'media-type') {\n          // if it is the last element - it might be an expression\n          // or 'and' depending on what is after it\n          if (!result[_i + 1]) {\n            node.type = 'media-feature-expression';\n          } else {\n            node.type = result[_i + 1].type === 'media-feature-expression' ? 'keyword' : 'media-feature-expression';\n          }\n        }\n      }\n\n      if (_i === 0) {\n        // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then\n        // its type would have been set by now\n        if (!result[_i + 1]) {\n          node.type = 'media-type';\n          continue;\n        } // `screen and` or `#{...} (max-width: 10px)`\n\n\n        if (result[_i + 1] && (result[_i + 1].type === 'media-feature-expression' || result[_i + 1].type === 'keyword')) {\n          node.type = 'media-type';\n          continue;\n        }\n\n        if (result[_i + 2]) {\n          // `screen and (color) ...`\n          if (result[_i + 2].type === 'media-feature-expression') {\n            node.type = 'media-type';\n            result[_i + 1].type = 'keyword';\n            continue;\n          } // `only screen and ...`\n\n\n          if (result[_i + 2].type === 'keyword') {\n            node.type = 'keyword';\n            result[_i + 1].type = 'media-type';\n            continue;\n          }\n        }\n\n        if (result[_i + 3]) {\n          // `screen and (color) ...`\n          if (result[_i + 3].type === 'media-feature-expression') {\n            node.type = 'keyword';\n            result[_i + 1].type = 'media-type';\n            result[_i + 2].type = 'keyword';\n            continue;\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Parses a media query list. Takes a possible `url()` at the start into\r\n * account, and divides the list into media queries that are parsed separately\r\n *\r\n * @param {string} string - the source media query list string\r\n *\r\n * @return {Array} an array of Nodes/Containers\r\n */\n\n\nfunction parseMediaList(string) {\n  var result = [];\n  var interimIndex = 0;\n  var levelLocal = 0; // Check for a `url(...)` part (if it is contents of an @import rule)\n\n  var doesHaveUrl = /^(\\s*)url\\s*\\(/.exec(string);\n\n  if (doesHaveUrl !== null) {\n    var i = doesHaveUrl[0].length;\n    var parenthesesLv = 1;\n\n    while (parenthesesLv > 0) {\n      var character = string[i];\n\n      if (character === '(') {\n        parenthesesLv++;\n      }\n\n      if (character === ')') {\n        parenthesesLv--;\n      }\n\n      i++;\n    }\n\n    result.unshift(new _Node2.default({\n      type: 'url',\n      value: string.substring(0, i).trim(),\n      sourceIndex: doesHaveUrl[1].length,\n      before: doesHaveUrl[1],\n      after: /^(\\s*)/.exec(string.substring(i))[1]\n    }));\n    interimIndex = i;\n  } // Start processing the media query list\n\n\n  for (var _i2 = interimIndex; _i2 < string.length; _i2++) {\n    var _character = string[_i2]; // Dividing the media query list into comma-separated media queries\n    // Only count commas that are outside of any parens\n    // (i.e., not part of function call params list, etc.)\n\n    if (_character === '(') {\n      levelLocal++;\n    }\n\n    if (_character === ')') {\n      levelLocal--;\n    }\n\n    if (levelLocal === 0 && _character === ',') {\n      var _mediaQueryString = string.substring(interimIndex, _i2);\n\n      var _spaceBefore = /^(\\s*)/.exec(_mediaQueryString)[1];\n      result.push(new _Container2.default({\n        type: 'media-query',\n        value: _mediaQueryString.trim(),\n        sourceIndex: interimIndex + _spaceBefore.length,\n        nodes: parseMediaQuery(_mediaQueryString, interimIndex),\n        before: _spaceBefore,\n        after: /(\\s*)$/.exec(_mediaQueryString)[1]\n      }));\n      interimIndex = _i2 + 1;\n    }\n  }\n\n  var mediaQueryString = string.substring(interimIndex);\n  var spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1];\n  result.push(new _Container2.default({\n    type: 'media-query',\n    value: mediaQueryString.trim(),\n    sourceIndex: interimIndex + spaceBefore.length,\n    nodes: parseMediaQuery(mediaQueryString, interimIndex),\n    before: spaceBefore,\n    after: /(\\s*)$/.exec(mediaQueryString)[1]\n  }));\n  return result;\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/postcss-media-query-parser/dist/parsers.js"],"names":["Object","defineProperty","exports","value","parseMediaFeature","parseMediaQuery","parseMediaList","_Node","require","_Node2","_interopRequireDefault","_Container","_Container2","obj","__esModule","default","string","index","arguments","length","undefined","modesEntered","mode","character","result","lastModeIndex","mediaFeature","colon","mediaFeatureValue","indexLocal","stringNormalized","substring","i","isCalculationEnabled","push","pop","mediaFeatureValueStr","type","before","exec","after","trim","sourceIndex","localLevel","insideSomeValue","node","resetNode","search","indexOf","nodes","Array","isArray","_i","interimIndex","levelLocal","doesHaveUrl","parenthesesLv","unshift","_i2","_character","_mediaQueryString","_spaceBefore","mediaQueryString","spaceBefore"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseMediaFeature = parseMediaFeature;\nexports.parseMediaQuery = parseMediaQuery;\nexports.parseMediaList = parseMediaList;\n\nvar _Node = require('./nodes/Node');\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nvar _Container = require('./nodes/Container');\n\nvar _Container2 = _interopRequireDefault(_Container);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`\r\n *\r\n * @param {string} string - the source expression string, can be inside parens\r\n * @param {Number} index - the index of `string` in the overall input\r\n *\r\n * @return {Array} an array of Nodes, the first element being a media feature,\r\n *    the secont - its value (may be missing)\r\n */\n\nfunction parseMediaFeature(string) {\n  var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n  var modesEntered = [{\n    mode: 'normal',\n    character: null\n  }];\n  var result = [];\n  var lastModeIndex = 0;\n  var mediaFeature = '';\n  var colon = null;\n  var mediaFeatureValue = null;\n  var indexLocal = index;\n\n  var stringNormalized = string;\n  // Strip trailing parens (if any), and correct the starting index\n  if (string[0] === '(' && string[string.length - 1] === ')') {\n    stringNormalized = string.substring(1, string.length - 1);\n    indexLocal++;\n  }\n\n  for (var i = 0; i < stringNormalized.length; i++) {\n    var character = stringNormalized[i];\n\n    // If entering/exiting a string\n    if (character === '\\'' || character === '\"') {\n      if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n        modesEntered.push({\n          mode: 'string',\n          isCalculationEnabled: false,\n          character: character\n        });\n        lastModeIndex++;\n      } else if (modesEntered[lastModeIndex].mode === 'string' && modesEntered[lastModeIndex].character === character && stringNormalized[i - 1] !== '\\\\') {\n        modesEntered.pop();\n        lastModeIndex--;\n      }\n    }\n\n    // If entering/exiting interpolation\n    if (character === '{') {\n      modesEntered.push({\n        mode: 'interpolation',\n        isCalculationEnabled: true\n      });\n      lastModeIndex++;\n    } else if (character === '}') {\n      modesEntered.pop();\n      lastModeIndex--;\n    }\n\n    // If a : is met outside of a string, function call or interpolation, than\n    // this : separates a media feature and a value\n    if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {\n      var mediaFeatureValueStr = stringNormalized.substring(i + 1);\n      mediaFeatureValue = {\n        type: 'value',\n        before: /^(\\s*)/.exec(mediaFeatureValueStr)[1],\n        after: /(\\s*)$/.exec(mediaFeatureValueStr)[1],\n        value: mediaFeatureValueStr.trim()\n      };\n      // +1 for the colon\n      mediaFeatureValue.sourceIndex = mediaFeatureValue.before.length + i + 1 + indexLocal;\n      colon = {\n        type: 'colon',\n        sourceIndex: i + indexLocal,\n        after: mediaFeatureValue.before,\n        value: ':' };\n      break;\n    }\n\n    mediaFeature += character;\n  }\n\n  // Forming a media feature node\n  mediaFeature = {\n    type: 'media-feature',\n    before: /^(\\s*)/.exec(mediaFeature)[1],\n    after: /(\\s*)$/.exec(mediaFeature)[1],\n    value: mediaFeature.trim()\n  };\n  mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal;\n  result.push(mediaFeature);\n\n  if (colon !== null) {\n    colon.before = mediaFeature.after;\n    result.push(colon);\n  }\n\n  if (mediaFeatureValue !== null) {\n    result.push(mediaFeatureValue);\n  }\n\n  return result;\n}\n\n/**\r\n * Parses a media query, e.g. `screen and (color)`, `only tv`\r\n *\r\n * @param {string} string - the source media query string\r\n * @param {Number} index - the index of `string` in the overall input\r\n *\r\n * @return {Array} an array of Nodes and Containers\r\n */\n\nfunction parseMediaQuery(string) {\n  var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n  var result = [];\n\n  // How many timies the parser entered parens/curly braces\n  var localLevel = 0;\n  // Has any keyword, media type, media feature expression or interpolation\n  // ('element' hereafter) started\n  var insideSomeValue = false;\n  var node = void 0;\n\n  function resetNode() {\n    return {\n      before: '',\n      after: '',\n      value: ''\n    };\n  }\n\n  node = resetNode();\n\n  for (var i = 0; i < string.length; i++) {\n    var character = string[i];\n    // If not yet entered any element\n    if (!insideSomeValue) {\n      if (character.search(/\\s/) !== -1) {\n        // A whitespace\n        // Don't form 'after' yet; will do it later\n        node.before += character;\n      } else {\n        // Not a whitespace - entering an element\n        // Expression start\n        if (character === '(') {\n          node.type = 'media-feature-expression';\n          localLevel++;\n        }\n        node.value = character;\n        node.sourceIndex = index + i;\n        insideSomeValue = true;\n      }\n    } else {\n      // Already in the middle of some alement\n      node.value += character;\n\n      // Here parens just increase localLevel and don't trigger a start of\n      // a media feature expression (since they can't be nested)\n      // Interpolation start\n      if (character === '{' || character === '(') {\n        localLevel++;\n      }\n      // Interpolation/function call/media feature expression end\n      if (character === ')' || character === '}') {\n        localLevel--;\n      }\n    }\n\n    // If exited all parens/curlies and the next symbol\n    if (insideSomeValue && localLevel === 0 && (character === ')' || i === string.length - 1 || string[i + 1].search(/\\s/) !== -1)) {\n      if (['not', 'only', 'and'].indexOf(node.value) !== -1) {\n        node.type = 'keyword';\n      }\n      // if it's an expression, parse its contents\n      if (node.type === 'media-feature-expression') {\n        node.nodes = parseMediaFeature(node.value, node.sourceIndex);\n      }\n      result.push(Array.isArray(node.nodes) ? new _Container2.default(node) : new _Node2.default(node));\n      node = resetNode();\n      insideSomeValue = false;\n    }\n  }\n\n  // Now process the result array - to specify undefined types of the nodes\n  // and specify the `after` prop\n  for (var _i = 0; _i < result.length; _i++) {\n    node = result[_i];\n    if (_i > 0) {\n      result[_i - 1].after = node.before;\n    }\n\n    // Node types. Might not be set because contains interpolation/function\n    // calls or fully consists of them\n    if (node.type === undefined) {\n      if (_i > 0) {\n        // only `and` can follow an expression\n        if (result[_i - 1].type === 'media-feature-expression') {\n          node.type = 'keyword';\n          continue;\n        }\n        // Anything after 'only|not' is a media type\n        if (result[_i - 1].value === 'not' || result[_i - 1].value === 'only') {\n          node.type = 'media-type';\n          continue;\n        }\n        // Anything after 'and' is an expression\n        if (result[_i - 1].value === 'and') {\n          node.type = 'media-feature-expression';\n          continue;\n        }\n\n        if (result[_i - 1].type === 'media-type') {\n          // if it is the last element - it might be an expression\n          // or 'and' depending on what is after it\n          if (!result[_i + 1]) {\n            node.type = 'media-feature-expression';\n          } else {\n            node.type = result[_i + 1].type === 'media-feature-expression' ? 'keyword' : 'media-feature-expression';\n          }\n        }\n      }\n\n      if (_i === 0) {\n        // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then\n        // its type would have been set by now\n        if (!result[_i + 1]) {\n          node.type = 'media-type';\n          continue;\n        }\n\n        // `screen and` or `#{...} (max-width: 10px)`\n        if (result[_i + 1] && (result[_i + 1].type === 'media-feature-expression' || result[_i + 1].type === 'keyword')) {\n          node.type = 'media-type';\n          continue;\n        }\n        if (result[_i + 2]) {\n          // `screen and (color) ...`\n          if (result[_i + 2].type === 'media-feature-expression') {\n            node.type = 'media-type';\n            result[_i + 1].type = 'keyword';\n            continue;\n          }\n          // `only screen and ...`\n          if (result[_i + 2].type === 'keyword') {\n            node.type = 'keyword';\n            result[_i + 1].type = 'media-type';\n            continue;\n          }\n        }\n        if (result[_i + 3]) {\n          // `screen and (color) ...`\n          if (result[_i + 3].type === 'media-feature-expression') {\n            node.type = 'keyword';\n            result[_i + 1].type = 'media-type';\n            result[_i + 2].type = 'keyword';\n            continue;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n\n/**\r\n * Parses a media query list. Takes a possible `url()` at the start into\r\n * account, and divides the list into media queries that are parsed separately\r\n *\r\n * @param {string} string - the source media query list string\r\n *\r\n * @return {Array} an array of Nodes/Containers\r\n */\n\nfunction parseMediaList(string) {\n  var result = [];\n  var interimIndex = 0;\n  var levelLocal = 0;\n\n  // Check for a `url(...)` part (if it is contents of an @import rule)\n  var doesHaveUrl = /^(\\s*)url\\s*\\(/.exec(string);\n  if (doesHaveUrl !== null) {\n    var i = doesHaveUrl[0].length;\n    var parenthesesLv = 1;\n    while (parenthesesLv > 0) {\n      var character = string[i];\n      if (character === '(') {\n        parenthesesLv++;\n      }\n      if (character === ')') {\n        parenthesesLv--;\n      }\n      i++;\n    }\n    result.unshift(new _Node2.default({\n      type: 'url',\n      value: string.substring(0, i).trim(),\n      sourceIndex: doesHaveUrl[1].length,\n      before: doesHaveUrl[1],\n      after: /^(\\s*)/.exec(string.substring(i))[1]\n    }));\n    interimIndex = i;\n  }\n\n  // Start processing the media query list\n  for (var _i2 = interimIndex; _i2 < string.length; _i2++) {\n    var _character = string[_i2];\n\n    // Dividing the media query list into comma-separated media queries\n    // Only count commas that are outside of any parens\n    // (i.e., not part of function call params list, etc.)\n    if (_character === '(') {\n      levelLocal++;\n    }\n    if (_character === ')') {\n      levelLocal--;\n    }\n    if (levelLocal === 0 && _character === ',') {\n      var _mediaQueryString = string.substring(interimIndex, _i2);\n      var _spaceBefore = /^(\\s*)/.exec(_mediaQueryString)[1];\n      result.push(new _Container2.default({\n        type: 'media-query',\n        value: _mediaQueryString.trim(),\n        sourceIndex: interimIndex + _spaceBefore.length,\n        nodes: parseMediaQuery(_mediaQueryString, interimIndex),\n        before: _spaceBefore,\n        after: /(\\s*)$/.exec(_mediaQueryString)[1]\n      }));\n      interimIndex = _i2 + 1;\n    }\n  }\n\n  var mediaQueryString = string.substring(interimIndex);\n  var spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1];\n  result.push(new _Container2.default({\n    type: 'media-query',\n    value: mediaQueryString.trim(),\n    sourceIndex: interimIndex + spaceBefore.length,\n    nodes: parseMediaQuery(mediaQueryString, interimIndex),\n    before: spaceBefore,\n    after: /(\\s*)$/.exec(mediaQueryString)[1]\n  }));\n\n  return result;\n}"]},"metadata":{},"sourceType":"script"}