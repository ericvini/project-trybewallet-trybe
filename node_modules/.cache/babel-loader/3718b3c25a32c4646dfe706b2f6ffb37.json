{"ast":null,"code":"'use strict';\n\nconst {\n  isRoot,\n  isAtRule,\n  isRule\n} = require('./typeGuards');\n/** @typedef {import('postcss').Root} Root */\n\n/** @typedef {import('postcss').Root} Document */\n\n/** @typedef {import('postcss').Node} PostcssNode */\n\n/** @typedef {import('postcss').ContainerBase} PostcssContainerNode */\n\n/**\n * @param {PostcssNode} node\n * @returns {node is PostcssContainerNode}\n */\n\n\nfunction isContainerNode(node) {\n  return isRule(node) || isAtRule(node) || isRoot(node);\n}\n/**\n * In order to accommodate nested blocks (postcss-nested),\n * we need to run a shallow loop (instead of eachDecl() or eachRule(),\n * which loop recursively) and allow each nested block to accumulate\n * its own list of properties -- so that a property in a nested rule\n * does not conflict with the same property in the parent rule\n * executes a provided function once for each declaration block.\n *\n * @param {Root | Document} root - root element of file.\n * @param {function} cb - Function to execute for each declaration block\n *\n * @returns {void}\n */\n\n\nmodule.exports = function (root, cb) {\n  /**\n   * @param {PostcssNode} statement\n   *\n   * @returns {void}\n   */\n  function each(statement) {\n    if (!isContainerNode(statement)) return;\n\n    if (statement.nodes && statement.nodes.length) {\n      /** @type {PostcssNode[]} */\n      const decls = [];\n      statement.nodes.forEach(node => {\n        if (node.type === 'decl') {\n          decls.push(node);\n        }\n\n        each(node);\n      });\n\n      if (decls.length) {\n        cb(decls.forEach.bind(decls));\n      }\n    }\n  }\n\n  each(root);\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/eachDeclarationBlock.js"],"names":["isRoot","isAtRule","isRule","require","isContainerNode","node","module","exports","root","cb","each","statement","nodes","length","decls","forEach","type","push","bind"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA,MAAF;AAAUC,EAAAA,QAAV;AAAoBC,EAAAA;AAApB,IAA+BC,OAAO,CAAC,cAAD,CAA5C;AAEA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAC9B,SAAOH,MAAM,CAACG,IAAD,CAAN,IAAgBJ,QAAQ,CAACI,IAAD,CAAxB,IAAkCL,MAAM,CAACK,IAAD,CAA/C;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,IAAV,EAAgBC,EAAhB,EAAoB;AACpC;AACD;AACA;AACA;AACA;AACC,WAASC,IAAT,CAAcC,SAAd,EAAyB;AACxB,QAAI,CAACP,eAAe,CAACO,SAAD,CAApB,EAAiC;;AAEjC,QAAIA,SAAS,CAACC,KAAV,IAAmBD,SAAS,CAACC,KAAV,CAAgBC,MAAvC,EAA+C;AAC9C;AACA,YAAMC,KAAK,GAAG,EAAd;AAEAH,MAAAA,SAAS,CAACC,KAAV,CAAgBG,OAAhB,CAAyBV,IAAD,IAAU;AACjC,YAAIA,IAAI,CAACW,IAAL,KAAc,MAAlB,EAA0B;AACzBF,UAAAA,KAAK,CAACG,IAAN,CAAWZ,IAAX;AACA;;AAEDK,QAAAA,IAAI,CAACL,IAAD,CAAJ;AACA,OAND;;AAQA,UAAIS,KAAK,CAACD,MAAV,EAAkB;AACjBJ,QAAAA,EAAE,CAACK,KAAK,CAACC,OAAN,CAAcG,IAAd,CAAmBJ,KAAnB,CAAD,CAAF;AACA;AACD;AACD;;AAEDJ,EAAAA,IAAI,CAACF,IAAD,CAAJ;AACA,CA5BD","sourcesContent":["'use strict';\n\nconst { isRoot, isAtRule, isRule } = require('./typeGuards');\n\n/** @typedef {import('postcss').Root} Root */\n/** @typedef {import('postcss').Root} Document */\n/** @typedef {import('postcss').Node} PostcssNode */\n/** @typedef {import('postcss').ContainerBase} PostcssContainerNode */\n\n/**\n * @param {PostcssNode} node\n * @returns {node is PostcssContainerNode}\n */\nfunction isContainerNode(node) {\n\treturn isRule(node) || isAtRule(node) || isRoot(node);\n}\n\n/**\n * In order to accommodate nested blocks (postcss-nested),\n * we need to run a shallow loop (instead of eachDecl() or eachRule(),\n * which loop recursively) and allow each nested block to accumulate\n * its own list of properties -- so that a property in a nested rule\n * does not conflict with the same property in the parent rule\n * executes a provided function once for each declaration block.\n *\n * @param {Root | Document} root - root element of file.\n * @param {function} cb - Function to execute for each declaration block\n *\n * @returns {void}\n */\nmodule.exports = function (root, cb) {\n\t/**\n\t * @param {PostcssNode} statement\n\t *\n\t * @returns {void}\n\t */\n\tfunction each(statement) {\n\t\tif (!isContainerNode(statement)) return;\n\n\t\tif (statement.nodes && statement.nodes.length) {\n\t\t\t/** @type {PostcssNode[]} */\n\t\t\tconst decls = [];\n\n\t\t\tstatement.nodes.forEach((node) => {\n\t\t\t\tif (node.type === 'decl') {\n\t\t\t\t\tdecls.push(node);\n\t\t\t\t}\n\n\t\t\t\teach(node);\n\t\t\t});\n\n\t\t\tif (decls.length) {\n\t\t\t\tcb(decls.forEach.bind(decls));\n\t\t\t}\n\t\t}\n\t}\n\n\teach(root);\n};\n"]},"metadata":{},"sourceType":"script"}