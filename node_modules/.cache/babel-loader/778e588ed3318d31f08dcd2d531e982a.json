{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\n\nconst findMediaOperator = require('../findMediaOperator');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'media-feature-range-operator-space-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected single space after range operator',\n  rejectedAfter: () => 'Unexpected whitespace after range operator'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('space', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      const fixOperatorIndices = [];\n      const fix = context.fix ? index => fixOperatorIndices.push(index) : null;\n      findMediaOperator(atRule, (match, params, node) => {\n        checkAfterOperator(match, params, node, fix);\n      });\n\n      if (fixOperatorIndices.length) {\n        let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;\n        fixOperatorIndices.sort((a, b) => b - a).forEach(index => {\n          const beforeOperator = params.slice(0, index + 1);\n          const afterOperator = params.slice(index + 1);\n\n          if (expectation === 'always') {\n            params = beforeOperator + afterOperator.replace(/^\\s*/, ' ');\n          } else if (expectation === 'never') {\n            params = beforeOperator + afterOperator.replace(/^\\s*/, '');\n          }\n        });\n\n        if (atRule.raws.params) {\n          atRule.raws.params.raw = params;\n        } else {\n          atRule.params = params;\n        }\n      }\n    });\n\n    function checkAfterOperator(match, params, node, fix) {\n      const endIndex = match.startIndex + match.target.length - 1;\n      checker.after({\n        source: params,\n        index: endIndex,\n        err: m => {\n          if (fix) {\n            fix(endIndex);\n            return;\n          }\n\n          report({\n            message: m,\n            node,\n            index: endIndex + atRuleParamIndex(node) + 1,\n            result,\n            ruleName\n          });\n        }\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/media-feature-range-operator-space-after/index.js"],"names":["atRuleParamIndex","require","findMediaOperator","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","rejectedAfter","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","walkAtRules","atRule","fixOperatorIndices","fix","index","push","match","params","node","checkAfterOperator","length","raws","raw","sort","a","b","forEach","beforeOperator","slice","afterOperator","replace","endIndex","startIndex","target","after","source","err","m","message","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\nconst findMediaOperator = require('../findMediaOperator');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'media-feature-range-operator-space-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected single space after range operator',\n\trejectedAfter: () => 'Unexpected whitespace after range operator',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('space', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkAtRules(/^media$/i, (atRule) => {\n\t\t\tconst fixOperatorIndices = [];\n\t\t\tconst fix = context.fix ? (index) => fixOperatorIndices.push(index) : null;\n\n\t\t\tfindMediaOperator(atRule, (match, params, node) => {\n\t\t\t\tcheckAfterOperator(match, params, node, fix);\n\t\t\t});\n\n\t\t\tif (fixOperatorIndices.length) {\n\t\t\t\tlet params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;\n\n\t\t\t\tfixOperatorIndices\n\t\t\t\t\t.sort((a, b) => b - a)\n\t\t\t\t\t.forEach((index) => {\n\t\t\t\t\t\tconst beforeOperator = params.slice(0, index + 1);\n\t\t\t\t\t\tconst afterOperator = params.slice(index + 1);\n\n\t\t\t\t\t\tif (expectation === 'always') {\n\t\t\t\t\t\t\tparams = beforeOperator + afterOperator.replace(/^\\s*/, ' ');\n\t\t\t\t\t\t} else if (expectation === 'never') {\n\t\t\t\t\t\t\tparams = beforeOperator + afterOperator.replace(/^\\s*/, '');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\tif (atRule.raws.params) {\n\t\t\t\t\tatRule.raws.params.raw = params;\n\t\t\t\t} else {\n\t\t\t\t\tatRule.params = params;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfunction checkAfterOperator(match, params, node, fix) {\n\t\t\tconst endIndex = match.startIndex + match.target.length - 1;\n\n\t\t\tchecker.after({\n\t\t\t\tsource: params,\n\t\t\t\tindex: endIndex,\n\t\t\t\terr: (m) => {\n\t\t\t\t\tif (fix) {\n\t\t\t\t\t\tfix(endIndex);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tindex: endIndex + atRuleParamIndex(node) + 1,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}