{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst blockString = require('../../utils/blockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'block-closing-brace-newline-before';\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: 'Expected newline before \"}\"',\n  expectedBeforeMultiLine: 'Expected newline before \"}\" of a multi-line block',\n  rejectedBeforeMultiLine: 'Unexpected whitespace before \"}\" of a multi-line block'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    } // Check both kinds of statements: rules and at-rules\n\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      // Return early if blockless or has empty block\n      if (!hasBlock(statement) || hasEmptyBlock(statement)) {\n        return;\n      } // Ignore extra semicolon\n\n\n      const after = (statement.raws.after || '').replace(/;+/, '');\n\n      if (after === undefined) {\n        return;\n      }\n\n      const blockIsMultiLine = !isSingleLineString(blockString(statement));\n      const statementString = statement.toString();\n      let index = statementString.length - 2;\n\n      if (statementString[index - 1] === '\\r') {\n        index -= 1;\n      } // We're really just checking whether a\n      // newline *starts* the block's final space -- between\n      // the last declaration and the closing brace. We can\n      // ignore any other whitespace between them, because that\n      // will be checked by the indentation rule.\n\n\n      if (!after.startsWith('\\n') && !after.startsWith('\\r\\n')) {\n        if (expectation === 'always') {\n          complain(messages.expectedBefore);\n        } else if (blockIsMultiLine && expectation === 'always-multi-line') {\n          complain(messages.expectedBeforeMultiLine);\n        }\n      }\n\n      if (after !== '' && blockIsMultiLine && expectation === 'never-multi-line') {\n        complain(messages.rejectedBeforeMultiLine);\n      }\n\n      function complain(message) {\n        if (context.fix) {\n          if (expectation.startsWith('always')) {\n            const firstWhitespaceIndex = statement.raws.after.search(/\\s/);\n            const newlineBefore = firstWhitespaceIndex >= 0 ? statement.raws.after.slice(0, firstWhitespaceIndex) : statement.raws.after;\n            const newlineAfter = firstWhitespaceIndex >= 0 ? statement.raws.after.slice(firstWhitespaceIndex) : '';\n            const newlineIndex = newlineAfter.search(/\\r?\\n/);\n\n            if (newlineIndex >= 0) {\n              statement.raws.after = newlineBefore + newlineAfter.slice(newlineIndex);\n            } else {\n              statement.raws.after = newlineBefore + context.newline + newlineAfter;\n            }\n\n            return;\n          }\n\n          if (expectation === 'never-multi-line') {\n            statement.raws.after = statement.raws.after.replace(/\\s/g, '');\n            return;\n          }\n        }\n\n        report({\n          message,\n          result,\n          ruleName,\n          node: statement,\n          index\n        });\n      }\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-closing-brace-newline-before/index.js"],"names":["blockString","require","hasBlock","hasEmptyBlock","isSingleLineString","report","ruleMessages","validateOptions","ruleName","messages","expectedBefore","expectedBeforeMultiLine","rejectedBeforeMultiLine","rule","expectation","options","context","root","result","validOptions","actual","possible","walkRules","check","walkAtRules","statement","after","raws","replace","undefined","blockIsMultiLine","statementString","toString","index","length","startsWith","complain","message","fix","firstWhitespaceIndex","search","newlineBefore","slice","newlineAfter","newlineIndex","newline","node","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst blockString = require('../../utils/blockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'block-closing-brace-newline-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedBefore: 'Expected newline before \"}\"',\n\texpectedBeforeMultiLine: 'Expected newline before \"}\" of a multi-line block',\n\trejectedBeforeMultiLine: 'Unexpected whitespace before \"}\" of a multi-line block',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check both kinds of statements: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\t// Return early if blockless or has empty block\n\t\t\tif (!hasBlock(statement) || hasEmptyBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore extra semicolon\n\t\t\tconst after = (statement.raws.after || '').replace(/;+/, '');\n\n\t\t\tif (after === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst blockIsMultiLine = !isSingleLineString(blockString(statement));\n\t\t\tconst statementString = statement.toString();\n\n\t\t\tlet index = statementString.length - 2;\n\n\t\t\tif (statementString[index - 1] === '\\r') {\n\t\t\t\tindex -= 1;\n\t\t\t}\n\n\t\t\t// We're really just checking whether a\n\t\t\t// newline *starts* the block's final space -- between\n\t\t\t// the last declaration and the closing brace. We can\n\t\t\t// ignore any other whitespace between them, because that\n\t\t\t// will be checked by the indentation rule.\n\t\t\tif (!after.startsWith('\\n') && !after.startsWith('\\r\\n')) {\n\t\t\t\tif (expectation === 'always') {\n\t\t\t\t\tcomplain(messages.expectedBefore);\n\t\t\t\t} else if (blockIsMultiLine && expectation === 'always-multi-line') {\n\t\t\t\t\tcomplain(messages.expectedBeforeMultiLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (after !== '' && blockIsMultiLine && expectation === 'never-multi-line') {\n\t\t\t\tcomplain(messages.rejectedBeforeMultiLine);\n\t\t\t}\n\n\t\t\tfunction complain(message) {\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\tconst firstWhitespaceIndex = statement.raws.after.search(/\\s/);\n\t\t\t\t\t\tconst newlineBefore =\n\t\t\t\t\t\t\tfirstWhitespaceIndex >= 0\n\t\t\t\t\t\t\t\t? statement.raws.after.slice(0, firstWhitespaceIndex)\n\t\t\t\t\t\t\t\t: statement.raws.after;\n\t\t\t\t\t\tconst newlineAfter =\n\t\t\t\t\t\t\tfirstWhitespaceIndex >= 0 ? statement.raws.after.slice(firstWhitespaceIndex) : '';\n\t\t\t\t\t\tconst newlineIndex = newlineAfter.search(/\\r?\\n/);\n\n\t\t\t\t\t\tif (newlineIndex >= 0) {\n\t\t\t\t\t\t\tstatement.raws.after = newlineBefore + newlineAfter.slice(newlineIndex);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatement.raws.after = newlineBefore + context.newline + newlineAfter;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (expectation === 'never-multi-line') {\n\t\t\t\t\t\tstatement.raws.after = statement.raws.after.replace(/\\s/g, '');\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t\tnode: statement,\n\t\t\t\t\tindex,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}