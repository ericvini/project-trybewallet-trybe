{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst parseSelector = require('../../utils/parseSelector');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-attribute-brackets-space-inside';\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: 'Expected single space after \"[\"',\n  rejectedOpening: 'Unexpected whitespace after \"[\"',\n  expectedClosing: 'Expected single space before \"]\"',\n  rejectedClosing: 'Unexpected whitespace before \"]\"'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    });\n\n    if (!validOptions) {\n      return;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      }\n\n      if (!rule.selector.includes('[')) {\n        return;\n      }\n\n      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n      let hasFixed;\n      const fixedSelector = parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkAttributes(attributeNode => {\n          const attributeSelectorString = attributeNode.toString();\n          styleSearch({\n            source: attributeSelectorString,\n            target: '['\n          }, match => {\n            const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === ' ';\n            const index = attributeNode.sourceIndex + match.startIndex + 1;\n\n            if (nextCharIsSpace && expectation === 'never') {\n              if (context.fix) {\n                hasFixed = true;\n                fixBefore(attributeNode);\n                return;\n              }\n\n              complain(messages.rejectedOpening, index);\n            }\n\n            if (!nextCharIsSpace && expectation === 'always') {\n              if (context.fix) {\n                hasFixed = true;\n                fixBefore(attributeNode);\n                return;\n              }\n\n              complain(messages.expectedOpening, index);\n            }\n          });\n          styleSearch({\n            source: attributeSelectorString,\n            target: ']'\n          }, match => {\n            const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === ' ';\n            const index = attributeNode.sourceIndex + match.startIndex - 1;\n\n            if (prevCharIsSpace && expectation === 'never') {\n              if (context.fix) {\n                hasFixed = true;\n                fixAfter(attributeNode);\n                return;\n              }\n\n              complain(messages.rejectedClosing, index);\n            }\n\n            if (!prevCharIsSpace && expectation === 'always') {\n              if (context.fix) {\n                hasFixed = true;\n                fixAfter(attributeNode);\n                return;\n              }\n\n              complain(messages.expectedClosing, index);\n            }\n          });\n        });\n      });\n\n      if (hasFixed) {\n        if (!rule.raws.selector) {\n          rule.selector = fixedSelector;\n        } else {\n          rule.raws.selector.raw = fixedSelector;\n        }\n      }\n\n      function complain(message, index) {\n        report({\n          message,\n          index,\n          result,\n          ruleName,\n          node: rule\n        });\n      }\n    });\n  };\n\n  function fixBefore(attributeNode) {\n    const rawAttrBefore = _.get(attributeNode, 'raws.spaces.attribute.before');\n\n    const {\n      attrBefore,\n      setAttrBefore\n    } = rawAttrBefore ? {\n      attrBefore: rawAttrBefore,\n\n      setAttrBefore(fixed) {\n        attributeNode.raws.spaces.attribute.before = fixed;\n      }\n\n    } : {\n      attrBefore: _.get(attributeNode, 'spaces.attribute.before', ''),\n\n      setAttrBefore(fixed) {\n        _.set(attributeNode, 'spaces.attribute.before', fixed);\n      }\n\n    };\n\n    if (expectation === 'always') {\n      setAttrBefore(attrBefore.replace(/^\\s*/, ' '));\n    } else if (expectation === 'never') {\n      setAttrBefore(attrBefore.replace(/^\\s*/, ''));\n    }\n  }\n\n  function fixAfter(attributeNode) {\n    let key;\n\n    if (attributeNode.operator) {\n      if (attributeNode.insensitive) {\n        key = 'insensitive';\n      } else {\n        key = 'value';\n      }\n    } else {\n      key = 'attribute';\n    }\n\n    const rawAfter = _.get(attributeNode, `raws.spaces.${key}.after`);\n\n    const {\n      after,\n      setAfter\n    } = rawAfter ? {\n      after: rawAfter,\n\n      setAfter(fixed) {\n        attributeNode.raws.spaces[key].after = fixed;\n      }\n\n    } : {\n      after: _.get(attributeNode, `spaces.${key}.after`, ''),\n\n      setAfter(fixed) {\n        _.set(attributeNode, `spaces.${key}.after`, fixed);\n      }\n\n    };\n\n    if (expectation === 'always') {\n      setAfter(after.replace(/\\s*$/, ' '));\n    } else if (expectation === 'never') {\n      setAfter(after.replace(/\\s*$/, ''));\n    }\n  }\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-attribute-brackets-space-inside/index.js"],"names":["_","require","isStandardSyntaxRule","parseSelector","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","expectedOpening","rejectedOpening","expectedClosing","rejectedClosing","rule","expectation","options","context","root","result","validOptions","actual","possible","walkRules","selector","includes","raws","raw","hasFixed","fixedSelector","selectorTree","walkAttributes","attributeNode","attributeSelectorString","toString","source","target","match","nextCharIsSpace","startIndex","index","sourceIndex","fix","fixBefore","complain","prevCharIsSpace","fixAfter","message","node","rawAttrBefore","get","attrBefore","setAttrBefore","fixed","spaces","attribute","before","set","replace","key","operator","insensitive","rawAfter","after","setAfter","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst parseSelector = require('../../utils/parseSelector');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-attribute-brackets-space-inside';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedOpening: 'Expected single space after \"[\"',\n\trejectedOpening: 'Unexpected whitespace after \"[\"',\n\texpectedClosing: 'Expected single space before \"]\"',\n\trejectedClosing: 'Unexpected whitespace before \"]\"',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!rule.selector.includes('[')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\n\t\t\tlet hasFixed;\n\t\t\tconst fixedSelector = parseSelector(selector, result, rule, (selectorTree) => {\n\t\t\t\tselectorTree.walkAttributes((attributeNode) => {\n\t\t\t\t\tconst attributeSelectorString = attributeNode.toString();\n\n\t\t\t\t\tstyleSearch({ source: attributeSelectorString, target: '[' }, (match) => {\n\t\t\t\t\t\tconst nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === ' ';\n\t\t\t\t\t\tconst index = attributeNode.sourceIndex + match.startIndex + 1;\n\n\t\t\t\t\t\tif (nextCharIsSpace && expectation === 'never') {\n\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\t\tfixBefore(attributeNode);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcomplain(messages.rejectedOpening, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!nextCharIsSpace && expectation === 'always') {\n\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\t\tfixBefore(attributeNode);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcomplain(messages.expectedOpening, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstyleSearch({ source: attributeSelectorString, target: ']' }, (match) => {\n\t\t\t\t\t\tconst prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === ' ';\n\t\t\t\t\t\tconst index = attributeNode.sourceIndex + match.startIndex - 1;\n\n\t\t\t\t\t\tif (prevCharIsSpace && expectation === 'never') {\n\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\t\tfixAfter(attributeNode);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcomplain(messages.rejectedClosing, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!prevCharIsSpace && expectation === 'always') {\n\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\t\t\tfixAfter(attributeNode);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcomplain(messages.expectedClosing, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (hasFixed) {\n\t\t\t\tif (!rule.raws.selector) {\n\t\t\t\t\trule.selector = fixedSelector;\n\t\t\t\t} else {\n\t\t\t\t\trule.raws.selector.raw = fixedSelector;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction complain(message, index) {\n\t\t\t\treport({\n\t\t\t\t\tmessage,\n\t\t\t\t\tindex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t\tnode: rule,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\tfunction fixBefore(attributeNode) {\n\t\tconst rawAttrBefore = _.get(attributeNode, 'raws.spaces.attribute.before');\n\t\tconst { attrBefore, setAttrBefore } = rawAttrBefore\n\t\t\t? {\n\t\t\t\t\tattrBefore: rawAttrBefore,\n\t\t\t\t\tsetAttrBefore(fixed) {\n\t\t\t\t\t\tattributeNode.raws.spaces.attribute.before = fixed;\n\t\t\t\t\t},\n\t\t\t  }\n\t\t\t: {\n\t\t\t\t\tattrBefore: _.get(attributeNode, 'spaces.attribute.before', ''),\n\t\t\t\t\tsetAttrBefore(fixed) {\n\t\t\t\t\t\t_.set(attributeNode, 'spaces.attribute.before', fixed);\n\t\t\t\t\t},\n\t\t\t  };\n\n\t\tif (expectation === 'always') {\n\t\t\tsetAttrBefore(attrBefore.replace(/^\\s*/, ' '));\n\t\t} else if (expectation === 'never') {\n\t\t\tsetAttrBefore(attrBefore.replace(/^\\s*/, ''));\n\t\t}\n\t}\n\n\tfunction fixAfter(attributeNode) {\n\t\tlet key;\n\n\t\tif (attributeNode.operator) {\n\t\t\tif (attributeNode.insensitive) {\n\t\t\t\tkey = 'insensitive';\n\t\t\t} else {\n\t\t\t\tkey = 'value';\n\t\t\t}\n\t\t} else {\n\t\t\tkey = 'attribute';\n\t\t}\n\n\t\tconst rawAfter = _.get(attributeNode, `raws.spaces.${key}.after`);\n\t\tconst { after, setAfter } = rawAfter\n\t\t\t? {\n\t\t\t\t\tafter: rawAfter,\n\t\t\t\t\tsetAfter(fixed) {\n\t\t\t\t\t\tattributeNode.raws.spaces[key].after = fixed;\n\t\t\t\t\t},\n\t\t\t  }\n\t\t\t: {\n\t\t\t\t\tafter: _.get(attributeNode, `spaces.${key}.after`, ''),\n\t\t\t\t\tsetAfter(fixed) {\n\t\t\t\t\t\t_.set(attributeNode, `spaces.${key}.after`, fixed);\n\t\t\t\t\t},\n\t\t\t  };\n\n\t\tif (expectation === 'always') {\n\t\t\tsetAfter(after.replace(/\\s*$/, ' '));\n\t\t} else if (expectation === 'never') {\n\t\t\tsetAfter(after.replace(/\\s*$/, ''));\n\t\t}\n\t}\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}