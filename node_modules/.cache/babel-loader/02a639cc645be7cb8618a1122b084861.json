{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst beforeBlockString = require('../../utils/beforeBlockString');\n\nconst blockString = require('../../utils/blockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-opening-brace-space-before';\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => 'Expected single space before \"{\"',\n  rejectedBefore: () => 'Unexpected whitespace before \"{\"',\n  expectedBeforeSingleLine: () => 'Expected single space before \"{\" of a single-line block',\n  rejectedBeforeSingleLine: () => 'Unexpected whitespace before \"{\" of a single-line block',\n  expectedBeforeMultiLine: () => 'Expected single space before \"{\" of a multi-line block',\n  rejectedBeforeMultiLine: () => 'Unexpected whitespace before \"{\" of a multi-line block'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('space', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']\n    }, {\n      actual: options,\n      possible: {\n        ignoreAtRules: [_.isString, _.isRegExp],\n        ignoreSelectors: [_.isString, _.isRegExp]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    } // Check both kinds of statements: rules and at-rules\n\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      // Return early if blockless or has an empty block\n      if (!hasBlock(statement) || hasEmptyBlock(statement)) {\n        return;\n      } // Return early if at-rule is to be ignored\n\n\n      if (optionsMatches(options, 'ignoreAtRules', statement.name)) {\n        return;\n      } // Return early if selector is to be ignored\n\n\n      if (optionsMatches(options, 'ignoreSelectors', statement.selector)) {\n        return;\n      }\n\n      const source = beforeBlockString(statement);\n      const beforeBraceNoRaw = beforeBlockString(statement, {\n        noRawBefore: true\n      });\n      let index = beforeBraceNoRaw.length - 1;\n\n      if (beforeBraceNoRaw[index - 1] === '\\r') {\n        index -= 1;\n      }\n\n      checker.before({\n        source,\n        index: source.length,\n        lineCheckStr: blockString(statement),\n        err: m => {\n          if (context.fix) {\n            if (expectation.startsWith('always')) {\n              statement.raws.between = ' ';\n              return;\n            }\n\n            if (expectation.startsWith('never')) {\n              statement.raws.between = '';\n              return;\n            }\n          }\n\n          report({\n            message: m,\n            node: statement,\n            index,\n            result,\n            ruleName\n          });\n        }\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-opening-brace-space-before/index.js"],"names":["_","require","beforeBlockString","blockString","hasBlock","hasEmptyBlock","optionsMatches","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedBefore","rejectedBefore","expectedBeforeSingleLine","rejectedBeforeSingleLine","expectedBeforeMultiLine","rejectedBeforeMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","ignoreAtRules","isString","isRegExp","ignoreSelectors","optional","walkRules","check","walkAtRules","statement","name","selector","source","beforeBraceNoRaw","noRawBefore","index","length","before","lineCheckStr","err","m","fix","startsWith","raws","between","message","node","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst beforeBlockString = require('../../utils/beforeBlockString');\nconst blockString = require('../../utils/blockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst hasEmptyBlock = require('../../utils/hasEmptyBlock');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-opening-brace-space-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedBefore: () => 'Expected single space before \"{\"',\n\trejectedBefore: () => 'Unexpected whitespace before \"{\"',\n\texpectedBeforeSingleLine: () => 'Expected single space before \"{\" of a single-line block',\n\trejectedBeforeSingleLine: () => 'Unexpected whitespace before \"{\" of a single-line block',\n\texpectedBeforeMultiLine: () => 'Expected single space before \"{\" of a multi-line block',\n\trejectedBeforeMultiLine: () => 'Unexpected whitespace before \"{\" of a multi-line block',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('space', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: [\n\t\t\t\t\t'always',\n\t\t\t\t\t'never',\n\t\t\t\t\t'always-single-line',\n\t\t\t\t\t'never-single-line',\n\t\t\t\t\t'always-multi-line',\n\t\t\t\t\t'never-multi-line',\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignoreAtRules: [_.isString, _.isRegExp],\n\t\t\t\t\tignoreSelectors: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check both kinds of statements: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\t// Return early if blockless or has an empty block\n\t\t\tif (!hasBlock(statement) || hasEmptyBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return early if at-rule is to be ignored\n\t\t\tif (optionsMatches(options, 'ignoreAtRules', statement.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return early if selector is to be ignored\n\t\t\tif (optionsMatches(options, 'ignoreSelectors', statement.selector)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst source = beforeBlockString(statement);\n\t\t\tconst beforeBraceNoRaw = beforeBlockString(statement, {\n\t\t\t\tnoRawBefore: true,\n\t\t\t});\n\n\t\t\tlet index = beforeBraceNoRaw.length - 1;\n\n\t\t\tif (beforeBraceNoRaw[index - 1] === '\\r') {\n\t\t\t\tindex -= 1;\n\t\t\t}\n\n\t\t\tchecker.before({\n\t\t\t\tsource,\n\t\t\t\tindex: source.length,\n\t\t\t\tlineCheckStr: blockString(statement),\n\t\t\t\terr: (m) => {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tstatement.raws.between = ' ';\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expectation.startsWith('never')) {\n\t\t\t\t\t\t\tstatement.raws.between = '';\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: m,\n\t\t\t\t\t\tnode: statement,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}