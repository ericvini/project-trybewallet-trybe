{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-parentheses-newline-inside';\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: 'Expected newline after \"(\"',\n  expectedClosing: 'Expected newline before \")\"',\n  expectedOpeningMultiLine: 'Expected newline after \"(\" in a multi-line function',\n  rejectedOpeningMultiLine: 'Unexpected whitespace after \"(\" in a multi-line function',\n  expectedClosingMultiLine: 'Expected newline before \")\" in a multi-line function',\n  rejectedClosingMultiLine: 'Unexpected whitespace before \")\" in a multi-line function'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      if (!decl.value.includes('(')) {\n        return;\n      }\n\n      let hasFixed = false;\n\n      const declValue = _.get(decl, 'raws.value.raw', decl.value);\n\n      const parsedValue = valueParser(declValue);\n      parsedValue.walk(valueNode => {\n        if (valueNode.type !== 'function') {\n          return;\n        }\n\n        if (!isStandardSyntaxFunction(valueNode)) {\n          return;\n        }\n\n        const functionString = valueParser.stringify(valueNode);\n        const isMultiLine = !isSingleLineString(functionString);\n\n        function containsNewline(str) {\n          return str.includes('\\n');\n        } // Check opening ...\n\n\n        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;\n        const checkBefore = getCheckBefore(valueNode);\n\n        if (expectation === 'always' && !containsNewline(checkBefore)) {\n          if (context.fix) {\n            hasFixed = true;\n            fixBeforeForAlways(valueNode, context.newline);\n          } else {\n            complain(messages.expectedOpening, openingIndex);\n          }\n        }\n\n        if (isMultiLine && expectation === 'always-multi-line' && !containsNewline(checkBefore)) {\n          if (context.fix) {\n            hasFixed = true;\n            fixBeforeForAlways(valueNode, context.newline);\n          } else {\n            complain(messages.expectedOpeningMultiLine, openingIndex);\n          }\n        }\n\n        if (isMultiLine && expectation === 'never-multi-line' && checkBefore !== '') {\n          if (context.fix) {\n            hasFixed = true;\n            fixBeforeForNever(valueNode);\n          } else {\n            complain(messages.rejectedOpeningMultiLine, openingIndex);\n          }\n        } // Check closing ...\n\n\n        const closingIndex = valueNode.sourceIndex + functionString.length - 2;\n        const checkAfter = getCheckAfter(valueNode);\n\n        if (expectation === 'always' && !containsNewline(checkAfter)) {\n          if (context.fix) {\n            hasFixed = true;\n            fixAfterForAlways(valueNode, context.newline);\n          } else {\n            complain(messages.expectedClosing, closingIndex);\n          }\n        }\n\n        if (isMultiLine && expectation === 'always-multi-line' && !containsNewline(checkAfter)) {\n          if (context.fix) {\n            hasFixed = true;\n            fixAfterForAlways(valueNode, context.newline);\n          } else {\n            complain(messages.expectedClosingMultiLine, closingIndex);\n          }\n        }\n\n        if (isMultiLine && expectation === 'never-multi-line' && checkAfter !== '') {\n          if (context.fix) {\n            hasFixed = true;\n            fixAfterForNever(valueNode);\n          } else {\n            complain(messages.rejectedClosingMultiLine, closingIndex);\n          }\n        }\n      });\n\n      if (hasFixed) {\n        if (!decl.raws.value) {\n          decl.value = parsedValue.toString();\n        } else {\n          decl.raws.value.raw = parsedValue.toString();\n        }\n      }\n\n      function complain(message, offset) {\n        report({\n          ruleName,\n          result,\n          message,\n          node: decl,\n          index: declarationValueIndex(decl) + offset\n        });\n      }\n    });\n  };\n}\n\nfunction getCheckBefore(valueNode) {\n  let before = valueNode.before;\n\n  for (const node of valueNode.nodes) {\n    if (node.type === 'comment') {\n      continue;\n    }\n\n    if (node.type === 'space') {\n      before += node.value;\n      continue;\n    }\n\n    break;\n  }\n\n  return before;\n}\n\nfunction getCheckAfter(valueNode) {\n  let after = '';\n\n  for (const node of valueNode.nodes.slice().reverse()) {\n    if (node.type === 'comment') {\n      continue;\n    }\n\n    if (node.type === 'space') {\n      after = node.value + after;\n      continue;\n    }\n\n    break;\n  }\n\n  after += valueNode.after;\n  return after;\n}\n\nfunction fixBeforeForAlways(valueNode, newline) {\n  let target;\n\n  for (const node of valueNode.nodes) {\n    if (node.type === 'comment') {\n      continue;\n    }\n\n    if (node.type === 'space') {\n      target = node;\n      continue;\n    }\n\n    break;\n  }\n\n  if (target) {\n    target.value = newline + target.value;\n  } else {\n    valueNode.before = newline + valueNode.before;\n  }\n}\n\nfunction fixBeforeForNever(valueNode) {\n  valueNode.before = '';\n\n  for (const node of valueNode.nodes) {\n    if (node.type === 'comment') {\n      continue;\n    }\n\n    if (node.type === 'space') {\n      node.value = '';\n      continue;\n    }\n\n    break;\n  }\n}\n\nfunction fixAfterForAlways(valueNode, newline) {\n  valueNode.after = newline + valueNode.after;\n}\n\nfunction fixAfterForNever(valueNode) {\n  valueNode.after = '';\n\n  for (const node of valueNode.nodes.slice().reverse()) {\n    if (node.type === 'comment') {\n      continue;\n    }\n\n    if (node.type === 'space') {\n      node.value = '';\n      continue;\n    }\n\n    break;\n  }\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/function-parentheses-newline-inside/index.js"],"names":["_","require","declarationValueIndex","isSingleLineString","isStandardSyntaxFunction","report","ruleMessages","validateOptions","valueParser","ruleName","messages","expectedOpening","expectedClosing","expectedOpeningMultiLine","rejectedOpeningMultiLine","expectedClosingMultiLine","rejectedClosingMultiLine","rule","expectation","options","context","root","result","validOptions","actual","possible","walkDecls","decl","value","includes","hasFixed","declValue","get","parsedValue","walk","valueNode","type","functionString","stringify","isMultiLine","containsNewline","str","openingIndex","sourceIndex","length","checkBefore","getCheckBefore","fix","fixBeforeForAlways","newline","complain","fixBeforeForNever","closingIndex","checkAfter","getCheckAfter","fixAfterForAlways","fixAfterForNever","raws","toString","raw","message","offset","node","index","before","nodes","after","slice","reverse","target","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-parentheses-newline-inside';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedOpening: 'Expected newline after \"(\"',\n\texpectedClosing: 'Expected newline before \")\"',\n\texpectedOpeningMultiLine: 'Expected newline after \"(\" in a multi-line function',\n\trejectedOpeningMultiLine: 'Unexpected whitespace after \"(\" in a multi-line function',\n\texpectedClosingMultiLine: 'Expected newline before \")\" in a multi-line function',\n\trejectedClosingMultiLine: 'Unexpected whitespace before \")\" in a multi-line function',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tif (!decl.value.includes('(')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet hasFixed = false;\n\t\t\tconst declValue = _.get(decl, 'raws.value.raw', decl.value);\n\t\t\tconst parsedValue = valueParser(declValue);\n\n\t\t\tparsedValue.walk((valueNode) => {\n\t\t\t\tif (valueNode.type !== 'function') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!isStandardSyntaxFunction(valueNode)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst functionString = valueParser.stringify(valueNode);\n\t\t\t\tconst isMultiLine = !isSingleLineString(functionString);\n\n\t\t\t\tfunction containsNewline(str) {\n\t\t\t\t\treturn str.includes('\\n');\n\t\t\t\t}\n\n\t\t\t\t// Check opening ...\n\n\t\t\t\tconst openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;\n\t\t\t\tconst checkBefore = getCheckBefore(valueNode);\n\n\t\t\t\tif (expectation === 'always' && !containsNewline(checkBefore)) {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tfixBeforeForAlways(valueNode, context.newline);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedOpening, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMultiLine && expectation === 'always-multi-line' && !containsNewline(checkBefore)) {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tfixBeforeForAlways(valueNode, context.newline);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedOpeningMultiLine, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMultiLine && expectation === 'never-multi-line' && checkBefore !== '') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tfixBeforeForNever(valueNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.rejectedOpeningMultiLine, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check closing ...\n\n\t\t\t\tconst closingIndex = valueNode.sourceIndex + functionString.length - 2;\n\t\t\t\tconst checkAfter = getCheckAfter(valueNode);\n\n\t\t\t\tif (expectation === 'always' && !containsNewline(checkAfter)) {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tfixAfterForAlways(valueNode, context.newline);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedClosing, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMultiLine && expectation === 'always-multi-line' && !containsNewline(checkAfter)) {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tfixAfterForAlways(valueNode, context.newline);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedClosingMultiLine, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMultiLine && expectation === 'never-multi-line' && checkAfter !== '') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tfixAfterForNever(valueNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.rejectedClosingMultiLine, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (hasFixed) {\n\t\t\t\tif (!decl.raws.value) {\n\t\t\t\t\tdecl.value = parsedValue.toString();\n\t\t\t\t} else {\n\t\t\t\t\tdecl.raws.value.raw = parsedValue.toString();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction complain(message, offset) {\n\t\t\t\treport({\n\t\t\t\t\truleName,\n\t\t\t\t\tresult,\n\t\t\t\t\tmessage,\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + offset,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction getCheckBefore(valueNode) {\n\tlet before = valueNode.before;\n\n\tfor (const node of valueNode.nodes) {\n\t\tif (node.type === 'comment') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.type === 'space') {\n\t\t\tbefore += node.value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn before;\n}\n\nfunction getCheckAfter(valueNode) {\n\tlet after = '';\n\n\tfor (const node of valueNode.nodes.slice().reverse()) {\n\t\tif (node.type === 'comment') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.type === 'space') {\n\t\t\tafter = node.value + after;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tafter += valueNode.after;\n\n\treturn after;\n}\n\nfunction fixBeforeForAlways(valueNode, newline) {\n\tlet target;\n\n\tfor (const node of valueNode.nodes) {\n\t\tif (node.type === 'comment') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.type === 'space') {\n\t\t\ttarget = node;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (target) {\n\t\ttarget.value = newline + target.value;\n\t} else {\n\t\tvalueNode.before = newline + valueNode.before;\n\t}\n}\n\nfunction fixBeforeForNever(valueNode) {\n\tvalueNode.before = '';\n\n\tfor (const node of valueNode.nodes) {\n\t\tif (node.type === 'comment') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.type === 'space') {\n\t\t\tnode.value = '';\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nfunction fixAfterForAlways(valueNode, newline) {\n\tvalueNode.after = newline + valueNode.after;\n}\n\nfunction fixAfterForNever(valueNode) {\n\tvalueNode.after = '';\n\n\tfor (const node of valueNode.nodes.slice().reverse()) {\n\t\tif (node.type === 'comment') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.type === 'space') {\n\t\t\tnode.value = '';\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}