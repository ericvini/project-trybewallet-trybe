{"ast":null,"code":"var SKIP = 'skip';\nvar CHECK = 'check';\nvar ONLY = 'only';\n\nmodule.exports = function (options, callback) {\n  var source = options.source;\n  var target = options.target;\n  var skipComments = options.comments ? options.comments === SKIP : true;\n  var skipStrings = options.strings ? options.strings === SKIP : true;\n  var skipFunctionNames = options.functionNames ? options.functionNames === SKIP : true;\n  var skipFunctionArguments = options.functionArguments === SKIP;\n  var skipParentheticals = options.parentheticals === SKIP;\n  var onceOptionUsed = false;\n  Object.keys(options).forEach(function (key) {\n    if (options[key] !== ONLY) return;\n\n    if (!onceOptionUsed) {\n      onceOptionUsed = true;\n    } else {\n      throw new Error('Only one syntax feature option can be the \"only\" one to check');\n    }\n  });\n  var onlyComments = options.comments === ONLY;\n  var onlyStrings = options.strings === ONLY;\n  var onlyFunctionNames = options.functionNames === ONLY;\n  var onlyFunctionArguments = options.functionArguments === ONLY;\n  var onlyParentheticals = options.parentheticals === ONLY;\n  var insideString = false;\n  var insideComment = false;\n  var insideSingleLineComment = false;\n  var insideParens = false;\n  var insideFunctionArguments = false;\n  var openingParenCount = 0;\n  var matchCount = 0;\n  var openingQuote;\n  var targetIsArray = Array.isArray(target); // If the target is just a string, it is easy to check whether\n  // some index of the source matches it.\n  // If the target is an array of strings, though, we have to\n  // check whether some index of the source matches *any* of\n  // those target strings (stopping after the first match).\n\n  var getMatch = function () {\n    if (!targetIsArray) {\n      return getMatchBase.bind(null, target);\n    }\n\n    return function (index) {\n      for (var ti = 0, tl = target.length; ti < tl; ti++) {\n        var checkResult = getMatchBase(target[ti], index);\n        if (checkResult) return checkResult;\n      }\n\n      return false;\n    };\n  }();\n\n  function getMatchBase(targetString, index) {\n    var targetStringLength = targetString.length; // Target is a single character\n\n    if (targetStringLength === 1 && source[index] !== targetString) return false; // Target is multiple characters\n\n    if (source.substr(index, targetStringLength) !== targetString) return false;\n    return {\n      insideParens: insideParens,\n      insideFunctionArguments: insideFunctionArguments,\n      insideComment: insideComment,\n      insideString: insideString,\n      startIndex: index,\n      endIndex: index + targetStringLength,\n      target: targetString\n    };\n  }\n\n  for (var i = 0, l = source.length; i < l; i++) {\n    var currentChar = source[i]; // Register the beginning of a comment\n\n    if (!insideString && !insideComment && currentChar === \"/\" && source[i - 1] !== \"\\\\\" // escaping\n    ) {\n        // standard comments\n        if (source[i + 1] === \"*\") {\n          insideComment = true;\n          continue;\n        } // single-line comments\n\n\n        if (source[i + 1] === \"/\") {\n          insideComment = true;\n          insideSingleLineComment = true;\n          continue;\n        }\n      }\n\n    if (insideComment) {\n      // Register the end of a standard comment\n      if (!insideSingleLineComment && currentChar === \"*\" && source[i - 1] !== \"\\\\\" // escaping\n      && source[i + 1] === \"/\" && source[i - 1] !== \"/\" // don't end if it's /*/\n      ) {\n          insideComment = false;\n          continue;\n        } // Register the end of a single-line comment\n\n\n      if (insideSingleLineComment && currentChar === \"\\n\") {\n        insideComment = false;\n        insideSingleLineComment = false;\n      }\n\n      if (skipComments) continue;\n    } // Register the beginning of a string\n\n\n    if (!insideComment && !insideString && (currentChar === \"\\\"\" || currentChar === \"'\")) {\n      if (source[i - 1] === \"\\\\\") continue; // escaping\n\n      openingQuote = currentChar;\n      insideString = true; // For string-quotes rule\n\n      if (target === currentChar) handleMatch(getMatch(i));\n      continue;\n    }\n\n    if (insideString) {\n      // Register the end of a string\n      if (currentChar === openingQuote) {\n        if (source[i - 1] === \"\\\\\") continue; // escaping\n\n        insideString = false;\n        continue;\n      }\n\n      if (skipStrings) continue;\n    } // Register the beginning of parens/functions\n\n\n    if (!insideString && !insideComment && currentChar === \"(\") {\n      // Keep track of opening parentheticals so that we\n      // know when the outermost function (possibly\n      // containing nested functions) is closing\n      openingParenCount++;\n      insideParens = true; // Only inside a function if there is a function name\n      // before the opening paren\n\n      if (/[a-zA-Z]/.test(source[i - 1])) {\n        insideFunctionArguments = true;\n      }\n\n      if (target === \"(\") handleMatch(getMatch(i));\n      continue;\n    }\n\n    if (insideParens) {\n      // Register the end of a function\n      if (currentChar === \")\") {\n        openingParenCount--; // Do this here so the match is still technically inside a function\n\n        if (target === \")\") handleMatch(getMatch(i));\n\n        if (openingParenCount === 0) {\n          insideParens = false;\n          insideFunctionArguments = false;\n        }\n\n        continue;\n      }\n    }\n\n    var isFunctionName = /^[a-zA-Z]*\\(/.test(source.slice(i));\n    if (skipFunctionNames && isFunctionName) continue;\n    if (onlyFunctionNames && !isFunctionName) continue;\n    var match = getMatch(i);\n    if (!match) continue;\n    handleMatch(match);\n    if (options.once) return;\n  }\n\n  function handleMatch(match) {\n    if (onlyParentheticals && !insideParens) return;\n    if (skipParentheticals && insideParens) return;\n    if (onlyFunctionArguments && !insideFunctionArguments) return;\n    if (skipFunctionArguments && insideFunctionArguments) return;\n    if (onlyStrings && !insideString) return;\n    if (onlyComments && !insideComment) return;\n    matchCount++;\n    callback(match, matchCount);\n  }\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/style-search/index.js"],"names":["SKIP","CHECK","ONLY","module","exports","options","callback","source","target","skipComments","comments","skipStrings","strings","skipFunctionNames","functionNames","skipFunctionArguments","functionArguments","skipParentheticals","parentheticals","onceOptionUsed","Object","keys","forEach","key","Error","onlyComments","onlyStrings","onlyFunctionNames","onlyFunctionArguments","onlyParentheticals","insideString","insideComment","insideSingleLineComment","insideParens","insideFunctionArguments","openingParenCount","matchCount","openingQuote","targetIsArray","Array","isArray","getMatch","getMatchBase","bind","index","ti","tl","length","checkResult","targetString","targetStringLength","substr","startIndex","endIndex","i","l","currentChar","handleMatch","test","isFunctionName","slice","match","once"],"mappings":"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","sourcesContent":["var SKIP = 'skip';\nvar CHECK = 'check';\nvar ONLY = 'only';\n\nmodule.exports = function (options, callback) {\n  var source = options.source;\n  var target = options.target;\n\n  var skipComments = (options.comments) ? options.comments === SKIP : true;\n  var skipStrings = (options.strings) ? options.strings === SKIP : true;\n  var skipFunctionNames = (options.functionNames) ? options.functionNames === SKIP : true;\n  var skipFunctionArguments = options.functionArguments === SKIP;\n  var skipParentheticals = options.parentheticals === SKIP;\n\n  var onceOptionUsed = false;\n  Object.keys(options).forEach(function(key) {\n    if (options[key] !== ONLY) return;\n    if (!onceOptionUsed) {\n      onceOptionUsed = true;\n    } else {\n      throw new Error('Only one syntax feature option can be the \"only\" one to check');\n    }\n  });\n\n  var onlyComments = options.comments === ONLY;\n  var onlyStrings = options.strings === ONLY;\n  var onlyFunctionNames = options.functionNames === ONLY;\n  var onlyFunctionArguments = options.functionArguments === ONLY;\n  var onlyParentheticals = options.parentheticals === ONLY;\n\n  var insideString = false;\n  var insideComment = false;\n  var insideSingleLineComment = false;\n  var insideParens = false;\n  var insideFunctionArguments = false;\n  var openingParenCount = 0;\n  var matchCount = 0;\n  var openingQuote;\n\n  var targetIsArray = Array.isArray(target);\n\n  // If the target is just a string, it is easy to check whether\n  // some index of the source matches it.\n  // If the target is an array of strings, though, we have to\n  // check whether some index of the source matches *any* of\n  // those target strings (stopping after the first match).\n  var getMatch = (function () {\n    if (!targetIsArray) {\n      return getMatchBase.bind(null, target);\n    }\n    return function(index) {\n      for (var ti = 0, tl = target.length; ti < tl; ti++) {\n        var checkResult = getMatchBase(target[ti], index);\n        if (checkResult) return checkResult;\n      }\n      return false;\n    }\n  })();\n\n  function getMatchBase(targetString, index) {\n    var targetStringLength = targetString.length;\n\n    // Target is a single character\n    if (targetStringLength === 1 && source[index] !== targetString) return false;\n\n    // Target is multiple characters\n    if (source.substr(index, targetStringLength) !== targetString) return false;\n\n    return {\n      insideParens: insideParens,\n      insideFunctionArguments: insideFunctionArguments,\n      insideComment: insideComment,\n      insideString: insideString,\n      startIndex: index,\n      endIndex: index + targetStringLength,\n      target: targetString,\n    };\n  }\n\n  for (var i = 0, l = source.length; i < l; i++) {\n    var currentChar = source[i];\n\n    // Register the beginning of a comment\n    if (\n      !insideString && !insideComment\n      && currentChar === \"/\"\n      && source[i - 1] !== \"\\\\\" // escaping\n    ) {\n      // standard comments\n      if (source[i + 1] === \"*\") {\n        insideComment = true;\n        continue;\n      }\n      // single-line comments\n      if (source[i + 1] === \"/\") {\n        insideComment = true;\n        insideSingleLineComment = true;\n        continue;\n      }\n    }\n\n    if (insideComment) {\n      // Register the end of a standard comment\n      if (\n        !insideSingleLineComment\n        && currentChar === \"*\"\n        && source[i - 1] !== \"\\\\\" // escaping\n        && source[i + 1] === \"/\"\n        && source[i - 1] !== \"/\" // don't end if it's /*/\n      ) {\n        insideComment = false;\n        continue;\n      }\n\n      // Register the end of a single-line comment\n      if (\n        insideSingleLineComment\n        && currentChar === \"\\n\"\n      ) {\n        insideComment = false;\n        insideSingleLineComment = false;\n      }\n\n      if (skipComments) continue;\n    }\n\n    // Register the beginning of a string\n    if (!insideComment && !insideString && (currentChar === \"\\\"\" || currentChar === \"'\")) {\n      if (source[i - 1] === \"\\\\\") continue; // escaping\n\n      openingQuote = currentChar;\n      insideString = true;\n\n      // For string-quotes rule\n      if (target === currentChar) handleMatch(getMatch(i));\n      continue;\n    }\n\n    if (insideString) {\n      // Register the end of a string\n      if (currentChar === openingQuote) {\n        if (source[i - 1] === \"\\\\\") continue; // escaping\n        insideString = false;\n        continue;\n      }\n\n      if (skipStrings) continue;\n    }\n\n    // Register the beginning of parens/functions\n    if (!insideString && !insideComment && currentChar === \"(\") {\n      // Keep track of opening parentheticals so that we\n      // know when the outermost function (possibly\n      // containing nested functions) is closing\n      openingParenCount++;\n\n      insideParens = true;\n      // Only inside a function if there is a function name\n      // before the opening paren\n      if (/[a-zA-Z]/.test(source[i - 1])) {\n        insideFunctionArguments = true;\n      }\n\n      if (target === \"(\") handleMatch(getMatch(i));\n      continue;\n    }\n\n    if (insideParens) {\n      // Register the end of a function\n      if (currentChar === \")\") {\n        openingParenCount--;\n        // Do this here so the match is still technically inside a function\n        if (target === \")\") handleMatch(getMatch(i));\n        if (openingParenCount === 0) {\n          insideParens = false;\n          insideFunctionArguments = false;\n        }\n        continue;\n      }\n    }\n\n    var isFunctionName = /^[a-zA-Z]*\\(/.test(source.slice(i));\n    if (skipFunctionNames && isFunctionName) continue;\n    if (onlyFunctionNames && !isFunctionName) continue;\n\n    var match = getMatch(i);\n\n    if (!match) continue;\n    handleMatch(match);\n    if (options.once) return;\n  }\n\n  function handleMatch(match) {\n    if (onlyParentheticals && !insideParens) return;\n    if (skipParentheticals && insideParens) return;\n    if (onlyFunctionArguments && !insideFunctionArguments) return;\n    if (skipFunctionArguments && insideFunctionArguments) return;\n    if (onlyStrings && !insideString) return;\n    if (onlyComments && !insideComment) return;\n    matchCount++;\n    callback(match, matchCount);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}