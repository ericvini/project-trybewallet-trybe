{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _indexesOf = _interopRequireDefault(require(\"indexes-of\"));\n\nvar _uniq = _interopRequireDefault(require(\"uniq\"));\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize.default)({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root.default({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector.default({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute.default(node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment.default({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string.default({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator.default({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator.default({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator.default({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector.default({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector.default({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string.default({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo.default({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = (0, _indexesOf.default)(word, '.').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    var hasId = (0, _indexesOf.default)(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = (0, _indexesOf.default)(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending.default)((0, _uniq.default)([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className.default(unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id.default(unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag.default(tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n\n\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/postcss-selector-parser/dist/parser.js"],"names":["exports","__esModule","default","_indexesOf","_interopRequireDefault","require","_uniq","_root","_selector","_className","_comment","_id","_tag","_string","_pseudo","_attribute","_interopRequireWildcard","_universal","_combinator","_nesting","_sortAscending","_tokenize","tokens","types","_util","_WHITESPACE_TOKENS","_Object$assign","obj","newObj","key","Object","prototype","hasOwnProperty","call","desc","defineProperty","getOwnPropertyDescriptor","get","set","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","_createClass","Constructor","protoProps","staticProps","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","assign","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","source","errorGenerator","append","current","loop","_proto","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","push","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","_unescaped","_oldRawValue","oldValue","quoteMark","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","requiredSpace","_this2","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_this$convertWhitespa","spaceOrDescendantSelectorNodes","_this$convertWhitespa2","_space","_rawSpace","_this$convertWhitespa3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","cache","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","every","string","firstCallback","_this5","lastIndexOf","hasClass","filter","hasId","interpolations","hashIndex","indices","concat","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","Array","isArray","pop","join","an","test","required","END_POS","searchPosition","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _indexesOf = _interopRequireDefault(require(\"indexes-of\"));\n\nvar _uniq = _interopRequireDefault(require(\"uniq\"));\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize.default)({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root.default({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector.default({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute.default(node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment.default({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string.default({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator.default({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator.default({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator.default({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector.default({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector.default({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string.default({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo.default({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = (0, _indexesOf.default)(word, '.').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    var hasId = (0, _indexesOf.default)(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = (0, _indexesOf.default)(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending.default)((0, _uniq.default)([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className.default(unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id.default(unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag.default(tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}