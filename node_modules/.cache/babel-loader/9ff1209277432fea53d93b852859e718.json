{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst execall = require('execall');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'max-line-length';\nconst EXCLUDED_PATTERNS = [/url\\(\\s*(\\S.*\\S)\\s*\\)/gi, // allow tab, whitespace in url content\n/@import\\s+(['\"].*['\"])/gi];\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected line length to be no more than ${max} ${max === 1 ? 'character' : 'characters'}`\n});\n\nfunction rule(maxLength, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: maxLength,\n      possible: _.isNumber\n    }, {\n      actual: options,\n      possible: {\n        ignore: ['non-comments', 'comments'],\n        ignorePattern: [_.isString, _.isRegExp]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const ignoreNonComments = optionsMatches(options, 'ignore', 'non-comments');\n    const ignoreComments = optionsMatches(options, 'ignore', 'comments');\n    const rootString = context.fix ? root.toString() : root.source.input.css; // Array of skipped sub strings, i.e `url(...)`, `@import \"...\"`\n\n    let skippedSubStrings = [];\n    let skippedSubStringsIndex = 0;\n    EXCLUDED_PATTERNS.forEach(pattern => execall(pattern, rootString).forEach(match => {\n      const startOfSubString = match.index + match.match.indexOf(_.get(match, 'subMatches[0]', ''));\n      return skippedSubStrings.push([startOfSubString, startOfSubString + _.get(match, 'subMatches[0].length', 0)]);\n    }));\n    skippedSubStrings = skippedSubStrings.sort((a, b) => a[0] - b[0]); // Check first line\n\n    checkNewline(rootString, {\n      endIndex: 0\n    }, root); // Check subsequent lines\n\n    styleSearch({\n      source: rootString,\n      target: ['\\n'],\n      comments: 'check'\n    }, match => checkNewline(rootString, match, root)); // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    function complain(index, root) {\n      report({\n        index,\n        result,\n        ruleName,\n        message: messages.expected(maxLength),\n        node: root\n      });\n    }\n\n    function tryToPopSubString(start, end) {\n      const [startSubString, endSubString] = skippedSubStrings[skippedSubStringsIndex]; // Excluded substring does not presented in current line\n\n      if (end < startSubString) {\n        return 0;\n      } // Compute excluded substring size regarding to current line indexes\n\n\n      const excluded = Math.min(end, endSubString) - Math.max(start, startSubString); // Current substring is out of range for next lines\n\n      if (endSubString <= end) {\n        skippedSubStringsIndex++;\n      }\n\n      return excluded;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function checkNewline(rootString, match, root) {\n      let nextNewlineIndex = rootString.indexOf('\\n', match.endIndex);\n\n      if (rootString[nextNewlineIndex - 1] === '\\r') {\n        nextNewlineIndex -= 1;\n      } // Accommodate last line\n\n\n      if (nextNewlineIndex === -1) {\n        nextNewlineIndex = rootString.length;\n      }\n\n      const rawLineLength = nextNewlineIndex - match.endIndex;\n      const excludedLength = skippedSubStrings[skippedSubStringsIndex] ? tryToPopSubString(match.endIndex, nextNewlineIndex) : 0;\n      const lineText = rootString.slice(match.endIndex, nextNewlineIndex); // Case sensitive ignorePattern match\n\n      if (optionsMatches(options, 'ignorePattern', lineText)) {\n        return;\n      } // If the line's length is less than or equal to the specified\n      // max, ignore it ... So anything below is liable to be complained about.\n      // **Note that the length of any url arguments or import urls\n      // are excluded from the calculation.**\n\n\n      if (rawLineLength - excludedLength <= maxLength) {\n        return;\n      }\n\n      const complaintIndex = nextNewlineIndex - 1;\n\n      if (ignoreComments) {\n        if (match.insideComment) {\n          return;\n        } // This trimming business is to notice when the line starts a\n        // comment but that comment is indented, e.g.\n        //       /* something here */\n\n\n        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);\n\n        if (nextTwoChars === '/*' || nextTwoChars === '//') {\n          return;\n        }\n      }\n\n      if (ignoreNonComments) {\n        if (match.insideComment) {\n          return complain(complaintIndex, root);\n        } // This trimming business is to notice when the line starts a\n        // comment but that comment is indented, e.g.\n        //       /* something here */\n\n\n        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);\n\n        if (nextTwoChars !== '/*' && nextTwoChars !== '//') {\n          return;\n        }\n\n        return complain(complaintIndex, root);\n      } // If there are no spaces besides initial (indent) spaces, ignore it\n\n\n      const lineString = rootString.slice(match.endIndex, nextNewlineIndex);\n\n      if (!lineString.replace(/^\\s+/, '').includes(' ')) {\n        return;\n      }\n\n      return complain(complaintIndex, root);\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/max-line-length/index.js"],"names":["_","require","execall","optionsMatches","report","ruleMessages","styleSearch","validateOptions","ruleName","EXCLUDED_PATTERNS","messages","expected","max","rule","maxLength","options","context","root","result","validOptions","actual","possible","isNumber","ignore","ignorePattern","isString","isRegExp","optional","ignoreNonComments","ignoreComments","rootString","fix","toString","source","input","css","skippedSubStrings","skippedSubStringsIndex","forEach","pattern","match","startOfSubString","index","indexOf","get","push","sort","a","b","checkNewline","endIndex","target","comments","complain","message","node","tryToPopSubString","start","end","startSubString","endSubString","excluded","Math","min","nextNewlineIndex","length","rawLineLength","excludedLength","lineText","slice","complaintIndex","insideComment","nextTwoChars","trim","lineString","replace","includes","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst execall = require('execall');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'max-line-length';\nconst EXCLUDED_PATTERNS = [\n\t/url\\(\\s*(\\S.*\\S)\\s*\\)/gi, // allow tab, whitespace in url content\n\t/@import\\s+(['\"].*['\"])/gi,\n];\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (max) =>\n\t\t`Expected line length to be no more than ${max} ${max === 1 ? 'character' : 'characters'}`,\n});\n\nfunction rule(maxLength, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: maxLength,\n\t\t\t\tpossible: _.isNumber,\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['non-comments', 'comments'],\n\t\t\t\t\tignorePattern: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ignoreNonComments = optionsMatches(options, 'ignore', 'non-comments');\n\t\tconst ignoreComments = optionsMatches(options, 'ignore', 'comments');\n\t\tconst rootString = context.fix ? root.toString() : root.source.input.css;\n\t\t// Array of skipped sub strings, i.e `url(...)`, `@import \"...\"`\n\t\tlet skippedSubStrings = [];\n\t\tlet skippedSubStringsIndex = 0;\n\n\t\tEXCLUDED_PATTERNS.forEach((pattern) =>\n\t\t\texecall(pattern, rootString).forEach((match) => {\n\t\t\t\tconst startOfSubString =\n\t\t\t\t\tmatch.index + match.match.indexOf(_.get(match, 'subMatches[0]', ''));\n\n\t\t\t\treturn skippedSubStrings.push([\n\t\t\t\t\tstartOfSubString,\n\t\t\t\t\tstartOfSubString + _.get(match, 'subMatches[0].length', 0),\n\t\t\t\t]);\n\t\t\t}),\n\t\t);\n\n\t\tskippedSubStrings = skippedSubStrings.sort((a, b) => a[0] - b[0]);\n\n\t\t// Check first line\n\t\tcheckNewline(rootString, { endIndex: 0 }, root);\n\t\t// Check subsequent lines\n\t\tstyleSearch({ source: rootString, target: ['\\n'], comments: 'check' }, (match) =>\n\t\t\tcheckNewline(rootString, match, root),\n\t\t);\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction complain(index, root) {\n\t\t\treport({\n\t\t\t\tindex,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t\tmessage: messages.expected(maxLength),\n\t\t\t\tnode: root,\n\t\t\t});\n\t\t}\n\n\t\tfunction tryToPopSubString(start, end) {\n\t\t\tconst [startSubString, endSubString] = skippedSubStrings[skippedSubStringsIndex];\n\n\t\t\t// Excluded substring does not presented in current line\n\t\t\tif (end < startSubString) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Compute excluded substring size regarding to current line indexes\n\t\t\tconst excluded = Math.min(end, endSubString) - Math.max(start, startSubString);\n\n\t\t\t// Current substring is out of range for next lines\n\t\t\tif (endSubString <= end) {\n\t\t\t\tskippedSubStringsIndex++;\n\t\t\t}\n\n\t\t\treturn excluded;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction checkNewline(rootString, match, root) {\n\t\t\tlet nextNewlineIndex = rootString.indexOf('\\n', match.endIndex);\n\n\t\t\tif (rootString[nextNewlineIndex - 1] === '\\r') {\n\t\t\t\tnextNewlineIndex -= 1;\n\t\t\t}\n\n\t\t\t// Accommodate last line\n\t\t\tif (nextNewlineIndex === -1) {\n\t\t\t\tnextNewlineIndex = rootString.length;\n\t\t\t}\n\n\t\t\tconst rawLineLength = nextNewlineIndex - match.endIndex;\n\t\t\tconst excludedLength = skippedSubStrings[skippedSubStringsIndex]\n\t\t\t\t? tryToPopSubString(match.endIndex, nextNewlineIndex)\n\t\t\t\t: 0;\n\t\t\tconst lineText = rootString.slice(match.endIndex, nextNewlineIndex);\n\n\t\t\t// Case sensitive ignorePattern match\n\t\t\tif (optionsMatches(options, 'ignorePattern', lineText)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the line's length is less than or equal to the specified\n\t\t\t// max, ignore it ... So anything below is liable to be complained about.\n\t\t\t// **Note that the length of any url arguments or import urls\n\t\t\t// are excluded from the calculation.**\n\t\t\tif (rawLineLength - excludedLength <= maxLength) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst complaintIndex = nextNewlineIndex - 1;\n\n\t\t\tif (ignoreComments) {\n\t\t\t\tif (match.insideComment) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// This trimming business is to notice when the line starts a\n\t\t\t\t// comment but that comment is indented, e.g.\n\t\t\t\t//       /* something here */\n\t\t\t\tconst nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);\n\n\t\t\t\tif (nextTwoChars === '/*' || nextTwoChars === '//') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ignoreNonComments) {\n\t\t\t\tif (match.insideComment) {\n\t\t\t\t\treturn complain(complaintIndex, root);\n\t\t\t\t}\n\n\t\t\t\t// This trimming business is to notice when the line starts a\n\t\t\t\t// comment but that comment is indented, e.g.\n\t\t\t\t//       /* something here */\n\t\t\t\tconst nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);\n\n\t\t\t\tif (nextTwoChars !== '/*' && nextTwoChars !== '//') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturn complain(complaintIndex, root);\n\t\t\t}\n\n\t\t\t// If there are no spaces besides initial (indent) spaces, ignore it\n\t\t\tconst lineString = rootString.slice(match.endIndex, nextNewlineIndex);\n\n\t\t\tif (!lineString.replace(/^\\s+/, '').includes(' ')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn complain(complaintIndex, root);\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}