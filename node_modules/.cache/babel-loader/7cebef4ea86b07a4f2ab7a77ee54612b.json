{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-attribute-operator-space-before';\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: operator => `Expected single space before \"${operator}\"`,\n  rejectedBefore: operator => `Unexpected whitespace before \"${operator}\"`\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('space', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    selectorAttributeOperatorSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n      checkBeforeOperator: true,\n      fix: context.fix ? attributeNode => {\n        const rawAttrAfter = _.get(attributeNode, 'raws.spaces.attribute.after');\n\n        const {\n          attrAfter,\n          setAttrAfter\n        } = rawAttrAfter ? {\n          attrAfter: rawAttrAfter,\n\n          setAttrAfter(fixed) {\n            attributeNode.raws.spaces.attribute.after = fixed;\n          }\n\n        } : {\n          attrAfter: _.get(attributeNode, 'spaces.attribute.after', ''),\n\n          setAttrAfter(fixed) {\n            _.set(attributeNode, 'spaces.attribute.after', fixed);\n          }\n\n        };\n\n        if (expectation === 'always') {\n          setAttrAfter(attrAfter.replace(/\\s*$/, ' '));\n          return true;\n        }\n\n        if (expectation === 'never') {\n          setAttrAfter(attrAfter.replace(/\\s*$/, ''));\n          return true;\n        }\n      } : null\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-attribute-operator-space-before/index.js"],"names":["_","require","ruleMessages","selectorAttributeOperatorSpaceChecker","validateOptions","whitespaceChecker","ruleName","messages","expectedBefore","operator","rejectedBefore","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","locationChecker","before","checkedRuleName","checkBeforeOperator","fix","attributeNode","rawAttrAfter","get","attrAfter","setAttrAfter","fixed","raws","spaces","attribute","after","set","replace","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAME,qCAAqC,GAAGF,OAAO,CAAC,0CAAD,CAArD;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,6BAAD,CAA/B;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,+BAAD,CAAjC;;AAEA,MAAMK,QAAQ,GAAG,0CAAjB;AAEA,MAAMC,QAAQ,GAAGL,YAAY,CAACI,QAAD,EAAW;AACvCE,EAAAA,cAAc,EAAGC,QAAD,IAAe,iCAAgCA,QAAS,GADjC;AAEvCC,EAAAA,cAAc,EAAGD,QAAD,IAAe,iCAAgCA,QAAS;AAFjC,CAAX,CAA7B;;AAKA,SAASE,IAAT,CAAcC,WAAd,EAA2BC,OAA3B,EAAoCC,OAApC,EAA6C;AAC5C,QAAMC,OAAO,GAAGV,iBAAiB,CAAC,OAAD,EAAUO,WAAV,EAAuBL,QAAvB,CAAjC;AAEA,SAAO,CAACS,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGd,eAAe,CAACa,MAAD,EAASX,QAAT,EAAmB;AACtDa,MAAAA,MAAM,EAAEP,WAD8C;AAEtDQ,MAAAA,QAAQ,EAAE,CAAC,QAAD,EAAW,OAAX;AAF4C,KAAnB,CAApC;;AAKA,QAAI,CAACF,YAAL,EAAmB;AAClB;AACA;;AAEDf,IAAAA,qCAAqC,CAAC;AACrCa,MAAAA,IADqC;AAErCC,MAAAA,MAFqC;AAGrCI,MAAAA,eAAe,EAAEN,OAAO,CAACO,MAHY;AAIrCC,MAAAA,eAAe,EAAEjB,QAJoB;AAKrCkB,MAAAA,mBAAmB,EAAE,IALgB;AAMrCC,MAAAA,GAAG,EAAEX,OAAO,CAACW,GAAR,GACDC,aAAD,IAAmB;AACnB,cAAMC,YAAY,GAAG3B,CAAC,CAAC4B,GAAF,CAAMF,aAAN,EAAqB,6BAArB,CAArB;;AACA,cAAM;AAAEG,UAAAA,SAAF;AAAaC,UAAAA;AAAb,YAA8BH,YAAY,GAC7C;AACAE,UAAAA,SAAS,EAAEF,YADX;;AAEAG,UAAAA,YAAY,CAACC,KAAD,EAAQ;AACnBL,YAAAA,aAAa,CAACM,IAAd,CAAmBC,MAAnB,CAA0BC,SAA1B,CAAoCC,KAApC,GAA4CJ,KAA5C;AACA;;AAJD,SAD6C,GAO7C;AACAF,UAAAA,SAAS,EAAE7B,CAAC,CAAC4B,GAAF,CAAMF,aAAN,EAAqB,wBAArB,EAA+C,EAA/C,CADX;;AAEAI,UAAAA,YAAY,CAACC,KAAD,EAAQ;AACnB/B,YAAAA,CAAC,CAACoC,GAAF,CAAMV,aAAN,EAAqB,wBAArB,EAA+CK,KAA/C;AACA;;AAJD,SAPH;;AAcA,YAAInB,WAAW,KAAK,QAApB,EAA8B;AAC7BkB,UAAAA,YAAY,CAACD,SAAS,CAACQ,OAAV,CAAkB,MAAlB,EAA0B,GAA1B,CAAD,CAAZ;AAEA,iBAAO,IAAP;AACA;;AAED,YAAIzB,WAAW,KAAK,OAApB,EAA6B;AAC5BkB,UAAAA,YAAY,CAACD,SAAS,CAACQ,OAAV,CAAkB,MAAlB,EAA0B,EAA1B,CAAD,CAAZ;AAEA,iBAAO,IAAP;AACA;AACA,OA5BC,GA6BF;AAnCkC,KAAD,CAArC;AAqCA,GA/CD;AAgDA;;AAED1B,IAAI,CAACL,QAAL,GAAgBA,QAAhB;AACAK,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACA+B,MAAM,CAACC,OAAP,GAAiB5B,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'selector-attribute-operator-space-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedBefore: (operator) => `Expected single space before \"${operator}\"`,\n\trejectedBefore: (operator) => `Unexpected whitespace before \"${operator}\"`,\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('space', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tselectorAttributeOperatorSpaceChecker({\n\t\t\troot,\n\t\t\tresult,\n\t\t\tlocationChecker: checker.before,\n\t\t\tcheckedRuleName: ruleName,\n\t\t\tcheckBeforeOperator: true,\n\t\t\tfix: context.fix\n\t\t\t\t? (attributeNode) => {\n\t\t\t\t\t\tconst rawAttrAfter = _.get(attributeNode, 'raws.spaces.attribute.after');\n\t\t\t\t\t\tconst { attrAfter, setAttrAfter } = rawAttrAfter\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tattrAfter: rawAttrAfter,\n\t\t\t\t\t\t\t\t\tsetAttrAfter(fixed) {\n\t\t\t\t\t\t\t\t\t\tattributeNode.raws.spaces.attribute.after = fixed;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tattrAfter: _.get(attributeNode, 'spaces.attribute.after', ''),\n\t\t\t\t\t\t\t\t\tsetAttrAfter(fixed) {\n\t\t\t\t\t\t\t\t\t\t_.set(attributeNode, 'spaces.attribute.after', fixed);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t  };\n\n\t\t\t\t\t\tif (expectation === 'always') {\n\t\t\t\t\t\t\tsetAttrAfter(attrAfter.replace(/\\s*$/, ' '));\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expectation === 'never') {\n\t\t\t\t\t\t\tsetAttrAfter(attrAfter.replace(/\\s*$/, ''));\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t: null,\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}