{"ast":null,"code":"'use strict';\n\nconst configurationError = require('./configurationError');\n\nconst isSingleLineString = require('./isSingleLineString');\n\nconst isWhitespace = require('./isWhitespace');\n/**\n * @typedef {object} Messages\n * @property {function} [expectedBefore]\n * @property {function} [rejectedBefore]\n * @property {function} [expectedAfter]\n * @property {function} [rejectedAfter]\n * @property {function} [expectedBeforeSingleLine]\n * @property {function} [rejectedBeforeSingleLine]\n * @property {function} [expectedBeforeMultiLine]\n * @property {function} [rejectedBeforeMultiLine]\n * @property {function} [expectedAfterSingleLine]\n * @property {function} [rejectedAfterSingleLine]\n * @property {function} [expectedAfterMultiLine]\n * @property {function} [rejectedAfterMultiLine]\n */\n\n/**\n * @typedef {object} WhitespaceCheckerArgs\n * @property {string} source - The source string\n * @property {number} index - The index of the character to check before\n * @property {function} err - If a violation is found, this callback\n *   will be invoked with the relevant warning message.\n *   Typically this callback will report() the violation.\n * @property {function} errTarget - If a violation is found, this string\n *   will be sent to the relevant warning message.\n * @property {string} [lineCheckStr] - Single- and multi-line checkers\n *   will use this string to determine whether they should proceed,\n *   i.e. if this string is one line only, single-line checkers will check,\n *   multi-line checkers will ignore.\n *   If none is passed, they will use `source`.\n * @property {boolean} [onlyOneChar=false] - Only check *one* character before.\n *   By default, \"always-*\" checks will look for the `targetWhitespace` one\n *   before and then ensure there is no whitespace two before. This option\n *   bypasses that second check.\n * @property {boolean} [allowIndentation=false] - Allow arbitrary indentation\n *   between the `targetWhitespace` (almost definitely a newline) and the `index`.\n *   With this option, the checker will see if a newline *begins* the whitespace before\n *   the `index`.\n */\n\n/**\n * @callback WhitespaceChecker\n * @param {WhitespaceCheckerArgs} args\n */\n\n/**\n * Create a whitespaceChecker, which exposes the following functions:\n * - `before()`\n * - `beforeAllowingIndentation()`\n * - `after()`\n * - `afterOneOnly()`\n *\n * @param {\"space\" | \"newline\"} targetWhitespace - This is a keyword instead\n *   of the actual character (e.g. \" \") in order to accommodate\n *   different styles of newline (\"\\n\" vs \"\\r\\n\")\n * @param { \"always\" | \"never\" | \"always-single-line\" | \"always-multi-line\" | \"never-single-line\" | \"never-multi-line\" } expectation\n * @param {Messages} messages - An object of message functions;\n *   calling `before*()` or `after*()` and the `expectation` that is passed\n *   determines which message functions are required\n *\n * @returns {object} The checker, with its exposed checking functions\n */\n\n\nmodule.exports = function (targetWhitespace, expectation, messages) {\n  // Keep track of active arguments in order to avoid passing\n  // too much stuff around, making signatures long and confusing.\n  // This variable gets reset anytime a checking function is called.\n\n  /**\n   * @type {{\n  \t\tsource?: any,\n  \t\tindex?: any,\n  \t\terr: any,\n  \t\terrTarget: any,\n  \t\tonlyOneChar: any,\n  \t\tallowIndentation?: any,\n  \t}}\n  */\n  let activeArgs;\n  /**\n   * Check for whitespace *before* a character.\n   * @type {WhitespaceChecker}\n   */\n\n  function before({\n    source,\n    index,\n    err,\n    errTarget,\n    lineCheckStr,\n    onlyOneChar = false,\n    allowIndentation = false\n  }) {\n    activeArgs = {\n      source,\n      index,\n      err,\n      errTarget,\n      onlyOneChar,\n      allowIndentation\n    };\n\n    switch (expectation) {\n      case 'always':\n        expectBefore();\n        break;\n\n      case 'never':\n        rejectBefore();\n        break;\n\n      case 'always-single-line':\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        expectBefore(messages.expectedBeforeSingleLine);\n        break;\n\n      case 'never-single-line':\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        rejectBefore(messages.rejectedBeforeSingleLine);\n        break;\n\n      case 'always-multi-line':\n        if (isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        expectBefore(messages.expectedBeforeMultiLine);\n        break;\n\n      case 'never-multi-line':\n        if (isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        rejectBefore(messages.rejectedBeforeMultiLine);\n        break;\n\n      default:\n        throw configurationError(`Unknown expectation \"${expectation}\"`);\n    }\n  }\n  /**\n   * Check for whitespace *after* a character.\n   * @type {WhitespaceChecker}\n   */\n\n\n  function after({\n    source,\n    index,\n    err,\n    errTarget,\n    lineCheckStr,\n    onlyOneChar = false\n  }) {\n    activeArgs = {\n      source,\n      index,\n      err,\n      errTarget,\n      onlyOneChar\n    };\n\n    switch (expectation) {\n      case 'always':\n        expectAfter();\n        break;\n\n      case 'never':\n        rejectAfter();\n        break;\n\n      case 'always-single-line':\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        expectAfter(messages.expectedAfterSingleLine);\n        break;\n\n      case 'never-single-line':\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        rejectAfter(messages.rejectedAfterSingleLine);\n        break;\n\n      case 'always-multi-line':\n        if (isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        expectAfter(messages.expectedAfterMultiLine);\n        break;\n\n      case 'never-multi-line':\n        if (isSingleLineString(lineCheckStr || source)) {\n          return;\n        }\n\n        rejectAfter(messages.rejectedAfterMultiLine);\n        break;\n\n      default:\n        throw configurationError(`Unknown expectation \"${expectation}\"`);\n    }\n  }\n  /**\n   * @param {WhitespaceCheckerArgs} obj\n   */\n\n\n  function beforeAllowingIndentation(obj) {\n    before({ ...obj,\n      allowIndentation: true\n    });\n  }\n  /**\n   * @param {Function} [messageFunc]\n   */\n\n\n  function expectBefore(messageFunc = messages.expectedBefore) {\n    if (activeArgs.allowIndentation) {\n      expectBeforeAllowingIndentation(messageFunc);\n      return;\n    }\n\n    const _activeArgs = activeArgs;\n    const source = _activeArgs.source;\n    const index = _activeArgs.index;\n    const oneCharBefore = source[index - 1];\n    const twoCharsBefore = source[index - 2];\n\n    if (!isValue(oneCharBefore)) {\n      return;\n    }\n\n    if (targetWhitespace === 'space' && oneCharBefore === ' ') {\n      if (activeArgs.onlyOneChar || !isWhitespace(twoCharsBefore)) {\n        return;\n      }\n    }\n\n    const msgFunc = assertFunction(messageFunc);\n    activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n  }\n  /**\n   * @param {Function} [messageFunc]\n   */\n\n\n  function expectBeforeAllowingIndentation(messageFunc = messages.expectedBefore) {\n    const _activeArgs2 = activeArgs;\n    const source = _activeArgs2.source;\n    const index = _activeArgs2.index;\n    const err = _activeArgs2.err;\n\n    const expectedChar = function () {\n      if (targetWhitespace === 'newline') {\n        return '\\n';\n      }\n    }();\n\n    let i = index - 1;\n\n    while (source[i] !== expectedChar) {\n      if (source[i] === '\\t' || source[i] === ' ') {\n        i--;\n        continue;\n      }\n\n      const msgFunc = assertFunction(messageFunc);\n      err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n      return;\n    }\n  }\n  /**\n   * @param {Function} [messageFunc]\n   */\n\n\n  function rejectBefore(messageFunc = messages.rejectedBefore) {\n    const _activeArgs3 = activeArgs;\n    const source = _activeArgs3.source;\n    const index = _activeArgs3.index;\n    const oneCharBefore = source[index - 1];\n\n    if (isValue(oneCharBefore) && isWhitespace(oneCharBefore)) {\n      const msgFunc = assertFunction(messageFunc);\n      activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n    }\n  }\n  /**\n   * @param {WhitespaceCheckerArgs} obj\n   */\n\n\n  function afterOneOnly(obj) {\n    after({ ...obj,\n      onlyOneChar: true\n    });\n  }\n  /**\n   * @param {Function} [messageFunc]\n   */\n\n\n  function expectAfter(messageFunc = messages.expectedAfter) {\n    const _activeArgs4 = activeArgs;\n    const source = _activeArgs4.source;\n    const index = _activeArgs4.index;\n    const oneCharAfter = source[index + 1];\n    const twoCharsAfter = source[index + 2];\n\n    if (!isValue(oneCharAfter)) {\n      return;\n    }\n\n    if (targetWhitespace === 'newline') {\n      // If index is followed by a Windows CR-LF ...\n      if (oneCharAfter === '\\r' && twoCharsAfter === '\\n') {\n        if (activeArgs.onlyOneChar || !isWhitespace(source[index + 3])) {\n          return;\n        }\n      } // If index is followed by a Unix LF ...\n\n\n      if (oneCharAfter === '\\n') {\n        if (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {\n          return;\n        }\n      }\n    }\n\n    if (targetWhitespace === 'space' && oneCharAfter === ' ') {\n      if (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {\n        return;\n      }\n    }\n\n    const msgFunc = assertFunction(messageFunc);\n    activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n  }\n  /**\n   * @param {Function} [messageFunc]\n   */\n\n\n  function rejectAfter(messageFunc = messages.rejectedAfter) {\n    const _activeArgs5 = activeArgs;\n    const source = _activeArgs5.source;\n    const index = _activeArgs5.index;\n    const oneCharAfter = source[index + 1];\n\n    if (isValue(oneCharAfter) && isWhitespace(oneCharAfter)) {\n      const msgFunc = assertFunction(messageFunc);\n      activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n    }\n  }\n\n  return {\n    before,\n    beforeAllowingIndentation,\n    after,\n    afterOneOnly\n  };\n};\n/**\n * @param {any} x\n */\n\n\nfunction isValue(x) {\n  return x !== undefined && x !== null;\n}\n/**\n * @param {unknown} x\n */\n\n\nfunction assertFunction(x) {\n  if (typeof x === 'function') {\n    return x;\n  }\n\n  throw new Error(`\\`${x}\\` must be a function`);\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/whitespaceChecker.js"],"names":["configurationError","require","isSingleLineString","isWhitespace","module","exports","targetWhitespace","expectation","messages","activeArgs","before","source","index","err","errTarget","lineCheckStr","onlyOneChar","allowIndentation","expectBefore","rejectBefore","expectedBeforeSingleLine","rejectedBeforeSingleLine","expectedBeforeMultiLine","rejectedBeforeMultiLine","after","expectAfter","rejectAfter","expectedAfterSingleLine","rejectedAfterSingleLine","expectedAfterMultiLine","rejectedAfterMultiLine","beforeAllowingIndentation","obj","messageFunc","expectedBefore","expectBeforeAllowingIndentation","_activeArgs","oneCharBefore","twoCharsBefore","isValue","msgFunc","assertFunction","_activeArgs2","expectedChar","i","rejectedBefore","_activeArgs3","afterOneOnly","expectedAfter","_activeArgs4","oneCharAfter","twoCharsAfter","rejectedAfter","_activeArgs5","x","undefined","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nconst configurationError = require('./configurationError');\nconst isSingleLineString = require('./isSingleLineString');\nconst isWhitespace = require('./isWhitespace');\n\n/**\n * @typedef {object} Messages\n * @property {function} [expectedBefore]\n * @property {function} [rejectedBefore]\n * @property {function} [expectedAfter]\n * @property {function} [rejectedAfter]\n * @property {function} [expectedBeforeSingleLine]\n * @property {function} [rejectedBeforeSingleLine]\n * @property {function} [expectedBeforeMultiLine]\n * @property {function} [rejectedBeforeMultiLine]\n * @property {function} [expectedAfterSingleLine]\n * @property {function} [rejectedAfterSingleLine]\n * @property {function} [expectedAfterMultiLine]\n * @property {function} [rejectedAfterMultiLine]\n */\n\n/**\n * @typedef {object} WhitespaceCheckerArgs\n * @property {string} source - The source string\n * @property {number} index - The index of the character to check before\n * @property {function} err - If a violation is found, this callback\n *   will be invoked with the relevant warning message.\n *   Typically this callback will report() the violation.\n * @property {function} errTarget - If a violation is found, this string\n *   will be sent to the relevant warning message.\n * @property {string} [lineCheckStr] - Single- and multi-line checkers\n *   will use this string to determine whether they should proceed,\n *   i.e. if this string is one line only, single-line checkers will check,\n *   multi-line checkers will ignore.\n *   If none is passed, they will use `source`.\n * @property {boolean} [onlyOneChar=false] - Only check *one* character before.\n *   By default, \"always-*\" checks will look for the `targetWhitespace` one\n *   before and then ensure there is no whitespace two before. This option\n *   bypasses that second check.\n * @property {boolean} [allowIndentation=false] - Allow arbitrary indentation\n *   between the `targetWhitespace` (almost definitely a newline) and the `index`.\n *   With this option, the checker will see if a newline *begins* the whitespace before\n *   the `index`.\n */\n\n/**\n * @callback WhitespaceChecker\n * @param {WhitespaceCheckerArgs} args\n */\n\n/**\n * Create a whitespaceChecker, which exposes the following functions:\n * - `before()`\n * - `beforeAllowingIndentation()`\n * - `after()`\n * - `afterOneOnly()`\n *\n * @param {\"space\" | \"newline\"} targetWhitespace - This is a keyword instead\n *   of the actual character (e.g. \" \") in order to accommodate\n *   different styles of newline (\"\\n\" vs \"\\r\\n\")\n * @param { \"always\" | \"never\" | \"always-single-line\" | \"always-multi-line\" | \"never-single-line\" | \"never-multi-line\" } expectation\n * @param {Messages} messages - An object of message functions;\n *   calling `before*()` or `after*()` and the `expectation` that is passed\n *   determines which message functions are required\n *\n * @returns {object} The checker, with its exposed checking functions\n */\nmodule.exports = function (targetWhitespace, expectation, messages) {\n\t// Keep track of active arguments in order to avoid passing\n\t// too much stuff around, making signatures long and confusing.\n\t// This variable gets reset anytime a checking function is called.\n\t/**\n\t * @type {{\n\t\t\tsource?: any,\n\t\t\tindex?: any,\n\t\t\terr: any,\n\t\t\terrTarget: any,\n\t\t\tonlyOneChar: any,\n\t\t\tallowIndentation?: any,\n\t\t}}\n\t*/\n\tlet activeArgs;\n\n\t/**\n\t * Check for whitespace *before* a character.\n\t * @type {WhitespaceChecker}\n\t */\n\tfunction before({\n\t\tsource,\n\t\tindex,\n\t\terr,\n\t\terrTarget,\n\t\tlineCheckStr,\n\t\tonlyOneChar = false,\n\t\tallowIndentation = false,\n\t}) {\n\t\tactiveArgs = {\n\t\t\tsource,\n\t\t\tindex,\n\t\t\terr,\n\t\t\terrTarget,\n\t\t\tonlyOneChar,\n\t\t\tallowIndentation,\n\t\t};\n\n\t\tswitch (expectation) {\n\t\t\tcase 'always':\n\t\t\t\texpectBefore();\n\t\t\t\tbreak;\n\t\t\tcase 'never':\n\t\t\t\trejectBefore();\n\t\t\t\tbreak;\n\t\t\tcase 'always-single-line':\n\t\t\t\tif (!isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\texpectBefore(messages.expectedBeforeSingleLine);\n\t\t\t\tbreak;\n\t\t\tcase 'never-single-line':\n\t\t\t\tif (!isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trejectBefore(messages.rejectedBeforeSingleLine);\n\t\t\t\tbreak;\n\t\t\tcase 'always-multi-line':\n\t\t\t\tif (isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\texpectBefore(messages.expectedBeforeMultiLine);\n\t\t\t\tbreak;\n\t\t\tcase 'never-multi-line':\n\t\t\t\tif (isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trejectBefore(messages.rejectedBeforeMultiLine);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow configurationError(`Unknown expectation \"${expectation}\"`);\n\t\t}\n\t}\n\n\t/**\n\t * Check for whitespace *after* a character.\n\t * @type {WhitespaceChecker}\n\t */\n\tfunction after({ source, index, err, errTarget, lineCheckStr, onlyOneChar = false }) {\n\t\tactiveArgs = { source, index, err, errTarget, onlyOneChar };\n\n\t\tswitch (expectation) {\n\t\t\tcase 'always':\n\t\t\t\texpectAfter();\n\t\t\t\tbreak;\n\t\t\tcase 'never':\n\t\t\t\trejectAfter();\n\t\t\t\tbreak;\n\t\t\tcase 'always-single-line':\n\t\t\t\tif (!isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\texpectAfter(messages.expectedAfterSingleLine);\n\t\t\t\tbreak;\n\t\t\tcase 'never-single-line':\n\t\t\t\tif (!isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trejectAfter(messages.rejectedAfterSingleLine);\n\t\t\t\tbreak;\n\t\t\tcase 'always-multi-line':\n\t\t\t\tif (isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\texpectAfter(messages.expectedAfterMultiLine);\n\t\t\t\tbreak;\n\t\t\tcase 'never-multi-line':\n\t\t\t\tif (isSingleLineString(lineCheckStr || source)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trejectAfter(messages.rejectedAfterMultiLine);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow configurationError(`Unknown expectation \"${expectation}\"`);\n\t\t}\n\t}\n\n\t/**\n\t * @param {WhitespaceCheckerArgs} obj\n\t */\n\tfunction beforeAllowingIndentation(obj) {\n\t\tbefore({ ...obj, allowIndentation: true });\n\t}\n\n\t/**\n\t * @param {Function} [messageFunc]\n\t */\n\tfunction expectBefore(messageFunc = messages.expectedBefore) {\n\t\tif (activeArgs.allowIndentation) {\n\t\t\texpectBeforeAllowingIndentation(messageFunc);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst _activeArgs = activeArgs;\n\t\tconst source = _activeArgs.source;\n\t\tconst index = _activeArgs.index;\n\n\t\tconst oneCharBefore = source[index - 1];\n\t\tconst twoCharsBefore = source[index - 2];\n\n\t\tif (!isValue(oneCharBefore)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (targetWhitespace === 'space' && oneCharBefore === ' ') {\n\t\t\tif (activeArgs.onlyOneChar || !isWhitespace(twoCharsBefore)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst msgFunc = assertFunction(messageFunc);\n\n\t\tactiveArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n\t}\n\n\t/**\n\t * @param {Function} [messageFunc]\n\t */\n\tfunction expectBeforeAllowingIndentation(messageFunc = messages.expectedBefore) {\n\t\tconst _activeArgs2 = activeArgs;\n\t\tconst source = _activeArgs2.source;\n\t\tconst index = _activeArgs2.index;\n\t\tconst err = _activeArgs2.err;\n\n\t\tconst expectedChar = (function () {\n\t\t\tif (targetWhitespace === 'newline') {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t})();\n\t\tlet i = index - 1;\n\n\t\twhile (source[i] !== expectedChar) {\n\t\t\tif (source[i] === '\\t' || source[i] === ' ') {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst msgFunc = assertFunction(messageFunc);\n\n\t\t\terr(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Function} [messageFunc]\n\t */\n\tfunction rejectBefore(messageFunc = messages.rejectedBefore) {\n\t\tconst _activeArgs3 = activeArgs;\n\t\tconst source = _activeArgs3.source;\n\t\tconst index = _activeArgs3.index;\n\n\t\tconst oneCharBefore = source[index - 1];\n\n\t\tif (isValue(oneCharBefore) && isWhitespace(oneCharBefore)) {\n\t\t\tconst msgFunc = assertFunction(messageFunc);\n\n\t\t\tactiveArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n\t\t}\n\t}\n\n\t/**\n\t * @param {WhitespaceCheckerArgs} obj\n\t */\n\tfunction afterOneOnly(obj) {\n\t\tafter({ ...obj, onlyOneChar: true });\n\t}\n\n\t/**\n\t * @param {Function} [messageFunc]\n\t */\n\tfunction expectAfter(messageFunc = messages.expectedAfter) {\n\t\tconst _activeArgs4 = activeArgs;\n\t\tconst source = _activeArgs4.source;\n\t\tconst index = _activeArgs4.index;\n\n\t\tconst oneCharAfter = source[index + 1];\n\t\tconst twoCharsAfter = source[index + 2];\n\n\t\tif (!isValue(oneCharAfter)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (targetWhitespace === 'newline') {\n\t\t\t// If index is followed by a Windows CR-LF ...\n\t\t\tif (oneCharAfter === '\\r' && twoCharsAfter === '\\n') {\n\t\t\t\tif (activeArgs.onlyOneChar || !isWhitespace(source[index + 3])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If index is followed by a Unix LF ...\n\t\t\tif (oneCharAfter === '\\n') {\n\t\t\t\tif (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetWhitespace === 'space' && oneCharAfter === ' ') {\n\t\t\tif (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst msgFunc = assertFunction(messageFunc);\n\n\t\tactiveArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n\t}\n\n\t/**\n\t * @param {Function} [messageFunc]\n\t */\n\tfunction rejectAfter(messageFunc = messages.rejectedAfter) {\n\t\tconst _activeArgs5 = activeArgs;\n\t\tconst source = _activeArgs5.source;\n\t\tconst index = _activeArgs5.index;\n\n\t\tconst oneCharAfter = source[index + 1];\n\n\t\tif (isValue(oneCharAfter) && isWhitespace(oneCharAfter)) {\n\t\t\tconst msgFunc = assertFunction(messageFunc);\n\n\t\t\tactiveArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n\t\t}\n\t}\n\n\treturn {\n\t\tbefore,\n\t\tbeforeAllowingIndentation,\n\t\tafter,\n\t\tafterOneOnly,\n\t};\n};\n\n/**\n * @param {any} x\n */\nfunction isValue(x) {\n\treturn x !== undefined && x !== null;\n}\n\n/**\n * @param {unknown} x\n */\nfunction assertFunction(x) {\n\tif (typeof x === 'function') {\n\t\treturn x;\n\t}\n\n\tthrow new Error(`\\`${x}\\` must be a function`);\n}\n"]},"metadata":{},"sourceType":"script"}