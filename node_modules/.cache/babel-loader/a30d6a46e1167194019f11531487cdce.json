{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'number-no-trailing-zeros';\nconst messages = ruleMessages(ruleName, {\n  rejected: 'Unexpected trailing zero(s)'\n});\n\nfunction rule(actual, secondary, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(atRule => {\n      if (atRule.name.toLowerCase() === 'import') {\n        return;\n      }\n\n      check(atRule, atRule.params, atRuleParamIndex);\n    });\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));\n\n    function check(node, value, getIndex) {\n      const fixPositions = []; // Get out quickly if there are no periods\n\n      if (!value.includes('.')) {\n        return;\n      }\n\n      valueParser(value).walk(valueNode => {\n        // Ignore `url` function\n        if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {\n          return false;\n        } // Ignore strings, comments, etc\n\n\n        if (valueNode.type !== 'word') {\n          return;\n        }\n\n        const match = /\\.(\\d*?)(0+)(?:\\D|$)/.exec(valueNode.value); // match[1] is any numbers between the decimal and our trailing zero, could be empty\n        // match[2] is our trailing zero(s)\n\n        if (match === null) {\n          return;\n        } // our index is:\n        //  the index of our valueNode +\n        //  the index of our match +\n        //  1 for our decimal +\n        //  the length of our potential non-zero number match (match[1])\n\n\n        const index = valueNode.sourceIndex + match.index + 1 + match[1].length; // our startIndex is identical to our index except when we have only\n        // trailing zeros after our decimal. in that case we don't need the decimal\n        // either so we move our index back by 1.\n\n        const startIndex = match[1].length > 0 ? index : index - 1; // our end index is our original index + the length of our trailing zeros\n\n        const endIndex = index + match[2].length;\n\n        if (context.fix) {\n          fixPositions.unshift({\n            startIndex,\n            endIndex\n          });\n          return;\n        }\n\n        report({\n          message: messages.rejected,\n          node,\n          // this is the index of the _first_ trailing zero\n          index: getIndex(node) + index,\n          result,\n          ruleName\n        });\n      });\n\n      if (fixPositions.length) {\n        fixPositions.forEach(fixPosition => {\n          const startIndex = fixPosition.startIndex;\n          const endIndex = fixPosition.endIndex;\n\n          if (node.type === 'atrule') {\n            node.params = removeTrailingZeros(node.params, startIndex, endIndex);\n          } else {\n            node.value = removeTrailingZeros(node.value, startIndex, endIndex);\n          }\n        });\n      }\n    }\n  };\n}\n\nfunction removeTrailingZeros(input, startIndex, endIndex) {\n  return input.slice(0, startIndex) + input.slice(endIndex);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/number-no-trailing-zeros/index.js"],"names":["atRuleParamIndex","require","declarationValueIndex","report","ruleMessages","validateOptions","valueParser","ruleName","messages","rejected","rule","actual","secondary","context","root","result","validOptions","walkAtRules","atRule","name","toLowerCase","check","params","walkDecls","decl","value","node","getIndex","fixPositions","includes","walk","valueNode","type","match","exec","index","sourceIndex","length","startIndex","endIndex","fix","unshift","message","forEach","fixPosition","removeTrailingZeros","input","slice","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'number-no-trailing-zeros';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: 'Unexpected trailing zero(s)',\n});\n\nfunction rule(actual, secondary, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, { actual });\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkAtRules((atRule) => {\n\t\t\tif (atRule.name.toLowerCase() === 'import') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcheck(atRule, atRule.params, atRuleParamIndex);\n\t\t});\n\n\t\troot.walkDecls((decl) => check(decl, decl.value, declarationValueIndex));\n\n\t\tfunction check(node, value, getIndex) {\n\t\t\tconst fixPositions = [];\n\n\t\t\t// Get out quickly if there are no periods\n\t\t\tif (!value.includes('.')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalueParser(value).walk((valueNode) => {\n\t\t\t\t// Ignore `url` function\n\t\t\t\tif (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Ignore strings, comments, etc\n\t\t\t\tif (valueNode.type !== 'word') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst match = /\\.(\\d*?)(0+)(?:\\D|$)/.exec(valueNode.value);\n\n\t\t\t\t// match[1] is any numbers between the decimal and our trailing zero, could be empty\n\t\t\t\t// match[2] is our trailing zero(s)\n\t\t\t\tif (match === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// our index is:\n\t\t\t\t//  the index of our valueNode +\n\t\t\t\t//  the index of our match +\n\t\t\t\t//  1 for our decimal +\n\t\t\t\t//  the length of our potential non-zero number match (match[1])\n\t\t\t\tconst index = valueNode.sourceIndex + match.index + 1 + match[1].length;\n\n\t\t\t\t// our startIndex is identical to our index except when we have only\n\t\t\t\t// trailing zeros after our decimal. in that case we don't need the decimal\n\t\t\t\t// either so we move our index back by 1.\n\t\t\t\tconst startIndex = match[1].length > 0 ? index : index - 1;\n\n\t\t\t\t// our end index is our original index + the length of our trailing zeros\n\t\t\t\tconst endIndex = index + match[2].length;\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tfixPositions.unshift({\n\t\t\t\t\t\tstartIndex,\n\t\t\t\t\t\tendIndex,\n\t\t\t\t\t});\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.rejected,\n\t\t\t\t\tnode,\n\t\t\t\t\t// this is the index of the _first_ trailing zero\n\t\t\t\t\tindex: getIndex(node) + index,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (fixPositions.length) {\n\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\tconst startIndex = fixPosition.startIndex;\n\t\t\t\t\tconst endIndex = fixPosition.endIndex;\n\n\t\t\t\t\tif (node.type === 'atrule') {\n\t\t\t\t\t\tnode.params = removeTrailingZeros(node.params, startIndex, endIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.value = removeTrailingZeros(node.value, startIndex, endIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction removeTrailingZeros(input, startIndex, endIndex) {\n\treturn input.slice(0, startIndex) + input.slice(endIndex);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}