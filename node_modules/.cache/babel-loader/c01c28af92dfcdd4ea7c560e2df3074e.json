{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst postcss = require('postcss');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'linebreaks';\nconst messages = ruleMessages(ruleName, {\n  expected: linebreak => `Expected linebreak to be ${linebreak}`\n});\n\nfunction rule(actual, secondary, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual,\n      possible: ['unix', 'windows']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const shouldHaveCR = actual === 'windows';\n\n    if (context.fix) {\n      const propertiesToUpdate = ['selector', 'raws.before', 'raws.after', 'value', 'text'];\n      root.walk(node => {\n        propertiesToUpdate.forEach(property => {\n          const fixedData = fixData(_.get(node, property), shouldHaveCR);\n\n          _.set(node, property, fixedData);\n        });\n      });\n      root.raws.after = fixData(root.raws.after, shouldHaveCR);\n    } else {\n      const lines = root.source.input.css.split('\\n');\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n\n        if (i < lines.length - 1 && !line.includes('\\r')) {\n          line += '\\n';\n        }\n\n        if (hasError(line, shouldHaveCR)) {\n          const lineNum = i + 1;\n          const colNum = line.length;\n          reportNewlineError(shouldHaveCR, lineNum, colNum, actual, result);\n        }\n      }\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function hasError(dataToCheck, shouldHaveCR) {\n      const hasNewlineToVerify = /[\\r\\n]/.test(dataToCheck);\n      const hasCR = hasNewlineToVerify ? /\\r/.test(dataToCheck) : false;\n      return hasNewlineToVerify && hasCR !== shouldHaveCR;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function fixData(data, shouldHaveCR) {\n      if (data) {\n        // TODO: Issue #4985\n        // eslint-disable-next-line no-shadow\n        let result = data.replace(/\\r/g, '');\n\n        if (shouldHaveCR) {\n          result = result.replace(/\\n/g, '\\r\\n');\n        }\n\n        return result;\n      }\n\n      return data;\n    }\n\n    function createReportNode(line, column) {\n      // Creating a node manually helps us to point to empty lines.\n      return postcss.rule({\n        source: {\n          start: {\n            line,\n            column\n          }\n        }\n      });\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function reportNewlineError(shouldHaveCR, lineNum, colNum, actual, result) {\n      const reportNode = createReportNode(lineNum, colNum);\n      report({\n        message: messages.expected(actual),\n        node: reportNode,\n        result,\n        ruleName\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/linebreaks/index.js"],"names":["_","require","postcss","report","ruleMessages","validateOptions","ruleName","messages","expected","linebreak","rule","actual","secondary","context","root","result","validOptions","possible","shouldHaveCR","fix","propertiesToUpdate","walk","node","forEach","property","fixedData","fixData","get","set","raws","after","lines","source","input","css","split","i","length","line","includes","hasError","lineNum","colNum","reportNewlineError","dataToCheck","hasNewlineToVerify","test","hasCR","data","replace","createReportNode","column","start","reportNode","message","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst postcss = require('postcss');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'linebreaks';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (linebreak) => `Expected linebreak to be ${linebreak}`,\n});\n\nfunction rule(actual, secondary, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual,\n\t\t\tpossible: ['unix', 'windows'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst shouldHaveCR = actual === 'windows';\n\n\t\tif (context.fix) {\n\t\t\tconst propertiesToUpdate = ['selector', 'raws.before', 'raws.after', 'value', 'text'];\n\n\t\t\troot.walk((node) => {\n\t\t\t\tpropertiesToUpdate.forEach((property) => {\n\t\t\t\t\tconst fixedData = fixData(_.get(node, property), shouldHaveCR);\n\n\t\t\t\t\t_.set(node, property, fixedData);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\troot.raws.after = fixData(root.raws.after, shouldHaveCR);\n\t\t} else {\n\t\t\tconst lines = root.source.input.css.split('\\n');\n\n\t\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\t\tlet line = lines[i];\n\n\t\t\t\tif (i < lines.length - 1 && !line.includes('\\r')) {\n\t\t\t\t\tline += '\\n';\n\t\t\t\t}\n\n\t\t\t\tif (hasError(line, shouldHaveCR)) {\n\t\t\t\t\tconst lineNum = i + 1;\n\t\t\t\t\tconst colNum = line.length;\n\n\t\t\t\t\treportNewlineError(shouldHaveCR, lineNum, colNum, actual, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction hasError(dataToCheck, shouldHaveCR) {\n\t\t\tconst hasNewlineToVerify = /[\\r\\n]/.test(dataToCheck);\n\t\t\tconst hasCR = hasNewlineToVerify ? /\\r/.test(dataToCheck) : false;\n\n\t\t\treturn hasNewlineToVerify && hasCR !== shouldHaveCR;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction fixData(data, shouldHaveCR) {\n\t\t\tif (data) {\n\t\t\t\t// TODO: Issue #4985\n\t\t\t\t// eslint-disable-next-line no-shadow\n\t\t\t\tlet result = data.replace(/\\r/g, '');\n\n\t\t\t\tif (shouldHaveCR) {\n\t\t\t\t\tresult = result.replace(/\\n/g, '\\r\\n');\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction createReportNode(line, column) {\n\t\t\t// Creating a node manually helps us to point to empty lines.\n\t\t\treturn postcss.rule({\n\t\t\t\tsource: {\n\t\t\t\t\tstart: {\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tcolumn,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction reportNewlineError(shouldHaveCR, lineNum, colNum, actual, result) {\n\t\t\tconst reportNode = createReportNode(lineNum, colNum);\n\n\t\t\treport({\n\t\t\t\tmessage: messages.expected(actual),\n\t\t\t\tnode: reportNode,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}