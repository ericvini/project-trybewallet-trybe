{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst keywordSets = require('../../reference/keywordSets');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst postcss = require('postcss');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst vendor = require('../../utils/vendor');\n\nconst ruleName = 'time-min-milliseconds';\nconst messages = ruleMessages(ruleName, {\n  expected: time => `Expected a minimum of ${time} milliseconds`\n});\nconst DELAY_PROPERTIES = ['animation-delay', 'transition-delay'];\n\nfunction rule(minimum, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: minimum,\n      possible: _.isNumber\n    }, {\n      actual: options,\n      possible: {\n        ignore: ['delay']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      const propertyName = vendor.unprefixed(decl.prop.toLowerCase());\n\n      if (keywordSets.longhandTimeProperties.has(propertyName) && !isIgnoredProperty(propertyName) && !isAcceptableTime(decl.value)) {\n        complain(decl);\n      }\n\n      if (keywordSets.shorthandTimeProperties.has(propertyName)) {\n        const valueListList = postcss.list.comma(decl.value);\n\n        for (const valueListString of valueListList) {\n          const valueList = postcss.list.space(valueListString);\n\n          if (optionsMatches(options, 'ignore', 'delay')) {\n            // Check only duration time values\n            const duration = getDuration(valueList);\n\n            if (duration && !isAcceptableTime(duration)) {\n              complain(decl, decl.value.indexOf(duration));\n            }\n          } else {\n            // Check all time values\n            for (const value of valueList) {\n              if (!isAcceptableTime(value)) {\n                complain(decl, decl.value.indexOf(value));\n              }\n            }\n          }\n        }\n      }\n    });\n    /**\n     * Get the duration within an `animation` or `transition` shorthand property value.\n     *\n     * @param {Node[]} valueList\n     *\n     * @returns {Node}\n     */\n\n    function getDuration(valueList) {\n      for (const value of valueList) {\n        const parsedTime = valueParser.unit(value);\n        if (!parsedTime) continue; // The first numeric value in an animation shorthand is the duration.\n\n        return value;\n      }\n    }\n\n    function isIgnoredProperty(propertyName) {\n      if (optionsMatches(options, 'ignore', 'delay') && DELAY_PROPERTIES.includes(propertyName)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isAcceptableTime(time) {\n      const parsedTime = valueParser.unit(time);\n      if (!parsedTime) return true;\n\n      if (parsedTime.number <= 0) {\n        return true;\n      }\n\n      if (parsedTime.unit.toLowerCase() === 'ms' && parsedTime.number < minimum) {\n        return false;\n      }\n\n      if (parsedTime.unit.toLowerCase() === 's' && parsedTime.number * 1000 < minimum) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function complain(decl, offset = 0) {\n      report({\n        result,\n        ruleName,\n        message: messages.expected(minimum),\n        index: declarationValueIndex(decl) + offset,\n        node: decl\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/time-min-milliseconds/index.js"],"names":["_","require","declarationValueIndex","keywordSets","optionsMatches","postcss","report","ruleMessages","validateOptions","valueParser","vendor","ruleName","messages","expected","time","DELAY_PROPERTIES","rule","minimum","options","root","result","validOptions","actual","possible","isNumber","ignore","optional","walkDecls","decl","propertyName","unprefixed","prop","toLowerCase","longhandTimeProperties","has","isIgnoredProperty","isAcceptableTime","value","complain","shorthandTimeProperties","valueListList","list","comma","valueListString","valueList","space","duration","getDuration","indexOf","parsedTime","unit","includes","number","offset","message","index","node","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst keywordSets = require('../../reference/keywordSets');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst postcss = require('postcss');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\nconst vendor = require('../../utils/vendor');\n\nconst ruleName = 'time-min-milliseconds';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (time) => `Expected a minimum of ${time} milliseconds`,\n});\n\nconst DELAY_PROPERTIES = ['animation-delay', 'transition-delay'];\n\nfunction rule(minimum, options) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: minimum,\n\t\t\t\tpossible: _.isNumber,\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['delay'],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst propertyName = vendor.unprefixed(decl.prop.toLowerCase());\n\n\t\t\tif (\n\t\t\t\tkeywordSets.longhandTimeProperties.has(propertyName) &&\n\t\t\t\t!isIgnoredProperty(propertyName) &&\n\t\t\t\t!isAcceptableTime(decl.value)\n\t\t\t) {\n\t\t\t\tcomplain(decl);\n\t\t\t}\n\n\t\t\tif (keywordSets.shorthandTimeProperties.has(propertyName)) {\n\t\t\t\tconst valueListList = postcss.list.comma(decl.value);\n\n\t\t\t\tfor (const valueListString of valueListList) {\n\t\t\t\t\tconst valueList = postcss.list.space(valueListString);\n\n\t\t\t\t\tif (optionsMatches(options, 'ignore', 'delay')) {\n\t\t\t\t\t\t// Check only duration time values\n\t\t\t\t\t\tconst duration = getDuration(valueList);\n\n\t\t\t\t\t\tif (duration && !isAcceptableTime(duration)) {\n\t\t\t\t\t\t\tcomplain(decl, decl.value.indexOf(duration));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check all time values\n\t\t\t\t\t\tfor (const value of valueList) {\n\t\t\t\t\t\t\tif (!isAcceptableTime(value)) {\n\t\t\t\t\t\t\t\tcomplain(decl, decl.value.indexOf(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Get the duration within an `animation` or `transition` shorthand property value.\n\t\t *\n\t\t * @param {Node[]} valueList\n\t\t *\n\t\t * @returns {Node}\n\t\t */\n\t\tfunction getDuration(valueList) {\n\t\t\tfor (const value of valueList) {\n\t\t\t\tconst parsedTime = valueParser.unit(value);\n\n\t\t\t\tif (!parsedTime) continue;\n\n\t\t\t\t// The first numeric value in an animation shorthand is the duration.\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tfunction isIgnoredProperty(propertyName) {\n\t\t\tif (optionsMatches(options, 'ignore', 'delay') && DELAY_PROPERTIES.includes(propertyName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction isAcceptableTime(time) {\n\t\t\tconst parsedTime = valueParser.unit(time);\n\n\t\t\tif (!parsedTime) return true;\n\n\t\t\tif (parsedTime.number <= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (parsedTime.unit.toLowerCase() === 'ms' && parsedTime.number < minimum) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (parsedTime.unit.toLowerCase() === 's' && parsedTime.number * 1000 < minimum) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction complain(decl, offset = 0) {\n\t\t\treport({\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t\tmessage: messages.expected(minimum),\n\t\t\t\tindex: declarationValueIndex(decl) + offset,\n\t\t\t\tnode: decl,\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}