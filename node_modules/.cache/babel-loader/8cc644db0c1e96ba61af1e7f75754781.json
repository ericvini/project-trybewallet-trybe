{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\n\nconst mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'media-query-list-comma-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \",\"',\n  expectedAfterMultiLine: () => 'Expected newline after \",\" in a multi-line list',\n  rejectedAfterMultiLine: () => 'Unexpected whitespace after \",\" in a multi-line list'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    } // Only check for the newline after the comma, while allowing\n    // arbitrary indentation after the newline\n\n\n    let fixData;\n    mediaQueryListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.afterOneOnly,\n      checkedRuleName: ruleName,\n      allowTrailingComments: expectation.startsWith('always'),\n      fix: context.fix ? (atRule, index) => {\n        const paramCommaIndex = index - atRuleParamIndex(atRule);\n        fixData = fixData || new Map();\n        const commaIndices = fixData.get(atRule) || [];\n        commaIndices.push(paramCommaIndex);\n        fixData.set(atRule, commaIndices);\n        return true;\n      } : null\n    });\n\n    if (fixData) {\n      fixData.forEach((commaIndices, atRule) => {\n        let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;\n        commaIndices.sort((a, b) => b - a).forEach(index => {\n          const beforeComma = params.slice(0, index + 1);\n          const afterComma = params.slice(index + 1);\n\n          if (expectation.startsWith('always')) {\n            if (/^\\s*\\r?\\n/.test(afterComma)) {\n              params = beforeComma + afterComma.replace(/^[^\\S\\r\\n]*/, '');\n            } else {\n              params = beforeComma + context.newline + afterComma;\n            }\n          } else if (expectation.startsWith('never')) {\n            params = beforeComma + afterComma.replace(/^\\s*/, '');\n          }\n        });\n\n        if (atRule.raws.params) {\n          atRule.raws.params.raw = params;\n        } else {\n          atRule.params = params;\n        }\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/media-query-list-comma-newline-after/index.js"],"names":["atRuleParamIndex","require","mediaQueryListCommaWhitespaceChecker","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","fixData","locationChecker","afterOneOnly","checkedRuleName","allowTrailingComments","startsWith","fix","atRule","index","paramCommaIndex","Map","commaIndices","get","push","set","forEach","params","raws","raw","sort","a","b","beforeComma","slice","afterComma","test","replace","newline","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\nconst mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'media-query-list-comma-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \",\"',\n\texpectedAfterMultiLine: () => 'Expected newline after \",\" in a multi-line list',\n\trejectedAfterMultiLine: () => 'Unexpected whitespace after \",\" in a multi-line list',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only check for the newline after the comma, while allowing\n\t\t// arbitrary indentation after the newline\n\t\tlet fixData;\n\n\t\tmediaQueryListCommaWhitespaceChecker({\n\t\t\troot,\n\t\t\tresult,\n\t\t\tlocationChecker: checker.afterOneOnly,\n\t\t\tcheckedRuleName: ruleName,\n\t\t\tallowTrailingComments: expectation.startsWith('always'),\n\t\t\tfix: context.fix\n\t\t\t\t? (atRule, index) => {\n\t\t\t\t\t\tconst paramCommaIndex = index - atRuleParamIndex(atRule);\n\n\t\t\t\t\t\tfixData = fixData || new Map();\n\t\t\t\t\t\tconst commaIndices = fixData.get(atRule) || [];\n\n\t\t\t\t\t\tcommaIndices.push(paramCommaIndex);\n\t\t\t\t\t\tfixData.set(atRule, commaIndices);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t  }\n\t\t\t\t: null,\n\t\t});\n\n\t\tif (fixData) {\n\t\t\tfixData.forEach((commaIndices, atRule) => {\n\t\t\t\tlet params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;\n\n\t\t\t\tcommaIndices\n\t\t\t\t\t.sort((a, b) => b - a)\n\t\t\t\t\t.forEach((index) => {\n\t\t\t\t\t\tconst beforeComma = params.slice(0, index + 1);\n\t\t\t\t\t\tconst afterComma = params.slice(index + 1);\n\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tif (/^\\s*\\r?\\n/.test(afterComma)) {\n\t\t\t\t\t\t\t\tparams = beforeComma + afterComma.replace(/^[^\\S\\r\\n]*/, '');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparams = beforeComma + context.newline + afterComma;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (expectation.startsWith('never')) {\n\t\t\t\t\t\t\tparams = beforeComma + afterComma.replace(/^\\s*/, '');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\tif (atRule.raws.params) {\n\t\t\t\t\tatRule.raws.params.raw = params;\n\t\t\t\t} else {\n\t\t\t\t\tatRule.params = params;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}