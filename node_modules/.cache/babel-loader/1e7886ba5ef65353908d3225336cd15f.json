{"ast":null,"code":"import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-ff5147c6.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"parse\",\n\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"parse\",\n\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\n\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  _createClass(Collection, null, [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"parse\",\n\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  _createClass(Document, null, [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\n\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch && _ch !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch2 = src[i];\n\n        if (_ch2 === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch2 === ' ' || _ch2 === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"parse\",\n\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  _createClass(ParseContext, null, [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var lineStart = offset + 1;\n          var inEnd = Node.endOfIndent(src, lineStart);\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (!Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }]);\n\n  return ParseContext;\n}(); // Published as 'yaml/parse-cst'\n\n\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/yaml/browser/dist/parse-cst.js"],"names":["j","_inherits","k","_createSuper","c","_classCallCheck","T","Type","b","_createClass","R","Range","N","Node","g","YAMLSemanticError","l","_get","m","_getPrototypeOf","Y","YAMLSyntaxError","C","Char","e","_defineProperty","P","PlainValue","BlankLine","_Node","_super","call","BLANK_LINE","key","value","parse","context","start","range","get","CollectionItem","type","props","_this","node","parseNode","src","atLineStart","lineStart","SEQ_ITEM","error","indent","offset","endOfWhiteSpace","ch","inlineComment","comments","blankLine","_end","endOfLine","push","wsEnd","length","endOfIndent","nextNodeIsIndented","inCollection","parent","items","contents","Array","prototype","apply","end","valueRange","setOrigRanges","cr","toString","str","slice","String","addStringTerminator","includesTrailingLines","Comment","COMMENT","parseComment","grabCollectionEndComments","cnode","Collection","len","ci","i","n","_n$context","ca","splice","prevEnd","nextContentHasIndent","firstItem","SEQ","MAP","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","comment","atBlank","next","msg","_next","_msg","ls","prev","forEach","item","_item$context","_i","Directive","DIRECTIVE","name","parseName","parseParameters","raw","rawValue","trim","split","Document","startCommentOrEndBlankLine","DOCUMENT","directives","directivesEndMarker","documentEndMarker","parseDirectives","hasDirectives","atDocumentBoundary","DIRECTIVES_END","directive","parseContents","_this$context","DOCUMENT_END","iEnd","inFlow","_comment","undefined","root","charCodeAt","setOrigRange","join","Alias","arguments","endOfIdentifier","Chomp","CLIP","KEEP","STRIP","BlockValue","blockIndent","chomping","header","parseBlockHeader","bi","Number","parseBlockValue","explicit","valueEnd","minBlockIndent","endOfBlockIndent","_ch","lineIndent","_src","concat","_this$valueRange","_this$context2","isEmpty","lastNewLine","keepStart","folded","BLOCK_FOLDED","atStart","sep","prevMoreIndented","_ch2","lineEnd","line","FlowCollection","prevNodeIsJsonLike","idx","jsonLike","char","origOffset","nodes","filter","prefix","QuoteDouble","parseCharCode","errors","cc","substr","ok","test","code","parseInt","NaN","isNaN","fromCodePoint","endOfQuote","_Node$foldNewline","foldNewline","fold","wsStart","QuoteSingle","createNewNode","ALIAS","BLOCK_LITERAL","FLOW_MAP","FLOW_SEQ","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","ParseContext","parseType","orig","_ref","overlay","_context$parseProps","parseProps","valueStart","Error","parseEnd","source","nodeStartsCollection","collection","lineHasProps","ANCHOR","TAG","inEnd","indentDiff","noIndicatorAsIndent","indexOf","replace","match","documents","doc","crOffset"],"mappings":"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","sourcesContent":["import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-ff5147c6.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"parse\",\n\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"parse\",\n\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  _createClass(Collection, null, [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"parse\",\n\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  _createClass(Document, null, [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch && _ch !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch2 = src[i];\n\n        if (_ch2 === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch2 === ' ' || _ch2 === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"parse\",\n\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  _createClass(ParseContext, null, [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var lineStart = offset + 1;\n          var inEnd = Node.endOfIndent(src, lineStart);\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (!Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };\n"]},"metadata":{},"sourceType":"module"}