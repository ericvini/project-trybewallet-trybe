{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst declarationValueIndex = require('../utils/declarationValueIndex');\n\nconst isStandardSyntaxFunction = require('../utils/isStandardSyntaxFunction');\n\nconst report = require('../utils/report');\n\nconst valueParser = require('postcss-value-parser');\n\nmodule.exports = function (opts) {\n  opts.root.walkDecls(decl => {\n    const declValue = _.get(decl, 'raws.value.raw', decl.value);\n\n    let hasFixed;\n    const parsedValue = valueParser(declValue);\n    parsedValue.walk(valueNode => {\n      if (valueNode.type !== 'function') {\n        return;\n      }\n\n      if (!isStandardSyntaxFunction(valueNode)) {\n        return;\n      } // Ignore `url()` arguments, which may contain data URIs or other funky stuff\n\n\n      if (valueNode.value.toLowerCase() === 'url') {\n        return;\n      }\n\n      const argumentStrings = valueNode.nodes.map(node => valueParser.stringify(node));\n\n      const functionArguments = (() => {\n        // Remove function name and parens\n        let result = valueNode.before + argumentStrings.join('') + valueNode.after; // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)\n        // 2. Remove all other comments, but leave adjacent whitespace intact\n\n        result = result.replace(/( *\\/(\\*.*\\*\\/(?!\\S)|\\/.*)|(\\/(\\*.*\\*\\/|\\/.*)))/, '');\n        return result;\n      })();\n      /**\n       * Gets the index of the comma for checking.\n       * @param {Node} commaNode The comma node\n       * @param {number} nodeIndex The index of the comma node\n       * @returns {number} The index of the comma for checking\n       */\n\n\n      function getCommaCheckIndex(commaNode, nodeIndex) {\n        let commaBefore = valueNode.before + argumentStrings.slice(0, nodeIndex).join('') + commaNode.before; // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)\n        // 2. Remove all other comments, but leave adjacent whitespace intact\n\n        commaBefore = commaBefore.replace(/( *\\/(\\*.*\\*\\/(?!\\S)|\\/.*)|(\\/(\\*.*\\*\\/|\\/.*)))/, '');\n        return commaBefore.length;\n      }\n\n      const commaDataList = [];\n      valueNode.nodes.forEach((node, nodeIndex) => {\n        if (node.type !== 'div' || node.value !== ',') {\n          return;\n        }\n\n        const checkIndex = getCommaCheckIndex(node, nodeIndex);\n        commaDataList.push({\n          commaNode: node,\n          checkIndex,\n          nodeIndex\n        });\n      });\n\n      for (const {\n        commaNode,\n        checkIndex,\n        nodeIndex\n      } of commaDataList) {\n        opts.locationChecker({\n          source: functionArguments,\n          index: checkIndex,\n          err: message => {\n            const index = declarationValueIndex(decl) + commaNode.sourceIndex + commaNode.before.length;\n\n            if (opts.fix && opts.fix(commaNode, nodeIndex, valueNode.nodes)) {\n              hasFixed = true;\n              return;\n            }\n\n            report({\n              index,\n              message,\n              node: decl,\n              result: opts.result,\n              ruleName: opts.checkedRuleName\n            });\n          }\n        });\n      }\n    });\n\n    if (hasFixed) {\n      if (!decl.raws.value) {\n        decl.value = parsedValue.toString();\n      } else {\n        decl.raws.value.raw = parsedValue.toString();\n      }\n    }\n  });\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/functionCommaSpaceChecker.js"],"names":["_","require","declarationValueIndex","isStandardSyntaxFunction","report","valueParser","module","exports","opts","root","walkDecls","decl","declValue","get","value","hasFixed","parsedValue","walk","valueNode","type","toLowerCase","argumentStrings","nodes","map","node","stringify","functionArguments","result","before","join","after","replace","getCommaCheckIndex","commaNode","nodeIndex","commaBefore","slice","length","commaDataList","forEach","checkIndex","push","locationChecker","source","index","err","message","sourceIndex","fix","ruleName","checkedRuleName","raws","toString","raw"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst declarationValueIndex = require('../utils/declarationValueIndex');\nconst isStandardSyntaxFunction = require('../utils/isStandardSyntaxFunction');\nconst report = require('../utils/report');\nconst valueParser = require('postcss-value-parser');\n\nmodule.exports = function (opts) {\n\topts.root.walkDecls((decl) => {\n\t\tconst declValue = _.get(decl, 'raws.value.raw', decl.value);\n\n\t\tlet hasFixed;\n\t\tconst parsedValue = valueParser(declValue);\n\n\t\tparsedValue.walk((valueNode) => {\n\t\t\tif (valueNode.type !== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isStandardSyntaxFunction(valueNode)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore `url()` arguments, which may contain data URIs or other funky stuff\n\t\t\tif (valueNode.value.toLowerCase() === 'url') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst argumentStrings = valueNode.nodes.map((node) => valueParser.stringify(node));\n\n\t\t\tconst functionArguments = (() => {\n\t\t\t\t// Remove function name and parens\n\t\t\t\tlet result = valueNode.before + argumentStrings.join('') + valueNode.after;\n\n\t\t\t\t// 1. Remove comments including preceding whitespace (when only succeeded by whitespace)\n\t\t\t\t// 2. Remove all other comments, but leave adjacent whitespace intact\n\t\t\t\tresult = result.replace(/( *\\/(\\*.*\\*\\/(?!\\S)|\\/.*)|(\\/(\\*.*\\*\\/|\\/.*)))/, '');\n\n\t\t\t\treturn result;\n\t\t\t})();\n\n\t\t\t/**\n\t\t\t * Gets the index of the comma for checking.\n\t\t\t * @param {Node} commaNode The comma node\n\t\t\t * @param {number} nodeIndex The index of the comma node\n\t\t\t * @returns {number} The index of the comma for checking\n\t\t\t */\n\t\t\tfunction getCommaCheckIndex(commaNode, nodeIndex) {\n\t\t\t\tlet commaBefore =\n\t\t\t\t\tvalueNode.before + argumentStrings.slice(0, nodeIndex).join('') + commaNode.before;\n\n\t\t\t\t// 1. Remove comments including preceding whitespace (when only succeeded by whitespace)\n\t\t\t\t// 2. Remove all other comments, but leave adjacent whitespace intact\n\t\t\t\tcommaBefore = commaBefore.replace(/( *\\/(\\*.*\\*\\/(?!\\S)|\\/.*)|(\\/(\\*.*\\*\\/|\\/.*)))/, '');\n\n\t\t\t\treturn commaBefore.length;\n\t\t\t}\n\n\t\t\tconst commaDataList = [];\n\n\t\t\tvalueNode.nodes.forEach((node, nodeIndex) => {\n\t\t\t\tif (node.type !== 'div' || node.value !== ',') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst checkIndex = getCommaCheckIndex(node, nodeIndex);\n\n\t\t\t\tcommaDataList.push({\n\t\t\t\t\tcommaNode: node,\n\t\t\t\t\tcheckIndex,\n\t\t\t\t\tnodeIndex,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfor (const { commaNode, checkIndex, nodeIndex } of commaDataList) {\n\t\t\t\topts.locationChecker({\n\t\t\t\t\tsource: functionArguments,\n\t\t\t\t\tindex: checkIndex,\n\t\t\t\t\terr: (message) => {\n\t\t\t\t\t\tconst index =\n\t\t\t\t\t\t\tdeclarationValueIndex(decl) + commaNode.sourceIndex + commaNode.before.length;\n\n\t\t\t\t\t\tif (opts.fix && opts.fix(commaNode, nodeIndex, valueNode.nodes)) {\n\t\t\t\t\t\t\thasFixed = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treport({\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tnode: decl,\n\t\t\t\t\t\t\tresult: opts.result,\n\t\t\t\t\t\t\truleName: opts.checkedRuleName,\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tif (hasFixed) {\n\t\t\tif (!decl.raws.value) {\n\t\t\t\tdecl.value = parsedValue.toString();\n\t\t\t} else {\n\t\t\t\tdecl.raws.value.raw = parsedValue.toString();\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}