{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-parentheses-space-inside';\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: 'Expected single space after \"(\"',\n  rejectedOpening: 'Unexpected whitespace after \"(\"',\n  expectedClosing: 'Expected single space before \")\"',\n  rejectedClosing: 'Unexpected whitespace before \")\"',\n  expectedOpeningSingleLine: 'Expected single space after \"(\" in a single-line function',\n  rejectedOpeningSingleLine: 'Unexpected whitespace after \"(\" in a single-line function',\n  expectedClosingSingleLine: 'Expected single space before \")\" in a single-line function',\n  rejectedClosingSingleLine: 'Unexpected whitespace before \")\" in a single-line function'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never', 'always-single-line', 'never-single-line']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      if (!decl.value.includes('(')) {\n        return;\n      }\n\n      let hasFixed = false;\n\n      const declValue = _.get(decl, 'raws.value.raw', decl.value);\n\n      const parsedValue = valueParser(declValue);\n      parsedValue.walk(valueNode => {\n        if (valueNode.type !== 'function') {\n          return;\n        }\n\n        if (!isStandardSyntaxFunction(valueNode)) {\n          return;\n        } // Ignore function without parameters\n\n\n        if (!valueNode.nodes.length) {\n          return;\n        }\n\n        const functionString = valueParser.stringify(valueNode);\n        const isSingleLine = isSingleLineString(functionString); // Check opening ...\n\n        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;\n\n        if (expectation === 'always' && valueNode.before !== ' ') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.before = ' ';\n          } else {\n            complain(messages.expectedOpening, openingIndex);\n          }\n        }\n\n        if (expectation === 'never' && valueNode.before !== '') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.before = '';\n          } else {\n            complain(messages.rejectedOpening, openingIndex);\n          }\n        }\n\n        if (isSingleLine && expectation === 'always-single-line' && valueNode.before !== ' ') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.before = ' ';\n          } else {\n            complain(messages.expectedOpeningSingleLine, openingIndex);\n          }\n        }\n\n        if (isSingleLine && expectation === 'never-single-line' && valueNode.before !== '') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.before = '';\n          } else {\n            complain(messages.rejectedOpeningSingleLine, openingIndex);\n          }\n        } // Check closing ...\n\n\n        const closingIndex = valueNode.sourceIndex + functionString.length - 2;\n\n        if (expectation === 'always' && valueNode.after !== ' ') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.after = ' ';\n          } else {\n            complain(messages.expectedClosing, closingIndex);\n          }\n        }\n\n        if (expectation === 'never' && valueNode.after !== '') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.after = '';\n          } else {\n            complain(messages.rejectedClosing, closingIndex);\n          }\n        }\n\n        if (isSingleLine && expectation === 'always-single-line' && valueNode.after !== ' ') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.after = ' ';\n          } else {\n            complain(messages.expectedClosingSingleLine, closingIndex);\n          }\n        }\n\n        if (isSingleLine && expectation === 'never-single-line' && valueNode.after !== '') {\n          if (context.fix) {\n            hasFixed = true;\n            valueNode.after = '';\n          } else {\n            complain(messages.rejectedClosingSingleLine, closingIndex);\n          }\n        }\n      });\n\n      if (hasFixed) {\n        if (!decl.raws.value) {\n          decl.value = parsedValue.toString();\n        } else {\n          decl.raws.value.raw = parsedValue.toString();\n        }\n      }\n\n      function complain(message, offset) {\n        report({\n          ruleName,\n          result,\n          message,\n          node: decl,\n          index: declarationValueIndex(decl) + offset\n        });\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/function-parentheses-space-inside/index.js"],"names":["_","require","declarationValueIndex","isSingleLineString","isStandardSyntaxFunction","report","ruleMessages","validateOptions","valueParser","ruleName","messages","expectedOpening","rejectedOpening","expectedClosing","rejectedClosing","expectedOpeningSingleLine","rejectedOpeningSingleLine","expectedClosingSingleLine","rejectedClosingSingleLine","rule","expectation","options","context","root","result","validOptions","actual","possible","walkDecls","decl","value","includes","hasFixed","declValue","get","parsedValue","walk","valueNode","type","nodes","length","functionString","stringify","isSingleLine","openingIndex","sourceIndex","before","fix","complain","closingIndex","after","raws","toString","raw","message","offset","node","index","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-parentheses-space-inside';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedOpening: 'Expected single space after \"(\"',\n\trejectedOpening: 'Unexpected whitespace after \"(\"',\n\texpectedClosing: 'Expected single space before \")\"',\n\trejectedClosing: 'Unexpected whitespace before \")\"',\n\texpectedOpeningSingleLine: 'Expected single space after \"(\" in a single-line function',\n\trejectedOpeningSingleLine: 'Unexpected whitespace after \"(\" in a single-line function',\n\texpectedClosingSingleLine: 'Expected single space before \")\" in a single-line function',\n\trejectedClosingSingleLine: 'Unexpected whitespace before \")\" in a single-line function',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'never', 'always-single-line', 'never-single-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tif (!decl.value.includes('(')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet hasFixed = false;\n\t\t\tconst declValue = _.get(decl, 'raws.value.raw', decl.value);\n\t\t\tconst parsedValue = valueParser(declValue);\n\n\t\t\tparsedValue.walk((valueNode) => {\n\t\t\t\tif (valueNode.type !== 'function') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!isStandardSyntaxFunction(valueNode)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Ignore function without parameters\n\t\t\t\tif (!valueNode.nodes.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst functionString = valueParser.stringify(valueNode);\n\t\t\t\tconst isSingleLine = isSingleLineString(functionString);\n\n\t\t\t\t// Check opening ...\n\n\t\t\t\tconst openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;\n\n\t\t\t\tif (expectation === 'always' && valueNode.before !== ' ') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.before = ' ';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedOpening, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (expectation === 'never' && valueNode.before !== '') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.before = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.rejectedOpening, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isSingleLine && expectation === 'always-single-line' && valueNode.before !== ' ') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.before = ' ';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedOpeningSingleLine, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isSingleLine && expectation === 'never-single-line' && valueNode.before !== '') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.before = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.rejectedOpeningSingleLine, openingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check closing ...\n\n\t\t\t\tconst closingIndex = valueNode.sourceIndex + functionString.length - 2;\n\n\t\t\t\tif (expectation === 'always' && valueNode.after !== ' ') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.after = ' ';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedClosing, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (expectation === 'never' && valueNode.after !== '') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.after = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.rejectedClosing, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isSingleLine && expectation === 'always-single-line' && valueNode.after !== ' ') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.after = ' ';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.expectedClosingSingleLine, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isSingleLine && expectation === 'never-single-line' && valueNode.after !== '') {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\thasFixed = true;\n\t\t\t\t\t\tvalueNode.after = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplain(messages.rejectedClosingSingleLine, closingIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (hasFixed) {\n\t\t\t\tif (!decl.raws.value) {\n\t\t\t\t\tdecl.value = parsedValue.toString();\n\t\t\t\t} else {\n\t\t\t\t\tdecl.raws.value.raw = parsedValue.toString();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction complain(message, offset) {\n\t\t\t\treport({\n\t\t\t\t\truleName,\n\t\t\t\t\tresult,\n\t\t\t\t\tmessage,\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + offset,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}