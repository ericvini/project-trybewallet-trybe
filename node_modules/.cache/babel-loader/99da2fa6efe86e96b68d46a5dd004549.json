{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'value-list-comma-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \",\"',\n  expectedAfterMultiLine: () => 'Expected newline after \",\" in a multi-line list',\n  rejectedAfterMultiLine: () => 'Unexpected whitespace after \",\" in a multi-line list'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    let fixData;\n    valueListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.afterOneOnly,\n      checkedRuleName: ruleName,\n      fix: context.fix ? (declNode, index) => {\n        const valueIndex = declarationValueIndex(declNode);\n\n        if (index <= valueIndex) {\n          return false;\n        }\n\n        fixData = fixData || new Map();\n        const commaIndices = fixData.get(declNode) || [];\n        commaIndices.push(index);\n        fixData.set(declNode, commaIndices);\n        return true;\n      } : null,\n      determineIndex: (declString, match) => {\n        const nextChars = declString.substr(match.endIndex, declString.length - match.endIndex); // If there's a // comment, that means there has to be a newline\n        // ending the comment so we're fine\n\n        if (/^[ \\t]*\\/\\//.test(nextChars)) {\n          return false;\n        } // If there are spaces and then a comment begins, look for the newline\n\n\n        return /^[ \\t]*\\/\\*/.test(nextChars) ? declString.indexOf('*/', match.endIndex) + 1 : match.startIndex;\n      }\n    });\n\n    if (fixData) {\n      fixData.forEach((commaIndices, decl) => {\n        commaIndices.sort((a, b) => a - b).reverse().forEach(index => {\n          const value = decl.raws.value ? decl.raws.value.raw : decl.value;\n          const valueIndex = index - declarationValueIndex(decl);\n          const beforeValue = value.slice(0, valueIndex + 1);\n          let afterValue = value.slice(valueIndex + 1);\n\n          if (expectation.startsWith('always')) {\n            afterValue = context.newline + afterValue;\n          } else if (expectation.startsWith('never-multi-line')) {\n            afterValue = afterValue.replace(/^\\s*/, '');\n          }\n\n          if (decl.raws.value) {\n            decl.raws.value.raw = beforeValue + afterValue;\n          } else {\n            decl.value = beforeValue + afterValue;\n          }\n        });\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/value-list-comma-newline-after/index.js"],"names":["declarationValueIndex","require","ruleMessages","validateOptions","valueListCommaWhitespaceChecker","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","fixData","locationChecker","afterOneOnly","checkedRuleName","fix","declNode","index","valueIndex","Map","commaIndices","get","push","set","determineIndex","declString","match","nextChars","substr","endIndex","length","test","indexOf","startIndex","forEach","decl","sort","a","b","reverse","value","raws","raw","beforeValue","slice","afterValue","startsWith","newline","replace","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'value-list-comma-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \",\"',\n\texpectedAfterMultiLine: () => 'Expected newline after \",\" in a multi-line list',\n\trejectedAfterMultiLine: () => 'Unexpected whitespace after \",\" in a multi-line list',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['always', 'always-multi-line', 'never-multi-line'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet fixData;\n\n\t\tvalueListCommaWhitespaceChecker({\n\t\t\troot,\n\t\t\tresult,\n\t\t\tlocationChecker: checker.afterOneOnly,\n\t\t\tcheckedRuleName: ruleName,\n\t\t\tfix: context.fix\n\t\t\t\t? (declNode, index) => {\n\t\t\t\t\t\tconst valueIndex = declarationValueIndex(declNode);\n\n\t\t\t\t\t\tif (index <= valueIndex) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfixData = fixData || new Map();\n\t\t\t\t\t\tconst commaIndices = fixData.get(declNode) || [];\n\n\t\t\t\t\t\tcommaIndices.push(index);\n\t\t\t\t\t\tfixData.set(declNode, commaIndices);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t  }\n\t\t\t\t: null,\n\t\t\tdetermineIndex: (declString, match) => {\n\t\t\t\tconst nextChars = declString.substr(match.endIndex, declString.length - match.endIndex);\n\n\t\t\t\t// If there's a // comment, that means there has to be a newline\n\t\t\t\t// ending the comment so we're fine\n\t\t\t\tif (/^[ \\t]*\\/\\//.test(nextChars)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// If there are spaces and then a comment begins, look for the newline\n\t\t\t\treturn /^[ \\t]*\\/\\*/.test(nextChars)\n\t\t\t\t\t? declString.indexOf('*/', match.endIndex) + 1\n\t\t\t\t\t: match.startIndex;\n\t\t\t},\n\t\t});\n\n\t\tif (fixData) {\n\t\t\tfixData.forEach((commaIndices, decl) => {\n\t\t\t\tcommaIndices\n\t\t\t\t\t.sort((a, b) => a - b)\n\t\t\t\t\t.reverse()\n\t\t\t\t\t.forEach((index) => {\n\t\t\t\t\t\tconst value = decl.raws.value ? decl.raws.value.raw : decl.value;\n\t\t\t\t\t\tconst valueIndex = index - declarationValueIndex(decl);\n\t\t\t\t\t\tconst beforeValue = value.slice(0, valueIndex + 1);\n\t\t\t\t\t\tlet afterValue = value.slice(valueIndex + 1);\n\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tafterValue = context.newline + afterValue;\n\t\t\t\t\t\t} else if (expectation.startsWith('never-multi-line')) {\n\t\t\t\t\t\t\tafterValue = afterValue.replace(/^\\s*/, '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (decl.raws.value) {\n\t\t\t\t\t\t\tdecl.raws.value.raw = beforeValue + afterValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdecl.value = beforeValue + afterValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}