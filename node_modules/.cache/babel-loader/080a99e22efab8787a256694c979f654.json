{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isStandardSyntaxCombinator = require('../utils/isStandardSyntaxCombinator');\n\nconst isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');\n\nconst parseSelector = require('../utils/parseSelector');\n\nconst report = require('../utils/report');\n\nmodule.exports = function (opts) {\n  let hasFixed;\n  opts.root.walkRules(rule => {\n    if (!isStandardSyntaxRule(rule)) {\n      return;\n    }\n\n    hasFixed = false;\n    const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n    const fixedSelector = parseSelector(selector, opts.result, rule, selectorTree => {\n      selectorTree.walkCombinators(node => {\n        // Ignore non-standard combinators\n        if (!isStandardSyntaxCombinator(node)) {\n          return;\n        } // Ignore spaced descendant combinator\n\n\n        if (/\\s/.test(node.value)) {\n          return;\n        } // Check the exist of node in prev of the combinator.\n        // in case some that aren't the first begin with combinators (nesting syntax)\n\n\n        if (opts.locationType === 'before' && !node.prev()) {\n          return;\n        }\n\n        const parentParentNode = node.parent && node.parent.parent; // Ignore pseudo-classes selector like `.foo:nth-child(2n + 1) {}`\n\n        if (parentParentNode && parentParentNode.type === 'pseudo') {\n          return;\n        }\n\n        const sourceIndex = node.sourceIndex;\n        const index = node.value.length > 1 && opts.locationType === 'before' ? sourceIndex : sourceIndex + node.value.length - 1;\n        check(selector, node, index, rule, sourceIndex);\n      });\n    });\n\n    if (hasFixed) {\n      if (!rule.raws.selector) {\n        rule.selector = fixedSelector;\n      } else {\n        rule.raws.selector.raw = fixedSelector;\n      }\n    }\n  });\n\n  function check(source, combinator, index, node, sourceIndex) {\n    opts.locationChecker({\n      source,\n      index,\n      errTarget: combinator.value,\n      err: m => {\n        if (opts.fix && opts.fix(combinator)) {\n          hasFixed = true;\n          return;\n        }\n\n        report({\n          message: m,\n          node,\n          index: sourceIndex,\n          result: opts.result,\n          ruleName: opts.checkedRuleName\n        });\n      }\n    });\n  }\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selectorCombinatorSpaceChecker.js"],"names":["isStandardSyntaxCombinator","require","isStandardSyntaxRule","parseSelector","report","module","exports","opts","hasFixed","root","walkRules","rule","selector","raws","raw","fixedSelector","result","selectorTree","walkCombinators","node","test","value","locationType","prev","parentParentNode","parent","type","sourceIndex","index","length","check","source","combinator","locationChecker","errTarget","err","m","fix","message","ruleName","checkedRuleName"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isStandardSyntaxCombinator = require('../utils/isStandardSyntaxCombinator');\nconst isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');\nconst parseSelector = require('../utils/parseSelector');\nconst report = require('../utils/report');\n\nmodule.exports = function (opts) {\n\tlet hasFixed;\n\n\topts.root.walkRules((rule) => {\n\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\treturn;\n\t\t}\n\n\t\thasFixed = false;\n\t\tconst selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\n\t\tconst fixedSelector = parseSelector(selector, opts.result, rule, (selectorTree) => {\n\t\t\tselectorTree.walkCombinators((node) => {\n\t\t\t\t// Ignore non-standard combinators\n\t\t\t\tif (!isStandardSyntaxCombinator(node)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Ignore spaced descendant combinator\n\t\t\t\tif (/\\s/.test(node.value)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check the exist of node in prev of the combinator.\n\t\t\t\t// in case some that aren't the first begin with combinators (nesting syntax)\n\t\t\t\tif (opts.locationType === 'before' && !node.prev()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst parentParentNode = node.parent && node.parent.parent;\n\n\t\t\t\t// Ignore pseudo-classes selector like `.foo:nth-child(2n + 1) {}`\n\t\t\t\tif (parentParentNode && parentParentNode.type === 'pseudo') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceIndex = node.sourceIndex;\n\t\t\t\tconst index =\n\t\t\t\t\tnode.value.length > 1 && opts.locationType === 'before'\n\t\t\t\t\t\t? sourceIndex\n\t\t\t\t\t\t: sourceIndex + node.value.length - 1;\n\n\t\t\t\tcheck(selector, node, index, rule, sourceIndex);\n\t\t\t});\n\t\t});\n\n\t\tif (hasFixed) {\n\t\t\tif (!rule.raws.selector) {\n\t\t\t\trule.selector = fixedSelector;\n\t\t\t} else {\n\t\t\t\trule.raws.selector.raw = fixedSelector;\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction check(source, combinator, index, node, sourceIndex) {\n\t\topts.locationChecker({\n\t\t\tsource,\n\t\t\tindex,\n\t\t\terrTarget: combinator.value,\n\t\t\terr: (m) => {\n\t\t\t\tif (opts.fix && opts.fix(combinator)) {\n\t\t\t\t\thasFixed = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: m,\n\t\t\t\t\tnode,\n\t\t\t\t\tindex: sourceIndex,\n\t\t\t\t\tresult: opts.result,\n\t\t\t\t\truleName: opts.checkedRuleName,\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}