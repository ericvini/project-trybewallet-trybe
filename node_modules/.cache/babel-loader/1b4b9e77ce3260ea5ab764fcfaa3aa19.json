{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\n\nconst getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');\n\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\n\nconst isAfterSingleLineComment = require('../../utils/isAfterSingleLineComment');\n\nconst isFirstNested = require('../../utils/isFirstNested');\n\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'rule-empty-line-before';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected empty line before rule',\n  rejected: 'Unexpected empty line before rule'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never', 'always-multi-line', 'never-multi-line']\n    }, {\n      actual: options,\n      possible: {\n        ignore: ['after-comment', 'first-nested', 'inside-block'],\n        except: ['after-rule', 'after-single-line-comment', 'first-nested', 'inside-block-and-after-rule', 'inside-block']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      } // Ignore the first node\n\n\n      if (isFirstNodeOfRoot(rule)) {\n        return;\n      } // Optionally ignore the expectation if a comment precedes this node\n\n\n      if (optionsMatches(options, 'ignore', 'after-comment') && rule.prev() && rule.prev().type === 'comment') {\n        return;\n      } // Optionally ignore the node if it is the first nested\n\n\n      if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(rule)) {\n        return;\n      }\n\n      const isNested = rule.parent.type !== 'root'; // Optionally ignore the expectation if inside a block\n\n      if (optionsMatches(options, 'ignore', 'inside-block') && isNested) {\n        return;\n      } // Ignore if the expectation is for multiple and the rule is single-line\n\n\n      if (expectation.includes('multi-line') && isSingleLineString(rule.toString())) {\n        return;\n      }\n\n      let expectEmptyLineBefore = Boolean(expectation.includes('always')); // Optionally reverse the expectation if any exceptions apply\n\n      if (optionsMatches(options, 'except', 'first-nested') && isFirstNested(rule) || optionsMatches(options, 'except', 'after-rule') && isAfterRule(rule) || optionsMatches(options, 'except', 'inside-block-and-after-rule') && isNested && isAfterRule(rule) || optionsMatches(options, 'except', 'after-single-line-comment') && isAfterSingleLineComment(rule) || optionsMatches(options, 'except', 'inside-block') && isNested) {\n        expectEmptyLineBefore = !expectEmptyLineBefore;\n      }\n\n      const hasEmptyLineBefore = hasEmptyLine(rule.raws.before); // Return if the expectation is met\n\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      } // Fix\n\n\n      if (context.fix) {\n        if (expectEmptyLineBefore) {\n          addEmptyLineBefore(rule, context.newline);\n        } else {\n          removeEmptyLinesBefore(rule, context.newline);\n        }\n\n        return;\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n      report({\n        message,\n        node: rule,\n        result,\n        ruleName\n      });\n    });\n  };\n} // TODO: Issue #4985\n// eslint-disable-next-line no-shadow\n\n\nfunction isAfterRule(rule) {\n  const prevNode = getPreviousNonSharedLineCommentNode(rule);\n  return prevNode && prevNode.type === 'rule';\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/rule-empty-line-before/index.js"],"names":["addEmptyLineBefore","require","getPreviousNonSharedLineCommentNode","hasEmptyLine","isAfterSingleLineComment","isFirstNested","isFirstNodeOfRoot","isSingleLineString","isStandardSyntaxRule","optionsMatches","removeEmptyLinesBefore","report","ruleMessages","validateOptions","ruleName","messages","expected","rejected","rule","expectation","options","context","root","result","validOptions","actual","possible","ignore","except","optional","walkRules","prev","type","isNested","parent","includes","toString","expectEmptyLineBefore","Boolean","isAfterRule","hasEmptyLineBefore","raws","before","fix","newline","message","node","prevNode","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\nconst getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\nconst isAfterSingleLineComment = require('../../utils/isAfterSingleLineComment');\nconst isFirstNested = require('../../utils/isFirstNested');\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'rule-empty-line-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected empty line before rule',\n\trejected: 'Unexpected empty line before rule',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['always', 'never', 'always-multi-line', 'never-multi-line'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['after-comment', 'first-nested', 'inside-block'],\n\t\t\t\t\texcept: [\n\t\t\t\t\t\t'after-rule',\n\t\t\t\t\t\t'after-single-line-comment',\n\t\t\t\t\t\t'first-nested',\n\t\t\t\t\t\t'inside-block-and-after-rule',\n\t\t\t\t\t\t'inside-block',\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore the first node\n\t\t\tif (isFirstNodeOfRoot(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the expectation if a comment precedes this node\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'ignore', 'after-comment') &&\n\t\t\t\trule.prev() &&\n\t\t\t\trule.prev().type === 'comment'\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if it is the first nested\n\t\t\tif (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst isNested = rule.parent.type !== 'root';\n\n\t\t\t// Optionally ignore the expectation if inside a block\n\t\t\tif (optionsMatches(options, 'ignore', 'inside-block') && isNested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore if the expectation is for multiple and the rule is single-line\n\t\t\tif (expectation.includes('multi-line') && isSingleLineString(rule.toString())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet expectEmptyLineBefore = Boolean(expectation.includes('always'));\n\n\t\t\t// Optionally reverse the expectation if any exceptions apply\n\t\t\tif (\n\t\t\t\t(optionsMatches(options, 'except', 'first-nested') && isFirstNested(rule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'after-rule') && isAfterRule(rule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'inside-block-and-after-rule') &&\n\t\t\t\t\tisNested &&\n\t\t\t\t\tisAfterRule(rule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'after-single-line-comment') &&\n\t\t\t\t\tisAfterSingleLineComment(rule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'inside-block') && isNested)\n\t\t\t) {\n\t\t\t\texpectEmptyLineBefore = !expectEmptyLineBefore;\n\t\t\t}\n\n\t\t\tconst hasEmptyLineBefore = hasEmptyLine(rule.raws.before);\n\n\t\t\t// Return if the expectation is met\n\t\t\tif (expectEmptyLineBefore === hasEmptyLineBefore) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fix\n\t\t\tif (context.fix) {\n\t\t\t\tif (expectEmptyLineBefore) {\n\t\t\t\t\taddEmptyLineBefore(rule, context.newline);\n\t\t\t\t} else {\n\t\t\t\t\tremoveEmptyLinesBefore(rule, context.newline);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n\t\t\treport({\n\t\t\t\tmessage,\n\t\t\t\tnode: rule,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t});\n\t};\n}\n\n// TODO: Issue #4985\n// eslint-disable-next-line no-shadow\nfunction isAfterRule(rule) {\n\tconst prevNode = getPreviousNonSharedLineCommentNode(rule);\n\n\treturn prevNode && prevNode.type === 'rule';\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}