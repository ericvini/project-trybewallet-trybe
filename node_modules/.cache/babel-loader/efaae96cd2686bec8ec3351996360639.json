{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst parser = require('postcss-selector-parser');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'max-nesting-depth';\nconst messages = ruleMessages(ruleName, {\n  expected: depth => `Expected nesting depth to be no more than ${depth}`\n});\n\nfunction rule(max, options) {\n  const isIgnoreAtRule = node => node.type === 'atrule' && optionsMatches(options, 'ignoreAtRules', node.name);\n\n  return (root, result) => {\n    validateOptions(result, ruleName, {\n      actual: max,\n      possible: [_.isNumber]\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignore: ['blockless-at-rules', 'pseudo-classes'],\n        ignoreAtRules: [_.isString, _.isRegExp]\n      }\n    });\n    root.walkRules(checkStatement);\n    root.walkAtRules(checkStatement);\n\n    function checkStatement(statement) {\n      if (isIgnoreAtRule(statement)) {\n        return;\n      }\n\n      if (!hasBlock(statement)) {\n        return;\n      }\n\n      if (statement.selector && !isStandardSyntaxRule(statement)) {\n        return;\n      }\n\n      const depth = nestingDepth(statement);\n\n      if (depth > max) {\n        report({\n          ruleName,\n          result,\n          node: statement,\n          message: messages.expected(max)\n        });\n      }\n    }\n  };\n\n  function nestingDepth(node, level = 0) {\n    const parent = node.parent;\n\n    if (isIgnoreAtRule(parent)) {\n      return 0;\n    } // The nesting depth level's computation has finished\n    // when this function, recursively called, receives\n    // a node that is not nested -- a direct child of the\n    // root node\n\n\n    if (parent.type === 'root' || parent.type === 'atrule' && parent.parent.type === 'root') {\n      return level;\n    }\n\n    function containsPseudoClassesOnly(selector) {\n      const normalized = parser().processSync(selector, {\n        lossless: false\n      });\n      const selectors = normalized.split(','); // TODO: Issue #4985\n      // eslint-disable-next-line no-shadow\n\n      return selectors.every(selector => selector.startsWith('&:') && selector[2] !== ':');\n    }\n\n    if (optionsMatches(options, 'ignore', 'blockless-at-rules') && node.type === 'atrule' && node.every(child => child.type !== 'decl') || optionsMatches(options, 'ignore', 'pseudo-classes') && node.type === 'rule' && containsPseudoClassesOnly(node.selector)) {\n      return nestingDepth(parent, level);\n    } // Unless any of the conditions above apply, we want to\n    // add 1 to the nesting depth level and then check the parent,\n    // continuing to add and move up the hierarchy\n    // until we hit the root node\n\n\n    return nestingDepth(parent, level + 1);\n  }\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/max-nesting-depth/index.js"],"names":["_","require","hasBlock","isStandardSyntaxRule","optionsMatches","parser","report","ruleMessages","validateOptions","ruleName","messages","expected","depth","rule","max","options","isIgnoreAtRule","node","type","name","root","result","actual","possible","isNumber","optional","ignore","ignoreAtRules","isString","isRegExp","walkRules","checkStatement","walkAtRules","statement","selector","nestingDepth","message","level","parent","containsPseudoClassesOnly","normalized","processSync","lossless","selectors","split","every","startsWith","child","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAME,oBAAoB,GAAGF,OAAO,CAAC,kCAAD,CAApC;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,4BAAD,CAA9B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,yBAAD,CAAtB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMO,eAAe,GAAGP,OAAO,CAAC,6BAAD,CAA/B;;AAEA,MAAMQ,QAAQ,GAAG,mBAAjB;AAEA,MAAMC,QAAQ,GAAGH,YAAY,CAACE,QAAD,EAAW;AACvCE,EAAAA,QAAQ,EAAGC,KAAD,IAAY,6CAA4CA,KAAM;AADjC,CAAX,CAA7B;;AAIA,SAASC,IAAT,CAAcC,GAAd,EAAmBC,OAAnB,EAA4B;AAC3B,QAAMC,cAAc,GAAIC,IAAD,IACtBA,IAAI,CAACC,IAAL,KAAc,QAAd,IAA0Bd,cAAc,CAACW,OAAD,EAAU,eAAV,EAA2BE,IAAI,CAACE,IAAhC,CADzC;;AAGA,SAAO,CAACC,IAAD,EAAOC,MAAP,KAAkB;AACxBb,IAAAA,eAAe,CACda,MADc,EAEdZ,QAFc,EAGd;AACCa,MAAAA,MAAM,EAAER,GADT;AAECS,MAAAA,QAAQ,EAAE,CAACvB,CAAC,CAACwB,QAAH;AAFX,KAHc,EAOd;AACCC,MAAAA,QAAQ,EAAE,IADX;AAECH,MAAAA,MAAM,EAAEP,OAFT;AAGCQ,MAAAA,QAAQ,EAAE;AACTG,QAAAA,MAAM,EAAE,CAAC,oBAAD,EAAuB,gBAAvB,CADC;AAETC,QAAAA,aAAa,EAAE,CAAC3B,CAAC,CAAC4B,QAAH,EAAa5B,CAAC,CAAC6B,QAAf;AAFN;AAHX,KAPc,CAAf;AAiBAT,IAAAA,IAAI,CAACU,SAAL,CAAeC,cAAf;AACAX,IAAAA,IAAI,CAACY,WAAL,CAAiBD,cAAjB;;AAEA,aAASA,cAAT,CAAwBE,SAAxB,EAAmC;AAClC,UAAIjB,cAAc,CAACiB,SAAD,CAAlB,EAA+B;AAC9B;AACA;;AAED,UAAI,CAAC/B,QAAQ,CAAC+B,SAAD,CAAb,EAA0B;AACzB;AACA;;AAED,UAAIA,SAAS,CAACC,QAAV,IAAsB,CAAC/B,oBAAoB,CAAC8B,SAAD,CAA/C,EAA4D;AAC3D;AACA;;AAED,YAAMrB,KAAK,GAAGuB,YAAY,CAACF,SAAD,CAA1B;;AAEA,UAAIrB,KAAK,GAAGE,GAAZ,EAAiB;AAChBR,QAAAA,MAAM,CAAC;AACNG,UAAAA,QADM;AAENY,UAAAA,MAFM;AAGNJ,UAAAA,IAAI,EAAEgB,SAHA;AAING,UAAAA,OAAO,EAAE1B,QAAQ,CAACC,QAAT,CAAkBG,GAAlB;AAJH,SAAD,CAAN;AAMA;AACD;AACD,GA7CD;;AA+CA,WAASqB,YAAT,CAAsBlB,IAAtB,EAA4BoB,KAAK,GAAG,CAApC,EAAuC;AACtC,UAAMC,MAAM,GAAGrB,IAAI,CAACqB,MAApB;;AAEA,QAAItB,cAAc,CAACsB,MAAD,CAAlB,EAA4B;AAC3B,aAAO,CAAP;AACA,KALqC,CAOtC;AACA;AACA;AACA;;;AACA,QAAIA,MAAM,CAACpB,IAAP,KAAgB,MAAhB,IAA2BoB,MAAM,CAACpB,IAAP,KAAgB,QAAhB,IAA4BoB,MAAM,CAACA,MAAP,CAAcpB,IAAd,KAAuB,MAAlF,EAA2F;AAC1F,aAAOmB,KAAP;AACA;;AAED,aAASE,yBAAT,CAAmCL,QAAnC,EAA6C;AAC5C,YAAMM,UAAU,GAAGnC,MAAM,GAAGoC,WAAT,CAAqBP,QAArB,EAA+B;AAAEQ,QAAAA,QAAQ,EAAE;AAAZ,OAA/B,CAAnB;AACA,YAAMC,SAAS,GAAGH,UAAU,CAACI,KAAX,CAAiB,GAAjB,CAAlB,CAF4C,CAI5C;AACA;;AACA,aAAOD,SAAS,CAACE,KAAV,CAAiBX,QAAD,IAAcA,QAAQ,CAACY,UAAT,CAAoB,IAApB,KAA6BZ,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAA3E,CAAP;AACA;;AAED,QACE9B,cAAc,CAACW,OAAD,EAAU,QAAV,EAAoB,oBAApB,CAAd,IACAE,IAAI,CAACC,IAAL,KAAc,QADd,IAEAD,IAAI,CAAC4B,KAAL,CAAYE,KAAD,IAAWA,KAAK,CAAC7B,IAAN,KAAe,MAArC,CAFD,IAGCd,cAAc,CAACW,OAAD,EAAU,QAAV,EAAoB,gBAApB,CAAd,IACAE,IAAI,CAACC,IAAL,KAAc,MADd,IAEAqB,yBAAyB,CAACtB,IAAI,CAACiB,QAAN,CAN3B,EAOE;AACD,aAAOC,YAAY,CAACG,MAAD,EAASD,KAAT,CAAnB;AACA,KAjCqC,CAmCtC;AACA;AACA;AACA;;;AACA,WAAOF,YAAY,CAACG,MAAD,EAASD,KAAK,GAAG,CAAjB,CAAnB;AACA;AACD;;AAEDxB,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAI,IAAI,CAACH,QAAL,GAAgBA,QAAhB;AACAsC,MAAM,CAACC,OAAP,GAAiBpC,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst hasBlock = require('../../utils/hasBlock');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst parser = require('postcss-selector-parser');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'max-nesting-depth';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (depth) => `Expected nesting depth to be no more than ${depth}`,\n});\n\nfunction rule(max, options) {\n\tconst isIgnoreAtRule = (node) =>\n\t\tnode.type === 'atrule' && optionsMatches(options, 'ignoreAtRules', node.name);\n\n\treturn (root, result) => {\n\t\tvalidateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: max,\n\t\t\t\tpossible: [_.isNumber],\n\t\t\t},\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['blockless-at-rules', 'pseudo-classes'],\n\t\t\t\t\tignoreAtRules: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\troot.walkRules(checkStatement);\n\t\troot.walkAtRules(checkStatement);\n\n\t\tfunction checkStatement(statement) {\n\t\t\tif (isIgnoreAtRule(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!hasBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (statement.selector && !isStandardSyntaxRule(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst depth = nestingDepth(statement);\n\n\t\t\tif (depth > max) {\n\t\t\t\treport({\n\t\t\t\t\truleName,\n\t\t\t\t\tresult,\n\t\t\t\t\tnode: statement,\n\t\t\t\t\tmessage: messages.expected(max),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction nestingDepth(node, level = 0) {\n\t\tconst parent = node.parent;\n\n\t\tif (isIgnoreAtRule(parent)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// The nesting depth level's computation has finished\n\t\t// when this function, recursively called, receives\n\t\t// a node that is not nested -- a direct child of the\n\t\t// root node\n\t\tif (parent.type === 'root' || (parent.type === 'atrule' && parent.parent.type === 'root')) {\n\t\t\treturn level;\n\t\t}\n\n\t\tfunction containsPseudoClassesOnly(selector) {\n\t\t\tconst normalized = parser().processSync(selector, { lossless: false });\n\t\t\tconst selectors = normalized.split(',');\n\n\t\t\t// TODO: Issue #4985\n\t\t\t// eslint-disable-next-line no-shadow\n\t\t\treturn selectors.every((selector) => selector.startsWith('&:') && selector[2] !== ':');\n\t\t}\n\n\t\tif (\n\t\t\t(optionsMatches(options, 'ignore', 'blockless-at-rules') &&\n\t\t\t\tnode.type === 'atrule' &&\n\t\t\t\tnode.every((child) => child.type !== 'decl')) ||\n\t\t\t(optionsMatches(options, 'ignore', 'pseudo-classes') &&\n\t\t\t\tnode.type === 'rule' &&\n\t\t\t\tcontainsPseudoClassesOnly(node.selector))\n\t\t) {\n\t\t\treturn nestingDepth(parent, level);\n\t\t}\n\n\t\t// Unless any of the conditions above apply, we want to\n\t\t// add 1 to the nesting depth level and then check the parent,\n\t\t// continuing to add and move up the hierarchy\n\t\t// until we hit the root node\n\t\treturn nestingDepth(parent, level + 1);\n\t}\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}