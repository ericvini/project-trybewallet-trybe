{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst LazyResult = require('postcss/lib/lazy-result');\n\nconst postcss = require('postcss');\n\nconst syntaxes = require('./syntaxes');\n/** @typedef {import('postcss').Result} Result */\n\n/** @typedef {import('postcss').Syntax} Syntax */\n\n/** @typedef {import('stylelint').CustomSyntax} CustomSyntax */\n\n/** @typedef {import('stylelint').GetPostcssOptions} GetPostcssOptions */\n\n/** @typedef {import('stylelint').StylelintInternalApi} StylelintInternalApi */\n\n\nconst postcssProcessor = postcss();\n/**\n * @param {StylelintInternalApi} stylelint\n * @param {GetPostcssOptions} options\n *\n * @returns {Promise<Result>}\n */\n\nmodule.exports = function (stylelint, options = {}) {\n  const cached = options.filePath ? stylelint._postcssResultCache.get(options.filePath) : undefined;\n  if (cached) return Promise.resolve(cached);\n  /** @type {Promise<string> | undefined} */\n\n  let getCode;\n\n  if (options.code !== undefined) {\n    getCode = Promise.resolve(options.code);\n  } else if (options.filePath) {\n    getCode = readFile(options.filePath);\n  }\n\n  if (!getCode) {\n    throw new Error('code or filePath required');\n  }\n\n  return getCode.then(code => {\n    /** @type {Syntax | null} */\n    let syntax = null;\n\n    if (stylelint._options.customSyntax) {\n      syntax = getCustomSyntax(stylelint._options.customSyntax);\n    } else if (stylelint._options.syntax) {\n      if (stylelint._options.syntax === 'css') {\n        syntax = cssSyntax(stylelint);\n      } else {\n        const keys = Object.keys(syntaxes);\n\n        if (!keys.includes(stylelint._options.syntax)) {\n          throw new Error(`You must use a valid syntax option, either: css, ${keys.slice(0, -1).join(', ')} or ${keys.slice(-1)}`);\n        }\n\n        syntax = syntaxes[stylelint._options.syntax];\n      }\n    } else if (!(options.codeProcessors && options.codeProcessors.length)) {\n      const autoSyntax = require('postcss-syntax'); // TODO: investigate why lazy import HTML syntax causes\n      // JS files with the word \"html\" to throw TypeError\n      // https://github.com/stylelint/stylelint/issues/4793\n\n\n      const {\n        html,\n        ...rest\n      } = syntaxes;\n      syntax = autoSyntax({\n        css: cssSyntax(stylelint),\n        jsx: syntaxes['css-in-js'],\n        ...rest\n      });\n    }\n\n    const postcssOptions = {\n      from: options.filePath,\n      syntax\n    };\n    const source = options.code ? options.codeFilename : options.filePath;\n    let preProcessedCode = code;\n\n    if (options.codeProcessors && options.codeProcessors.length) {\n      if (stylelint._options.fix) {\n        // eslint-disable-next-line no-console\n        console.warn('Autofix is incompatible with processors and will be disabled. Are you sure you need a processor?');\n        stylelint._options.fix = false;\n      }\n\n      options.codeProcessors.forEach(codeProcessor => {\n        preProcessedCode = codeProcessor(preProcessedCode, source);\n      });\n    }\n\n    const result = new LazyResult(postcssProcessor, preProcessedCode, postcssOptions);\n    return result;\n  }).then(postcssResult => {\n    if (options.filePath) {\n      stylelint._postcssResultCache.set(options.filePath, postcssResult);\n    }\n\n    return postcssResult;\n  });\n};\n/**\n * @param {CustomSyntax} customSyntax\n * @returns {Syntax}\n */\n\n\nfunction getCustomSyntax(customSyntax) {\n  let resolved;\n\n  if (typeof customSyntax === 'string') {\n    try {\n      resolved = require(customSyntax);\n    } catch (error) {\n      throw new Error(`Cannot resolve custom syntax module ${customSyntax}. Check that module ${customSyntax} is available and spelled correctly.`);\n    }\n    /*\n     * PostCSS allows for syntaxes that only contain a parser, however,\n     * it then expects the syntax to be set as the `parse` option.\n     */\n\n\n    if (!resolved.parse) {\n      resolved = {\n        parse: resolved,\n        stringify: postcss.stringify\n      };\n    }\n\n    return resolved;\n  }\n\n  if (typeof customSyntax === 'object') {\n    if (typeof customSyntax.parse === 'function') {\n      resolved = { ...customSyntax\n      };\n    } else {\n      throw new Error(`An object provided to the \"customSyntax\" option must have a \"parse\" property. Ensure the \"parse\" property exists and its value is a function.`);\n    }\n\n    return resolved;\n  }\n\n  throw new Error(`Custom syntax must be a string or a Syntax object`);\n}\n/**\n * @param {string} filePath\n * @returns {Promise<string>}\n */\n\n\nfunction readFile(filePath) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (err, content) => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve(content);\n    });\n  });\n}\n/**\n * @param {StylelintInternalApi} stylelint\n * @returns {Syntax}\n */\n\n\nfunction cssSyntax(stylelint) {\n  return {\n    parse: stylelint._options.fix ? require('postcss-safe-parser') : postcss.parse,\n    stringify: postcss.stringify\n  };\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/getPostcssResult.js"],"names":["fs","require","LazyResult","postcss","syntaxes","postcssProcessor","module","exports","stylelint","options","cached","filePath","_postcssResultCache","get","undefined","Promise","resolve","getCode","code","readFile","Error","then","syntax","_options","customSyntax","getCustomSyntax","cssSyntax","keys","Object","includes","slice","join","codeProcessors","length","autoSyntax","html","rest","css","jsx","postcssOptions","from","source","codeFilename","preProcessedCode","fix","console","warn","forEach","codeProcessor","result","postcssResult","set","resolved","error","parse","stringify","reject","err","content"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst LazyResult = require('postcss/lib/lazy-result');\nconst postcss = require('postcss');\nconst syntaxes = require('./syntaxes');\n\n/** @typedef {import('postcss').Result} Result */\n/** @typedef {import('postcss').Syntax} Syntax */\n/** @typedef {import('stylelint').CustomSyntax} CustomSyntax */\n/** @typedef {import('stylelint').GetPostcssOptions} GetPostcssOptions */\n/** @typedef {import('stylelint').StylelintInternalApi} StylelintInternalApi */\n\nconst postcssProcessor = postcss();\n\n/**\n * @param {StylelintInternalApi} stylelint\n * @param {GetPostcssOptions} options\n *\n * @returns {Promise<Result>}\n */\nmodule.exports = function (stylelint, options = {}) {\n\tconst cached = options.filePath ? stylelint._postcssResultCache.get(options.filePath) : undefined;\n\n\tif (cached) return Promise.resolve(cached);\n\n\t/** @type {Promise<string> | undefined} */\n\tlet getCode;\n\n\tif (options.code !== undefined) {\n\t\tgetCode = Promise.resolve(options.code);\n\t} else if (options.filePath) {\n\t\tgetCode = readFile(options.filePath);\n\t}\n\n\tif (!getCode) {\n\t\tthrow new Error('code or filePath required');\n\t}\n\n\treturn getCode\n\t\t.then((code) => {\n\t\t\t/** @type {Syntax | null} */\n\t\t\tlet syntax = null;\n\n\t\t\tif (stylelint._options.customSyntax) {\n\t\t\t\tsyntax = getCustomSyntax(stylelint._options.customSyntax);\n\t\t\t} else if (stylelint._options.syntax) {\n\t\t\t\tif (stylelint._options.syntax === 'css') {\n\t\t\t\t\tsyntax = cssSyntax(stylelint);\n\t\t\t\t} else {\n\t\t\t\t\tconst keys = Object.keys(syntaxes);\n\n\t\t\t\t\tif (!keys.includes(stylelint._options.syntax)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`You must use a valid syntax option, either: css, ${keys\n\t\t\t\t\t\t\t\t.slice(0, -1)\n\t\t\t\t\t\t\t\t.join(', ')} or ${keys.slice(-1)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tsyntax = syntaxes[stylelint._options.syntax];\n\t\t\t\t}\n\t\t\t} else if (!(options.codeProcessors && options.codeProcessors.length)) {\n\t\t\t\tconst autoSyntax = require('postcss-syntax');\n\n\t\t\t\t// TODO: investigate why lazy import HTML syntax causes\n\t\t\t\t// JS files with the word \"html\" to throw TypeError\n\t\t\t\t// https://github.com/stylelint/stylelint/issues/4793\n\t\t\t\tconst { html, ...rest } = syntaxes;\n\n\t\t\t\tsyntax = autoSyntax({\n\t\t\t\t\tcss: cssSyntax(stylelint),\n\t\t\t\t\tjsx: syntaxes['css-in-js'],\n\t\t\t\t\t...rest,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst postcssOptions = {\n\t\t\t\tfrom: options.filePath,\n\t\t\t\tsyntax,\n\t\t\t};\n\n\t\t\tconst source = options.code ? options.codeFilename : options.filePath;\n\t\t\tlet preProcessedCode = code;\n\n\t\t\tif (options.codeProcessors && options.codeProcessors.length) {\n\t\t\t\tif (stylelint._options.fix) {\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'Autofix is incompatible with processors and will be disabled. Are you sure you need a processor?',\n\t\t\t\t\t);\n\t\t\t\t\tstylelint._options.fix = false;\n\t\t\t\t}\n\n\t\t\t\toptions.codeProcessors.forEach((codeProcessor) => {\n\t\t\t\t\tpreProcessedCode = codeProcessor(preProcessedCode, source);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst result = new LazyResult(postcssProcessor, preProcessedCode, postcssOptions);\n\n\t\t\treturn result;\n\t\t})\n\t\t.then((postcssResult) => {\n\t\t\tif (options.filePath) {\n\t\t\t\tstylelint._postcssResultCache.set(options.filePath, postcssResult);\n\t\t\t}\n\n\t\t\treturn postcssResult;\n\t\t});\n};\n\n/**\n * @param {CustomSyntax} customSyntax\n * @returns {Syntax}\n */\nfunction getCustomSyntax(customSyntax) {\n\tlet resolved;\n\n\tif (typeof customSyntax === 'string') {\n\t\ttry {\n\t\t\tresolved = require(customSyntax);\n\t\t} catch (error) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot resolve custom syntax module ${customSyntax}. Check that module ${customSyntax} is available and spelled correctly.`,\n\t\t\t);\n\t\t}\n\n\t\t/*\n\t\t * PostCSS allows for syntaxes that only contain a parser, however,\n\t\t * it then expects the syntax to be set as the `parse` option.\n\t\t */\n\t\tif (!resolved.parse) {\n\t\t\tresolved = {\n\t\t\t\tparse: resolved,\n\t\t\t\tstringify: postcss.stringify,\n\t\t\t};\n\t\t}\n\n\t\treturn resolved;\n\t}\n\n\tif (typeof customSyntax === 'object') {\n\t\tif (typeof customSyntax.parse === 'function') {\n\t\t\tresolved = { ...customSyntax };\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`An object provided to the \"customSyntax\" option must have a \"parse\" property. Ensure the \"parse\" property exists and its value is a function.`,\n\t\t\t);\n\t\t}\n\n\t\treturn resolved;\n\t}\n\n\tthrow new Error(`Custom syntax must be a string or a Syntax object`);\n}\n\n/**\n * @param {string} filePath\n * @returns {Promise<string>}\n */\nfunction readFile(filePath) {\n\treturn new Promise((resolve, reject) => {\n\t\tfs.readFile(filePath, 'utf8', (err, content) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tresolve(content);\n\t\t});\n\t});\n}\n\n/**\n * @param {StylelintInternalApi} stylelint\n * @returns {Syntax}\n */\nfunction cssSyntax(stylelint) {\n\treturn {\n\t\tparse: stylelint._options.fix ? require('postcss-safe-parser') : postcss.parse,\n\t\tstringify: postcss.stringify,\n\t};\n}\n"]},"metadata":{},"sourceType":"script"}