{"ast":null,"code":"'use strict';\n\nconst {\n  isComment,\n  hasSource\n} = require('./typeGuards');\n/**\n * @param {import('postcss').Node} statement\n * @returns {boolean}\n */\n\n\nmodule.exports = function (statement) {\n  const parentNode = statement.parent;\n\n  if (parentNode === undefined || parentNode.type === 'root') {\n    return false;\n  }\n\n  if (statement === parentNode.first) {\n    return true;\n  }\n  /*\n   * Search for the statement in the parent's nodes, ignoring comment\n   * nodes on the same line as the parent's opening brace.\n   */\n\n\n  const parentNodes = parentNode.nodes;\n\n  if (!parentNodes) {\n    return false;\n  }\n\n  const firstNode = parentNodes[0];\n\n  if (!isComment(firstNode) || typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\\n')) {\n    return false;\n  }\n\n  if (!hasSource(firstNode) || !firstNode.source.start) {\n    return false;\n  }\n\n  const openingBraceLine = firstNode.source.start.line;\n\n  if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {\n    return false;\n  }\n\n  for (let i = 1; i < parentNodes.length; i++) {\n    const node = parentNodes[i];\n\n    if (node === statement) {\n      return true;\n    }\n\n    if (!isComment(node) || hasSource(node) && node.source.end && node.source.end.line !== openingBraceLine) {\n      return false;\n    }\n  }\n  /* istanbul ignore next: Should always return in the loop */\n\n\n  return false;\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/isFirstNested.js"],"names":["isComment","hasSource","require","module","exports","statement","parentNode","parent","undefined","type","first","parentNodes","nodes","firstNode","raws","before","includes","source","start","openingBraceLine","line","end","i","length","node"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA,SAAF;AAAaC,EAAAA;AAAb,IAA2BC,OAAO,CAAC,cAAD,CAAxC;AAEA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,SAAV,EAAqB;AACrC,QAAMC,UAAU,GAAGD,SAAS,CAACE,MAA7B;;AAEA,MAAID,UAAU,KAAKE,SAAf,IAA4BF,UAAU,CAACG,IAAX,KAAoB,MAApD,EAA4D;AAC3D,WAAO,KAAP;AACA;;AAED,MAAIJ,SAAS,KAAKC,UAAU,CAACI,KAA7B,EAAoC;AACnC,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;;;AAEC,QAAMC,WAAW,GAAGL,UAAU,CAACM,KAA/B;;AAEA,MAAI,CAACD,WAAL,EAAkB;AACjB,WAAO,KAAP;AACA;;AAED,QAAME,SAAS,GAAGF,WAAW,CAAC,CAAD,CAA7B;;AAEA,MACC,CAACX,SAAS,CAACa,SAAD,CAAV,IACC,OAAOA,SAAS,CAACC,IAAV,CAAeC,MAAtB,KAAiC,QAAjC,IAA6CF,SAAS,CAACC,IAAV,CAAeC,MAAf,CAAsBC,QAAtB,CAA+B,IAA/B,CAF/C,EAGE;AACD,WAAO,KAAP;AACA;;AAED,MAAI,CAACf,SAAS,CAACY,SAAD,CAAV,IAAyB,CAACA,SAAS,CAACI,MAAV,CAAiBC,KAA/C,EAAsD;AACrD,WAAO,KAAP;AACA;;AAED,QAAMC,gBAAgB,GAAGN,SAAS,CAACI,MAAV,CAAiBC,KAAjB,CAAuBE,IAAhD;;AAEA,MAAI,CAACP,SAAS,CAACI,MAAV,CAAiBI,GAAlB,IAAyBF,gBAAgB,KAAKN,SAAS,CAACI,MAAV,CAAiBI,GAAjB,CAAqBD,IAAvE,EAA6E;AAC5E,WAAO,KAAP;AACA;;AAED,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,WAAW,CAACY,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC5C,UAAME,IAAI,GAAGb,WAAW,CAACW,CAAD,CAAxB;;AAEA,QAAIE,IAAI,KAAKnB,SAAb,EAAwB;AACvB,aAAO,IAAP;AACA;;AAED,QACC,CAACL,SAAS,CAACwB,IAAD,CAAV,IACCvB,SAAS,CAACuB,IAAD,CAAT,IAAmBA,IAAI,CAACP,MAAL,CAAYI,GAA/B,IAAsCG,IAAI,CAACP,MAAL,CAAYI,GAAZ,CAAgBD,IAAhB,KAAyBD,gBAFjE,EAGE;AACD,aAAO,KAAP;AACA;AACD;AAED;;;AACA,SAAO,KAAP;AACA,CA1DD","sourcesContent":["'use strict';\n\nconst { isComment, hasSource } = require('./typeGuards');\n\n/**\n * @param {import('postcss').Node} statement\n * @returns {boolean}\n */\nmodule.exports = function (statement) {\n\tconst parentNode = statement.parent;\n\n\tif (parentNode === undefined || parentNode.type === 'root') {\n\t\treturn false;\n\t}\n\n\tif (statement === parentNode.first) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Search for the statement in the parent's nodes, ignoring comment\n\t * nodes on the same line as the parent's opening brace.\n\t */\n\n\tconst parentNodes = parentNode.nodes;\n\n\tif (!parentNodes) {\n\t\treturn false;\n\t}\n\n\tconst firstNode = parentNodes[0];\n\n\tif (\n\t\t!isComment(firstNode) ||\n\t\t(typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\\n'))\n\t) {\n\t\treturn false;\n\t}\n\n\tif (!hasSource(firstNode) || !firstNode.source.start) {\n\t\treturn false;\n\t}\n\n\tconst openingBraceLine = firstNode.source.start.line;\n\n\tif (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 1; i < parentNodes.length; i++) {\n\t\tconst node = parentNodes[i];\n\n\t\tif (node === statement) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\t!isComment(node) ||\n\t\t\t(hasSource(node) && node.source.end && node.source.end.line !== openingBraceLine)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* istanbul ignore next: Should always return in the loop */\n\treturn false;\n};\n"]},"metadata":{},"sourceType":"script"}