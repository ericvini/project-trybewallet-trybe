{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst blurFunctionArguments = require('../../utils/blurFunctionArguments');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'color-hex-case';\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['lower', 'upper']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      const declString = blurFunctionArguments(decl.toString(), 'url');\n      const fixPositions = [];\n      styleSearch({\n        source: declString,\n        target: '#'\n      }, match => {\n        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex));\n\n        if (!hexMatch) {\n          return;\n        }\n\n        const hexValue = hexMatch[0];\n        const hexValueLower = hexValue.toLowerCase();\n        const hexValueUpper = hexValue.toUpperCase();\n        const expectedHex = expectation === 'lower' ? hexValueLower : hexValueUpper;\n\n        if (hexValue === expectedHex) {\n          return;\n        }\n\n        if (context.fix) {\n          fixPositions.unshift({\n            expectedHex,\n            currentHex: hexValue,\n            startIndex: match.startIndex\n          });\n          return;\n        }\n\n        report({\n          message: messages.expected(hexValue, expectedHex),\n          node: decl,\n          index: match.startIndex,\n          result,\n          ruleName\n        });\n      });\n\n      if (fixPositions.length) {\n        const declProp = decl.prop;\n        const declBetween = decl.raws.between;\n        fixPositions.forEach(fixPosition => {\n          // 1 — it's a # length\n          decl.value = replaceHex(decl.value, fixPosition.currentHex, fixPosition.expectedHex, fixPosition.startIndex - declProp.length - declBetween.length - 1);\n        });\n      }\n    });\n  };\n}\n\nfunction replaceHex(input, searchString, replaceString, startIndex) {\n  const offset = startIndex + 1;\n  const stringStart = input.slice(0, offset);\n  const stringEnd = input.slice(offset + searchString.length);\n  return stringStart + replaceString + stringEnd;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/color-hex-case/index.js"],"names":["blurFunctionArguments","require","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","expected","actual","rule","expectation","options","context","root","result","validOptions","possible","walkDecls","decl","declString","toString","fixPositions","source","target","match","hexMatch","exec","substr","startIndex","hexValue","hexValueLower","toLowerCase","hexValueUpper","toUpperCase","expectedHex","fix","unshift","currentHex","message","node","index","length","declProp","prop","declBetween","raws","between","forEach","fixPosition","value","replaceHex","input","searchString","replaceString","offset","stringStart","slice","stringEnd","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst blurFunctionArguments = require('../../utils/blurFunctionArguments');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'color-hex-case';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['lower', 'upper'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst declString = blurFunctionArguments(decl.toString(), 'url');\n\t\t\tconst fixPositions = [];\n\n\t\t\tstyleSearch({ source: declString, target: '#' }, (match) => {\n\t\t\t\tconst hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex));\n\n\t\t\t\tif (!hexMatch) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst hexValue = hexMatch[0];\n\t\t\t\tconst hexValueLower = hexValue.toLowerCase();\n\t\t\t\tconst hexValueUpper = hexValue.toUpperCase();\n\t\t\t\tconst expectedHex = expectation === 'lower' ? hexValueLower : hexValueUpper;\n\n\t\t\t\tif (hexValue === expectedHex) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tfixPositions.unshift({\n\t\t\t\t\t\texpectedHex,\n\t\t\t\t\t\tcurrentHex: hexValue,\n\t\t\t\t\t\tstartIndex: match.startIndex,\n\t\t\t\t\t});\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(hexValue, expectedHex),\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: match.startIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (fixPositions.length) {\n\t\t\t\tconst declProp = decl.prop;\n\t\t\t\tconst declBetween = decl.raws.between;\n\n\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\t// 1 — it's a # length\n\t\t\t\t\tdecl.value = replaceHex(\n\t\t\t\t\t\tdecl.value,\n\t\t\t\t\t\tfixPosition.currentHex,\n\t\t\t\t\t\tfixPosition.expectedHex,\n\t\t\t\t\t\tfixPosition.startIndex - declProp.length - declBetween.length - 1,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction replaceHex(input, searchString, replaceString, startIndex) {\n\tconst offset = startIndex + 1;\n\tconst stringStart = input.slice(0, offset);\n\tconst stringEnd = input.slice(offset + searchString.length);\n\n\treturn stringStart + replaceString + stringEnd;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}