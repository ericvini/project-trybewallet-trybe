{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst parseSelector = require('../../utils/parseSelector');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'string-quotes';\nconst messages = ruleMessages(ruleName, {\n  expected: q => `Expected ${q} quotes`\n});\nconst singleQuote = `'`;\nconst doubleQuote = `\"`;\n\nfunction rule(expectation, secondary, context) {\n  const correctQuote = expectation === 'single' ? singleQuote : doubleQuote;\n  const erroneousQuote = expectation === 'single' ? doubleQuote : singleQuote;\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['single', 'double']\n    }, {\n      actual: secondary,\n      possible: {\n        avoidEscape: _.isBoolean\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const avoidEscape = _.get(secondary, 'avoidEscape', true);\n\n    root.walk(node => {\n      switch (node.type) {\n        case 'atrule':\n          checkDeclOrAtRule(node, node.params, atRuleParamIndex);\n          break;\n\n        case 'decl':\n          checkDeclOrAtRule(node, node.value, declarationValueIndex);\n          break;\n\n        case 'rule':\n          checkRule(node);\n          break;\n      }\n    }); // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    function checkRule(rule) {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      }\n\n      if (!rule.selector.includes('[') || !rule.selector.includes('=')) {\n        return;\n      }\n\n      const fixPositions = [];\n      parseSelector(rule.selector, result, rule, selectorTree => {\n        let selectorFixed = false;\n        selectorTree.walkAttributes(attributeNode => {\n          if (!attributeNode.quoted) {\n            return;\n          }\n\n          if (attributeNode.quoteMark === correctQuote) {\n            if (avoidEscape) {\n              const needsCorrectEscape = attributeNode.value.includes(correctQuote);\n              const needsOtherEscape = attributeNode.value.includes(erroneousQuote);\n\n              if (needsOtherEscape) {\n                return;\n              }\n\n              if (needsCorrectEscape) {\n                if (context.fix) {\n                  selectorFixed = true;\n                  attributeNode.quoteMark = erroneousQuote;\n                } else {\n                  report({\n                    message: messages.expected(expectation === 'single' ? 'double' : expectation),\n                    node: rule,\n                    index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),\n                    result,\n                    ruleName\n                  });\n                }\n              }\n            }\n          }\n\n          if (attributeNode.quoteMark === erroneousQuote) {\n            if (avoidEscape) {\n              const needsCorrectEscape = attributeNode.value.includes(correctQuote);\n              const needsOtherEscape = attributeNode.value.includes(erroneousQuote);\n\n              if (needsOtherEscape) {\n                if (context.fix) {\n                  selectorFixed = true;\n                  attributeNode.quoteMark = correctQuote;\n                } else {\n                  report({\n                    message: messages.expected(expectation),\n                    node: rule,\n                    index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),\n                    result,\n                    ruleName\n                  });\n                }\n\n                return;\n              }\n\n              if (needsCorrectEscape) {\n                return;\n              }\n            }\n\n            if (context.fix) {\n              selectorFixed = true;\n              attributeNode.quoteMark = correctQuote;\n            } else {\n              report({\n                message: messages.expected(expectation),\n                node: rule,\n                index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),\n                result,\n                ruleName\n              });\n            }\n          }\n        });\n\n        if (selectorFixed) {\n          rule.selector = selectorTree.toString();\n        }\n      });\n      fixPositions.forEach(fixIndex => {\n        rule.selector = replaceQuote(rule.selector, fixIndex, correctQuote);\n      });\n    }\n\n    function checkDeclOrAtRule(node, value, getIndex) {\n      const fixPositions = []; // Get out quickly if there are no erroneous quotes\n\n      if (!value.includes(erroneousQuote)) {\n        return;\n      }\n\n      if (node.type === 'atrule' && node.name === 'charset') {\n        // allow @charset rules to have double quotes, in spite of the configuration\n        // TODO: @charset should always use double-quotes, see https://github.com/stylelint/stylelint/issues/2788\n        return;\n      }\n\n      valueParser(value).walk(valueNode => {\n        if (valueNode.type === 'string' && valueNode.quote === erroneousQuote) {\n          const needsEscape = valueNode.value.includes(correctQuote);\n\n          if (avoidEscape && needsEscape) {\n            // don't consider this an error\n            return;\n          }\n\n          const openIndex = valueNode.sourceIndex; // we currently don't fix escapes\n\n          if (context.fix && !needsEscape) {\n            const closeIndex = openIndex + valueNode.value.length + erroneousQuote.length;\n            fixPositions.push(openIndex, closeIndex);\n          } else {\n            report({\n              message: messages.expected(expectation),\n              node,\n              index: getIndex(node) + openIndex,\n              result,\n              ruleName\n            });\n          }\n        }\n      });\n      fixPositions.forEach(fixIndex => {\n        if (node.type === 'atrule') {\n          node.params = replaceQuote(node.params, fixIndex, correctQuote);\n        } else {\n          node.value = replaceQuote(node.value, fixIndex, correctQuote);\n        }\n      });\n    }\n  };\n}\n\nfunction replaceQuote(string, index, replace) {\n  return string.substring(0, index) + replace + string.substring(index + replace.length);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/string-quotes/index.js"],"names":["_","require","atRuleParamIndex","declarationValueIndex","isStandardSyntaxRule","parseSelector","report","ruleMessages","validateOptions","valueParser","ruleName","messages","expected","q","singleQuote","doubleQuote","rule","expectation","secondary","context","correctQuote","erroneousQuote","root","result","validOptions","actual","possible","avoidEscape","isBoolean","optional","get","walk","node","type","checkDeclOrAtRule","params","value","checkRule","selector","includes","fixPositions","selectorTree","selectorFixed","walkAttributes","attributeNode","quoted","quoteMark","needsCorrectEscape","needsOtherEscape","fix","message","index","sourceIndex","offsetOf","toString","forEach","fixIndex","replaceQuote","getIndex","name","valueNode","quote","needsEscape","openIndex","closeIndex","length","push","string","replace","substring","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,8BAAD,CAAhC;;AACA,MAAME,qBAAqB,GAAGF,OAAO,CAAC,mCAAD,CAArC;;AACA,MAAMG,oBAAoB,GAAGH,OAAO,CAAC,kCAAD,CAApC;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMO,eAAe,GAAGP,OAAO,CAAC,6BAAD,CAA/B;;AACA,MAAMQ,WAAW,GAAGR,OAAO,CAAC,sBAAD,CAA3B;;AAEA,MAAMS,QAAQ,GAAG,eAAjB;AAEA,MAAMC,QAAQ,GAAGJ,YAAY,CAACG,QAAD,EAAW;AACvCE,EAAAA,QAAQ,EAAGC,CAAD,IAAQ,YAAWA,CAAE;AADQ,CAAX,CAA7B;AAIA,MAAMC,WAAW,GAAI,GAArB;AACA,MAAMC,WAAW,GAAI,GAArB;;AAEA,SAASC,IAAT,CAAcC,WAAd,EAA2BC,SAA3B,EAAsCC,OAAtC,EAA+C;AAC9C,QAAMC,YAAY,GAAGH,WAAW,KAAK,QAAhB,GAA2BH,WAA3B,GAAyCC,WAA9D;AACA,QAAMM,cAAc,GAAGJ,WAAW,KAAK,QAAhB,GAA2BF,WAA3B,GAAyCD,WAAhE;AAEA,SAAO,CAACQ,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGhB,eAAe,CACnCe,MADmC,EAEnCb,QAFmC,EAGnC;AACCe,MAAAA,MAAM,EAAER,WADT;AAECS,MAAAA,QAAQ,EAAE,CAAC,QAAD,EAAW,QAAX;AAFX,KAHmC,EAOnC;AACCD,MAAAA,MAAM,EAAEP,SADT;AAECQ,MAAAA,QAAQ,EAAE;AACTC,QAAAA,WAAW,EAAE3B,CAAC,CAAC4B;AADN,OAFX;AAKCC,MAAAA,QAAQ,EAAE;AALX,KAPmC,CAApC;;AAgBA,QAAI,CAACL,YAAL,EAAmB;AAClB;AACA;;AAED,UAAMG,WAAW,GAAG3B,CAAC,CAAC8B,GAAF,CAAMZ,SAAN,EAAiB,aAAjB,EAAgC,IAAhC,CAApB;;AAEAI,IAAAA,IAAI,CAACS,IAAL,CAAWC,IAAD,IAAU;AACnB,cAAQA,IAAI,CAACC,IAAb;AACC,aAAK,QAAL;AACCC,UAAAA,iBAAiB,CAACF,IAAD,EAAOA,IAAI,CAACG,MAAZ,EAAoBjC,gBAApB,CAAjB;AACA;;AACD,aAAK,MAAL;AACCgC,UAAAA,iBAAiB,CAACF,IAAD,EAAOA,IAAI,CAACI,KAAZ,EAAmBjC,qBAAnB,CAAjB;AACA;;AACD,aAAK,MAAL;AACCkC,UAAAA,SAAS,CAACL,IAAD,CAAT;AACA;AATF;AAWA,KAZD,EAvBwB,CAqCxB;AACA;;AACA,aAASK,SAAT,CAAmBrB,IAAnB,EAAyB;AACxB,UAAI,CAACZ,oBAAoB,CAACY,IAAD,CAAzB,EAAiC;AAChC;AACA;;AAED,UAAI,CAACA,IAAI,CAACsB,QAAL,CAAcC,QAAd,CAAuB,GAAvB,CAAD,IAAgC,CAACvB,IAAI,CAACsB,QAAL,CAAcC,QAAd,CAAuB,GAAvB,CAArC,EAAkE;AACjE;AACA;;AAED,YAAMC,YAAY,GAAG,EAArB;AAEAnC,MAAAA,aAAa,CAACW,IAAI,CAACsB,QAAN,EAAgBf,MAAhB,EAAwBP,IAAxB,EAA+ByB,YAAD,IAAkB;AAC5D,YAAIC,aAAa,GAAG,KAApB;AAEAD,QAAAA,YAAY,CAACE,cAAb,CAA6BC,aAAD,IAAmB;AAC9C,cAAI,CAACA,aAAa,CAACC,MAAnB,EAA2B;AAC1B;AACA;;AAED,cAAID,aAAa,CAACE,SAAd,KAA4B1B,YAAhC,EAA8C;AAC7C,gBAAIO,WAAJ,EAAiB;AAChB,oBAAMoB,kBAAkB,GAAGH,aAAa,CAACR,KAAd,CAAoBG,QAApB,CAA6BnB,YAA7B,CAA3B;AACA,oBAAM4B,gBAAgB,GAAGJ,aAAa,CAACR,KAAd,CAAoBG,QAApB,CAA6BlB,cAA7B,CAAzB;;AAEA,kBAAI2B,gBAAJ,EAAsB;AACrB;AACA;;AAED,kBAAID,kBAAJ,EAAwB;AACvB,oBAAI5B,OAAO,CAAC8B,GAAZ,EAAiB;AAChBP,kBAAAA,aAAa,GAAG,IAAhB;AACAE,kBAAAA,aAAa,CAACE,SAAd,GAA0BzB,cAA1B;AACA,iBAHD,MAGO;AACNf,kBAAAA,MAAM,CAAC;AACN4C,oBAAAA,OAAO,EAAEvC,QAAQ,CAACC,QAAT,CAAkBK,WAAW,KAAK,QAAhB,GAA2B,QAA3B,GAAsCA,WAAxD,CADH;AAENe,oBAAAA,IAAI,EAAEhB,IAFA;AAGNmC,oBAAAA,KAAK,EAAEP,aAAa,CAACQ,WAAd,GAA4BR,aAAa,CAACS,QAAd,CAAuB,OAAvB,CAH7B;AAIN9B,oBAAAA,MAJM;AAKNb,oBAAAA;AALM,mBAAD,CAAN;AAOA;AACD;AACD;AACD;;AAED,cAAIkC,aAAa,CAACE,SAAd,KAA4BzB,cAAhC,EAAgD;AAC/C,gBAAIM,WAAJ,EAAiB;AAChB,oBAAMoB,kBAAkB,GAAGH,aAAa,CAACR,KAAd,CAAoBG,QAApB,CAA6BnB,YAA7B,CAA3B;AACA,oBAAM4B,gBAAgB,GAAGJ,aAAa,CAACR,KAAd,CAAoBG,QAApB,CAA6BlB,cAA7B,CAAzB;;AAEA,kBAAI2B,gBAAJ,EAAsB;AACrB,oBAAI7B,OAAO,CAAC8B,GAAZ,EAAiB;AAChBP,kBAAAA,aAAa,GAAG,IAAhB;AACAE,kBAAAA,aAAa,CAACE,SAAd,GAA0B1B,YAA1B;AACA,iBAHD,MAGO;AACNd,kBAAAA,MAAM,CAAC;AACN4C,oBAAAA,OAAO,EAAEvC,QAAQ,CAACC,QAAT,CAAkBK,WAAlB,CADH;AAENe,oBAAAA,IAAI,EAAEhB,IAFA;AAGNmC,oBAAAA,KAAK,EAAEP,aAAa,CAACQ,WAAd,GAA4BR,aAAa,CAACS,QAAd,CAAuB,OAAvB,CAH7B;AAIN9B,oBAAAA,MAJM;AAKNb,oBAAAA;AALM,mBAAD,CAAN;AAOA;;AAED;AACA;;AAED,kBAAIqC,kBAAJ,EAAwB;AACvB;AACA;AACD;;AAED,gBAAI5B,OAAO,CAAC8B,GAAZ,EAAiB;AAChBP,cAAAA,aAAa,GAAG,IAAhB;AACAE,cAAAA,aAAa,CAACE,SAAd,GAA0B1B,YAA1B;AACA,aAHD,MAGO;AACNd,cAAAA,MAAM,CAAC;AACN4C,gBAAAA,OAAO,EAAEvC,QAAQ,CAACC,QAAT,CAAkBK,WAAlB,CADH;AAENe,gBAAAA,IAAI,EAAEhB,IAFA;AAGNmC,gBAAAA,KAAK,EAAEP,aAAa,CAACQ,WAAd,GAA4BR,aAAa,CAACS,QAAd,CAAuB,OAAvB,CAH7B;AAIN9B,gBAAAA,MAJM;AAKNb,gBAAAA;AALM,eAAD,CAAN;AAOA;AACD;AACD,SAvED;;AAyEA,YAAIgC,aAAJ,EAAmB;AAClB1B,UAAAA,IAAI,CAACsB,QAAL,GAAgBG,YAAY,CAACa,QAAb,EAAhB;AACA;AACD,OA/EY,CAAb;AAiFAd,MAAAA,YAAY,CAACe,OAAb,CAAsBC,QAAD,IAAc;AAClCxC,QAAAA,IAAI,CAACsB,QAAL,GAAgBmB,YAAY,CAACzC,IAAI,CAACsB,QAAN,EAAgBkB,QAAhB,EAA0BpC,YAA1B,CAA5B;AACA,OAFD;AAGA;;AAED,aAASc,iBAAT,CAA2BF,IAA3B,EAAiCI,KAAjC,EAAwCsB,QAAxC,EAAkD;AACjD,YAAMlB,YAAY,GAAG,EAArB,CADiD,CAGjD;;AACA,UAAI,CAACJ,KAAK,CAACG,QAAN,CAAelB,cAAf,CAAL,EAAqC;AACpC;AACA;;AAED,UAAIW,IAAI,CAACC,IAAL,KAAc,QAAd,IAA0BD,IAAI,CAAC2B,IAAL,KAAc,SAA5C,EAAuD;AACtD;AACA;AACA;AACA;;AAEDlD,MAAAA,WAAW,CAAC2B,KAAD,CAAX,CAAmBL,IAAnB,CAAyB6B,SAAD,IAAe;AACtC,YAAIA,SAAS,CAAC3B,IAAV,KAAmB,QAAnB,IAA+B2B,SAAS,CAACC,KAAV,KAAoBxC,cAAvD,EAAuE;AACtE,gBAAMyC,WAAW,GAAGF,SAAS,CAACxB,KAAV,CAAgBG,QAAhB,CAAyBnB,YAAzB,CAApB;;AAEA,cAAIO,WAAW,IAAImC,WAAnB,EAAgC;AAC/B;AACA;AACA;;AAED,gBAAMC,SAAS,GAAGH,SAAS,CAACR,WAA5B,CARsE,CAUtE;;AACA,cAAIjC,OAAO,CAAC8B,GAAR,IAAe,CAACa,WAApB,EAAiC;AAChC,kBAAME,UAAU,GAAGD,SAAS,GAAGH,SAAS,CAACxB,KAAV,CAAgB6B,MAA5B,GAAqC5C,cAAc,CAAC4C,MAAvE;AAEAzB,YAAAA,YAAY,CAAC0B,IAAb,CAAkBH,SAAlB,EAA6BC,UAA7B;AACA,WAJD,MAIO;AACN1D,YAAAA,MAAM,CAAC;AACN4C,cAAAA,OAAO,EAAEvC,QAAQ,CAACC,QAAT,CAAkBK,WAAlB,CADH;AAENe,cAAAA,IAFM;AAGNmB,cAAAA,KAAK,EAAEO,QAAQ,CAAC1B,IAAD,CAAR,GAAiB+B,SAHlB;AAINxC,cAAAA,MAJM;AAKNb,cAAAA;AALM,aAAD,CAAN;AAOA;AACD;AACD,OA1BD;AA4BA8B,MAAAA,YAAY,CAACe,OAAb,CAAsBC,QAAD,IAAc;AAClC,YAAIxB,IAAI,CAACC,IAAL,KAAc,QAAlB,EAA4B;AAC3BD,UAAAA,IAAI,CAACG,MAAL,GAAcsB,YAAY,CAACzB,IAAI,CAACG,MAAN,EAAcqB,QAAd,EAAwBpC,YAAxB,CAA1B;AACA,SAFD,MAEO;AACNY,UAAAA,IAAI,CAACI,KAAL,GAAaqB,YAAY,CAACzB,IAAI,CAACI,KAAN,EAAaoB,QAAb,EAAuBpC,YAAvB,CAAzB;AACA;AACD,OAND;AAOA;AACD,GA1LD;AA2LA;;AAED,SAASqC,YAAT,CAAsBU,MAAtB,EAA8BhB,KAA9B,EAAqCiB,OAArC,EAA8C;AAC7C,SAAOD,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBlB,KAApB,IAA6BiB,OAA7B,GAAuCD,MAAM,CAACE,SAAP,CAAiBlB,KAAK,GAAGiB,OAAO,CAACH,MAAjC,CAA9C;AACA;;AAEDjD,IAAI,CAACN,QAAL,GAAgBA,QAAhB;AACAM,IAAI,CAACL,QAAL,GAAgBA,QAAhB;AACA2D,MAAM,CAACC,OAAP,GAAiBvD,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst atRuleParamIndex = require('../../utils/atRuleParamIndex');\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst parseSelector = require('../../utils/parseSelector');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'string-quotes';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (q) => `Expected ${q} quotes`,\n});\n\nconst singleQuote = `'`;\nconst doubleQuote = `\"`;\n\nfunction rule(expectation, secondary, context) {\n\tconst correctQuote = expectation === 'single' ? singleQuote : doubleQuote;\n\tconst erroneousQuote = expectation === 'single' ? doubleQuote : singleQuote;\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['single', 'double'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: secondary,\n\t\t\t\tpossible: {\n\t\t\t\t\tavoidEscape: _.isBoolean,\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst avoidEscape = _.get(secondary, 'avoidEscape', true);\n\n\t\troot.walk((node) => {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'atrule':\n\t\t\t\t\tcheckDeclOrAtRule(node, node.params, atRuleParamIndex);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'decl':\n\t\t\t\t\tcheckDeclOrAtRule(node, node.value, declarationValueIndex);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rule':\n\t\t\t\t\tcheckRule(node);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction checkRule(rule) {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!rule.selector.includes('[') || !rule.selector.includes('=')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fixPositions = [];\n\n\t\t\tparseSelector(rule.selector, result, rule, (selectorTree) => {\n\t\t\t\tlet selectorFixed = false;\n\n\t\t\t\tselectorTree.walkAttributes((attributeNode) => {\n\t\t\t\t\tif (!attributeNode.quoted) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributeNode.quoteMark === correctQuote) {\n\t\t\t\t\t\tif (avoidEscape) {\n\t\t\t\t\t\t\tconst needsCorrectEscape = attributeNode.value.includes(correctQuote);\n\t\t\t\t\t\t\tconst needsOtherEscape = attributeNode.value.includes(erroneousQuote);\n\n\t\t\t\t\t\t\tif (needsOtherEscape) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (needsCorrectEscape) {\n\t\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\t\tselectorFixed = true;\n\t\t\t\t\t\t\t\t\tattributeNode.quoteMark = erroneousQuote;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treport({\n\t\t\t\t\t\t\t\t\t\tmessage: messages.expected(expectation === 'single' ? 'double' : expectation),\n\t\t\t\t\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\t\t\t\t\tindex: attributeNode.sourceIndex + attributeNode.offsetOf('value'),\n\t\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributeNode.quoteMark === erroneousQuote) {\n\t\t\t\t\t\tif (avoidEscape) {\n\t\t\t\t\t\t\tconst needsCorrectEscape = attributeNode.value.includes(correctQuote);\n\t\t\t\t\t\t\tconst needsOtherEscape = attributeNode.value.includes(erroneousQuote);\n\n\t\t\t\t\t\t\tif (needsOtherEscape) {\n\t\t\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\t\t\tselectorFixed = true;\n\t\t\t\t\t\t\t\t\tattributeNode.quoteMark = correctQuote;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treport({\n\t\t\t\t\t\t\t\t\t\tmessage: messages.expected(expectation),\n\t\t\t\t\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\t\t\t\t\tindex: attributeNode.sourceIndex + attributeNode.offsetOf('value'),\n\t\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (needsCorrectEscape) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\t\tselectorFixed = true;\n\t\t\t\t\t\t\tattributeNode.quoteMark = correctQuote;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treport({\n\t\t\t\t\t\t\t\tmessage: messages.expected(expectation),\n\t\t\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\t\t\tindex: attributeNode.sourceIndex + attributeNode.offsetOf('value'),\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (selectorFixed) {\n\t\t\t\t\trule.selector = selectorTree.toString();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfixPositions.forEach((fixIndex) => {\n\t\t\t\trule.selector = replaceQuote(rule.selector, fixIndex, correctQuote);\n\t\t\t});\n\t\t}\n\n\t\tfunction checkDeclOrAtRule(node, value, getIndex) {\n\t\t\tconst fixPositions = [];\n\n\t\t\t// Get out quickly if there are no erroneous quotes\n\t\t\tif (!value.includes(erroneousQuote)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node.type === 'atrule' && node.name === 'charset') {\n\t\t\t\t// allow @charset rules to have double quotes, in spite of the configuration\n\t\t\t\t// TODO: @charset should always use double-quotes, see https://github.com/stylelint/stylelint/issues/2788\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalueParser(value).walk((valueNode) => {\n\t\t\t\tif (valueNode.type === 'string' && valueNode.quote === erroneousQuote) {\n\t\t\t\t\tconst needsEscape = valueNode.value.includes(correctQuote);\n\n\t\t\t\t\tif (avoidEscape && needsEscape) {\n\t\t\t\t\t\t// don't consider this an error\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst openIndex = valueNode.sourceIndex;\n\n\t\t\t\t\t// we currently don't fix escapes\n\t\t\t\t\tif (context.fix && !needsEscape) {\n\t\t\t\t\t\tconst closeIndex = openIndex + valueNode.value.length + erroneousQuote.length;\n\n\t\t\t\t\t\tfixPositions.push(openIndex, closeIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treport({\n\t\t\t\t\t\t\tmessage: messages.expected(expectation),\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tindex: getIndex(node) + openIndex,\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfixPositions.forEach((fixIndex) => {\n\t\t\t\tif (node.type === 'atrule') {\n\t\t\t\t\tnode.params = replaceQuote(node.params, fixIndex, correctQuote);\n\t\t\t\t} else {\n\t\t\t\t\tnode.value = replaceQuote(node.value, fixIndex, correctQuote);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction replaceQuote(string, index, replace) {\n\treturn string.substring(0, index) + replace + string.substring(index + replace.length);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}