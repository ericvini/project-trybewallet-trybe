{"ast":null,"code":"\"use strict\";\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar tokenizer = require('postcss/lib/tokenize');\n\nvar Comment = require('postcss/lib/comment');\n\nvar Parser = require('postcss/lib/parser');\n\nvar SafeParser = /*#__PURE__*/function (_Parser) {\n  _inheritsLoose(SafeParser, _Parser);\n\n  function SafeParser() {\n    return _Parser.apply(this, arguments) || this;\n  }\n\n  var _proto = SafeParser.prototype;\n\n  _proto.createTokenizer = function createTokenizer() {\n    this.tokenizer = tokenizer(this.input, {\n      ignoreErrors: true\n    });\n  };\n\n  _proto.comment = function comment(token) {\n    var node = new Comment();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2);\n    if (text.slice(-2) === '*/') text = text.slice(0, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  _proto.decl = function decl(tokens) {\n    if (tokens.length > 1 && tokens.some(function (i) {\n      return i[0] === 'word';\n    })) {\n      _Parser.prototype.decl.call(this, tokens);\n    }\n  };\n\n  _proto.unclosedBracket = function unclosedBracket() {};\n\n  _proto.unknownWord = function unknownWord(tokens) {\n    this.spaces += tokens.map(function (i) {\n      return i[1];\n    }).join('');\n  };\n\n  _proto.unexpectedClose = function unexpectedClose() {\n    this.current.raws.after += '}';\n  };\n\n  _proto.doubleColon = function doubleColon() {};\n\n  _proto.unnamedAtrule = function unnamedAtrule(node) {\n    node.name = '';\n  };\n\n  _proto.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var split;\n\n    for (split = colon - 1; split >= 0; split--) {\n      if (tokens[split][0] === 'word') break;\n    }\n\n    for (split -= 1; split >= 0; split--) {\n      if (tokens[split][0] !== 'space') {\n        split += 1;\n        break;\n      }\n    }\n\n    var other = tokens.splice(split, tokens.length - split);\n    this.decl(other);\n  };\n\n  _proto.checkMissedSemicolon = function checkMissedSemicolon() {};\n\n  _proto.endFile = function endFile() {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n\n    while (this.current.parent) {\n      this.current = this.current.parent;\n      this.current.raws.after = '';\n    }\n  };\n\n  return SafeParser;\n}(Parser);\n\nmodule.exports = SafeParser;","map":{"version":3,"sources":["safe-parser.es6"],"names":["tokenizer","require","Comment","Parser","SafeParser","createTokenizer","ignoreErrors","comment","node","token","line","column","text","match","decl","tokens","i","unclosedBracket","unknownWord","unexpectedClose","doubleColon","unnamedAtrule","precheckMissedSemicolon","colon","split","other","checkMissedSemicolon","endFile","module"],"mappings":"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","sourcesContent":["let tokenizer = require('postcss/lib/tokenize')\nlet Comment = require('postcss/lib/comment')\nlet Parser = require('postcss/lib/parser')\n\nclass SafeParser extends Parser {\n  createTokenizer () {\n    this.tokenizer = tokenizer(this.input, { ignoreErrors: true })\n  }\n\n  comment (token) {\n    let node = new Comment()\n    this.init(node, token[2], token[3])\n    node.source.end = { line: token[4], column: token[5] }\n\n    let text = token[1].slice(2)\n    if (text.slice(-2) === '*/') text = text.slice(0, -2)\n\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  decl (tokens) {\n    if (tokens.length > 1 && tokens.some(i => i[0] === 'word')) {\n      super.decl(tokens)\n    }\n  }\n\n  unclosedBracket () { }\n\n  unknownWord (tokens) {\n    this.spaces += tokens.map(i => i[1]).join('')\n  }\n\n  unexpectedClose () {\n    this.current.raws.after += '}'\n  }\n\n  doubleColon () { }\n\n  unnamedAtrule (node) {\n    node.name = ''\n  }\n\n  precheckMissedSemicolon (tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let split\n    for (split = colon - 1; split >= 0; split--) {\n      if (tokens[split][0] === 'word') break\n    }\n    for (split -= 1; split >= 0; split--) {\n      if (tokens[split][0] !== 'space') {\n        split += 1\n        break\n      }\n    }\n    let other = tokens.splice(split, tokens.length - split)\n    this.decl(other)\n  }\n\n  checkMissedSemicolon () { }\n\n  endFile () {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n\n    while (this.current.parent) {\n      this.current = this.current.parent\n      this.current.raws.after = ''\n    }\n  }\n}\n\nmodule.exports = SafeParser\n"]},"metadata":{},"sourceType":"script"}