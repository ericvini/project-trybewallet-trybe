{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isCustomPropertySet = require('../../utils/isCustomPropertySet');\n\nconst isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'no-extra-semicolons';\nconst messages = ruleMessages(ruleName, {\n  rejected: 'Unexpected extra semicolon'\n});\n\nfunction getOffsetByNode(node) {\n  if (node.parent && node.parent.document) {\n    return 0;\n  }\n\n  const string = node.root().source.input.css;\n  const nodeColumn = node.source.start.column;\n  const nodeLine = node.source.start.line;\n  let line = 1;\n  let column = 1;\n  let index = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    if (column === nodeColumn && nodeLine === line) {\n      index = i;\n      break;\n    }\n\n    if (string[i] === '\\n') {\n      column = 1;\n      line += 1;\n    } else {\n      column += 1;\n    }\n  }\n\n  return index;\n}\n\nfunction rule(actual, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const rawAfterRoot = root.raws.after;\n\n    if (rawAfterRoot && rawAfterRoot.trim().length !== 0) {\n      const fixSemiIndices = [];\n      styleSearch({\n        source: rawAfterRoot,\n        target: ';'\n      }, match => {\n        if (context.fix) {\n          fixSemiIndices.push(match.startIndex);\n          return;\n        }\n\n        complain(root.source.input.css.length - rawAfterRoot.length + match.startIndex);\n      }); // fix\n\n      if (fixSemiIndices.length) {\n        root.raws.after = removeIndices(rawAfterRoot, fixSemiIndices);\n      }\n    }\n\n    root.walk(node => {\n      if (node.type === 'atrule' && !isStandardSyntaxAtRule(node)) {\n        return;\n      }\n\n      if (node.type === 'rule' && !isCustomPropertySet(node) && !isStandardSyntaxRule(node)) {\n        return;\n      }\n\n      let rawBeforeNode = node.raws.before;\n\n      if (rawBeforeNode && rawBeforeNode.trim().length !== 0) {\n        let allowedSemi = 0;\n        const next = node.next(); // Ignore semicolon before comment if next node is custom properties sets or comment\n\n        if (node.type === 'comment' && next && isCustomPropertySet(next) && node.parent.index(next) > 0) {\n          allowedSemi = 1;\n        }\n\n        const prev = node.prev();\n        let rawBeforeIndexStart = 0; // Adding previous node string to custom properties set if previous node is comment\n\n        if (isCustomPropertySet(node) && node.parent.index(node) > 0 && prev && prev.type === 'comment') {\n          rawBeforeNode = prev.toString() + rawBeforeNode;\n          allowedSemi = 0;\n          rawBeforeIndexStart = prev.toString().length;\n        }\n\n        const fixSemiIndices = [];\n        styleSearch({\n          source: rawBeforeNode,\n          target: ';'\n        }, (match, count) => {\n          if (count === allowedSemi) {\n            return;\n          }\n\n          if (context.fix) {\n            fixSemiIndices.push(match.startIndex - rawBeforeIndexStart);\n            return;\n          }\n\n          complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex);\n        }); // fix\n\n        if (fixSemiIndices.length) {\n          node.raws.before = removeIndices(node.raws.before, fixSemiIndices);\n        }\n      }\n\n      const rawAfterNode = node.raws.after;\n\n      if (rawAfterNode && rawAfterNode.trim().length !== 0) {\n        /**\n         * If the last child is a Less mixin followed by more than one semicolon,\n         * node.raws.after will be populated with that semicolon.\n         * Since we ignore Less mixins, exit here\n         */\n        if (node.last && node.last.type === 'atrule' && !isCustomPropertySet(node.last) && !isStandardSyntaxAtRule(node.last)) {\n          return;\n        }\n\n        const fixSemiIndices = [];\n        styleSearch({\n          source: rawAfterNode,\n          target: ';'\n        }, match => {\n          if (context.fix) {\n            fixSemiIndices.push(match.startIndex);\n            return;\n          }\n\n          const index = getOffsetByNode(node) + node.toString().length - 1 - rawAfterNode.length + match.startIndex;\n          complain(index);\n        }); // fix\n\n        if (fixSemiIndices.length) {\n          node.raws.after = removeIndices(rawAfterNode, fixSemiIndices);\n        }\n      }\n\n      const rawOwnSemicolon = node.raws.ownSemicolon;\n\n      if (rawOwnSemicolon) {\n        let allowedSemi = 0;\n\n        if (isCustomPropertySet(node)) {\n          allowedSemi = 1;\n        }\n\n        const fixSemiIndices = [];\n        styleSearch({\n          source: rawOwnSemicolon,\n          target: ';'\n        }, (match, count) => {\n          if (count === allowedSemi) {\n            return;\n          }\n\n          if (context.fix) {\n            fixSemiIndices.push(match.startIndex);\n            return;\n          }\n\n          const index = getOffsetByNode(node) + node.toString().length - rawOwnSemicolon.length + match.startIndex;\n          complain(index);\n        }); // fix\n\n        if (fixSemiIndices.length) {\n          node.raws.ownSemicolon = removeIndices(rawOwnSemicolon, fixSemiIndices);\n        }\n      }\n    });\n\n    function complain(index) {\n      report({\n        message: messages.rejected,\n        node: root,\n        index,\n        result,\n        ruleName\n      });\n    }\n\n    function removeIndices(str, indices) {\n      indices.reverse().forEach(index => {\n        str = str.slice(0, index) + str.slice(index + 1);\n      });\n      return str;\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/no-extra-semicolons/index.js"],"names":["isCustomPropertySet","require","isStandardSyntaxAtRule","isStandardSyntaxRule","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","rejected","getOffsetByNode","node","parent","document","string","root","source","input","css","nodeColumn","start","column","nodeLine","line","index","i","length","rule","actual","options","context","result","validOptions","rawAfterRoot","raws","after","trim","fixSemiIndices","target","match","fix","push","startIndex","complain","removeIndices","walk","type","rawBeforeNode","before","allowedSemi","next","prev","rawBeforeIndexStart","toString","count","rawAfterNode","last","rawOwnSemicolon","ownSemicolon","message","str","indices","reverse","forEach","slice","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isCustomPropertySet = require('../../utils/isCustomPropertySet');\nconst isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'no-extra-semicolons';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: 'Unexpected extra semicolon',\n});\n\nfunction getOffsetByNode(node) {\n\tif (node.parent && node.parent.document) {\n\t\treturn 0;\n\t}\n\n\tconst string = node.root().source.input.css;\n\tconst nodeColumn = node.source.start.column;\n\tconst nodeLine = node.source.start.line;\n\tlet line = 1;\n\tlet column = 1;\n\tlet index = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (column === nodeColumn && nodeLine === line) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (string[i] === '\\n') {\n\t\t\tcolumn = 1;\n\t\t\tline += 1;\n\t\t} else {\n\t\t\tcolumn += 1;\n\t\t}\n\t}\n\n\treturn index;\n}\n\nfunction rule(actual, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, { actual });\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst rawAfterRoot = root.raws.after;\n\n\t\tif (rawAfterRoot && rawAfterRoot.trim().length !== 0) {\n\t\t\tconst fixSemiIndices = [];\n\n\t\t\tstyleSearch({ source: rawAfterRoot, target: ';' }, (match) => {\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tfixSemiIndices.push(match.startIndex);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcomplain(root.source.input.css.length - rawAfterRoot.length + match.startIndex);\n\t\t\t});\n\n\t\t\t// fix\n\t\t\tif (fixSemiIndices.length) {\n\t\t\t\troot.raws.after = removeIndices(rawAfterRoot, fixSemiIndices);\n\t\t\t}\n\t\t}\n\n\t\troot.walk((node) => {\n\t\t\tif (node.type === 'atrule' && !isStandardSyntaxAtRule(node)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node.type === 'rule' && !isCustomPropertySet(node) && !isStandardSyntaxRule(node)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet rawBeforeNode = node.raws.before;\n\n\t\t\tif (rawBeforeNode && rawBeforeNode.trim().length !== 0) {\n\t\t\t\tlet allowedSemi = 0;\n\n\t\t\t\tconst next = node.next();\n\n\t\t\t\t// Ignore semicolon before comment if next node is custom properties sets or comment\n\t\t\t\tif (\n\t\t\t\t\tnode.type === 'comment' &&\n\t\t\t\t\tnext &&\n\t\t\t\t\tisCustomPropertySet(next) &&\n\t\t\t\t\tnode.parent.index(next) > 0\n\t\t\t\t) {\n\t\t\t\t\tallowedSemi = 1;\n\t\t\t\t}\n\n\t\t\t\tconst prev = node.prev();\n\n\t\t\t\tlet rawBeforeIndexStart = 0;\n\n\t\t\t\t// Adding previous node string to custom properties set if previous node is comment\n\t\t\t\tif (\n\t\t\t\t\tisCustomPropertySet(node) &&\n\t\t\t\t\tnode.parent.index(node) > 0 &&\n\t\t\t\t\tprev &&\n\t\t\t\t\tprev.type === 'comment'\n\t\t\t\t) {\n\t\t\t\t\trawBeforeNode = prev.toString() + rawBeforeNode;\n\t\t\t\t\tallowedSemi = 0;\n\t\t\t\t\trawBeforeIndexStart = prev.toString().length;\n\t\t\t\t}\n\n\t\t\t\tconst fixSemiIndices = [];\n\n\t\t\t\tstyleSearch({ source: rawBeforeNode, target: ';' }, (match, count) => {\n\t\t\t\t\tif (count === allowedSemi) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tfixSemiIndices.push(match.startIndex - rawBeforeIndexStart);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcomplain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex);\n\t\t\t\t});\n\n\t\t\t\t// fix\n\t\t\t\tif (fixSemiIndices.length) {\n\t\t\t\t\tnode.raws.before = removeIndices(node.raws.before, fixSemiIndices);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst rawAfterNode = node.raws.after;\n\n\t\t\tif (rawAfterNode && rawAfterNode.trim().length !== 0) {\n\t\t\t\t/**\n\t\t\t\t * If the last child is a Less mixin followed by more than one semicolon,\n\t\t\t\t * node.raws.after will be populated with that semicolon.\n\t\t\t\t * Since we ignore Less mixins, exit here\n\t\t\t\t */\n\t\t\t\tif (\n\t\t\t\t\tnode.last &&\n\t\t\t\t\tnode.last.type === 'atrule' &&\n\t\t\t\t\t!isCustomPropertySet(node.last) &&\n\t\t\t\t\t!isStandardSyntaxAtRule(node.last)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst fixSemiIndices = [];\n\n\t\t\t\tstyleSearch({ source: rawAfterNode, target: ';' }, (match) => {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tfixSemiIndices.push(match.startIndex);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst index =\n\t\t\t\t\t\tgetOffsetByNode(node) +\n\t\t\t\t\t\tnode.toString().length -\n\t\t\t\t\t\t1 -\n\t\t\t\t\t\trawAfterNode.length +\n\t\t\t\t\t\tmatch.startIndex;\n\n\t\t\t\t\tcomplain(index);\n\t\t\t\t});\n\n\t\t\t\t// fix\n\t\t\t\tif (fixSemiIndices.length) {\n\t\t\t\t\tnode.raws.after = removeIndices(rawAfterNode, fixSemiIndices);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst rawOwnSemicolon = node.raws.ownSemicolon;\n\n\t\t\tif (rawOwnSemicolon) {\n\t\t\t\tlet allowedSemi = 0;\n\n\t\t\t\tif (isCustomPropertySet(node)) {\n\t\t\t\t\tallowedSemi = 1;\n\t\t\t\t}\n\n\t\t\t\tconst fixSemiIndices = [];\n\n\t\t\t\tstyleSearch({ source: rawOwnSemicolon, target: ';' }, (match, count) => {\n\t\t\t\t\tif (count === allowedSemi) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tfixSemiIndices.push(match.startIndex);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst index =\n\t\t\t\t\t\tgetOffsetByNode(node) +\n\t\t\t\t\t\tnode.toString().length -\n\t\t\t\t\t\trawOwnSemicolon.length +\n\t\t\t\t\t\tmatch.startIndex;\n\n\t\t\t\t\tcomplain(index);\n\t\t\t\t});\n\n\t\t\t\t// fix\n\t\t\t\tif (fixSemiIndices.length) {\n\t\t\t\t\tnode.raws.ownSemicolon = removeIndices(rawOwnSemicolon, fixSemiIndices);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfunction complain(index) {\n\t\t\treport({\n\t\t\t\tmessage: messages.rejected,\n\t\t\t\tnode: root,\n\t\t\t\tindex,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t}\n\n\t\tfunction removeIndices(str, indices) {\n\t\t\tindices.reverse().forEach((index) => {\n\t\t\t\tstr = str.slice(0, index) + str.slice(index + 1);\n\t\t\t});\n\n\t\t\treturn str;\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}