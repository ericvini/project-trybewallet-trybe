{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _wrapString = _interopRequireDefault(require(\"./wrapString\"));\n\nvar _wrapWord = _interopRequireDefault(require(\"./wrapWord\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Wrap a single cell value into a list of lines\n *\n * Always wraps on newlines, for the remainder uses either word or string wrapping\n * depending on user configuration.\n *\n * @param {string} cellValue\n * @param {number} columnWidth\n * @param {boolean} useWrapWord\n * @returns {Array}\n */\n\n\nconst wrapCell = (cellValue, columnWidth, useWrapWord) => {\n  // First split on literal newlines\n  const cellLines = cellValue.split('\\n'); // Then iterate over the list and word-wrap every remaining line if necessary.\n\n  for (let lineNr = 0; lineNr < cellLines.length;) {\n    let lineChunks;\n\n    if (useWrapWord) {\n      lineChunks = (0, _wrapWord.default)(cellLines[lineNr], columnWidth);\n    } else {\n      lineChunks = (0, _wrapString.default)(cellLines[lineNr], columnWidth);\n    } // Replace our original array element with whatever the wrapping returned\n\n\n    cellLines.splice(lineNr, 1, ...lineChunks);\n    lineNr += lineChunks.length;\n  }\n\n  return cellLines;\n};\n\nvar _default = wrapCell;\nexports.default = _default;","map":{"version":3,"sources":["../src/wrapCell.js"],"names":["cellValue","columnWidth","useWrapWord","cellLines","lineNr","lineChunks"],"mappings":";;;;;;;AAAA,IAAA,WAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,SAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;kBACgBA,S,EAAWC,W,EAAaC,W,KAAgB;AACtD;AACA,QAAMC,SAAS,GAAGH,SAAS,CAATA,KAAAA,CAFoC,IAEpCA,CAAlB,CAFsD,CAItD;;AACA,OAAK,IAAII,MAAM,GAAf,CAAA,EAAqBA,MAAM,GAAGD,SAAS,CAAvC,MAAA,GAAiD;AAC/C,QAAA,UAAA;;AAEA,QAAA,WAAA,EAAiB;AACfE,MAAAA,UAAU,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAASF,SAAS,CAAlB,MAAkB,CAAlB,EAAbE,WAAa,CAAbA;AADF,KAAA,MAEO;AACLA,MAAAA,UAAU,GAAG,CAAA,GAAA,WAAA,CAAA,OAAA,EAAWF,SAAS,CAApB,MAAoB,CAApB,EAAbE,WAAa,CAAbA;AAN6C,KAAA,CAS/C;;;AACAF,IAAAA,SAAS,CAATA,MAAAA,CAAAA,MAAAA,EAAAA,CAAAA,EAA4B,GAA5BA,UAAAA;AACAC,IAAAA,MAAM,IAAIC,UAAU,CAApBD,MAAAA;AACD;;AAED,SAAA,SAAA","sourcesContent":["import wrapString from './wrapString';\nimport wrapWord from './wrapWord';\n\n/**\n * Wrap a single cell value into a list of lines\n *\n * Always wraps on newlines, for the remainder uses either word or string wrapping\n * depending on user configuration.\n *\n * @param {string} cellValue\n * @param {number} columnWidth\n * @param {boolean} useWrapWord\n * @returns {Array}\n */\nexport default (cellValue, columnWidth, useWrapWord) => {\n  // First split on literal newlines\n  const cellLines = cellValue.split('\\n');\n\n  // Then iterate over the list and word-wrap every remaining line if necessary.\n  for (let lineNr = 0; lineNr < cellLines.length;) {\n    let lineChunks;\n\n    if (useWrapWord) {\n      lineChunks = wrapWord(cellLines[lineNr], columnWidth);\n    } else {\n      lineChunks = wrapString(cellLines[lineNr], columnWidth);\n    }\n\n    // Replace our original array element with whatever the wrapping returned\n    cellLines.splice(lineNr, 1, ...lineChunks);\n    lineNr += lineChunks.length;\n  }\n\n  return cellLines;\n};\n"]},"metadata":{},"sourceType":"script"}