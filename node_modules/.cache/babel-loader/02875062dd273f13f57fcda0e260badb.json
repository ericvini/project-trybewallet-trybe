{"ast":null,"code":"'use strict';\n\nvar reusify = require('reusify');\n\nfunction fastqueue(context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker;\n    worker = context;\n    context = null;\n  }\n\n  var cache = reusify(Task);\n  var queueHead = null;\n  var queueTail = null;\n  var _running = 0;\n  var errorHandler = null;\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  };\n  return self;\n\n  function running() {\n    return _running;\n  }\n\n  function pause() {\n    self.paused = true;\n  }\n\n  function length() {\n    var current = queueHead;\n    var counter = 0;\n\n    while (current) {\n      current = current.next;\n      counter++;\n    }\n\n    return counter;\n  }\n\n  function getQueue() {\n    var current = queueHead;\n    var tasks = [];\n\n    while (current) {\n      tasks.push(current.value);\n      current = current.next;\n    }\n\n    return tasks;\n  }\n\n  function resume() {\n    if (!self.paused) return;\n    self.paused = false;\n\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++;\n      release();\n    }\n  }\n\n  function idle() {\n    return _running === 0 && self.length() === 0;\n  }\n\n  function push(value, done) {\n    var current = cache.get();\n    current.context = context;\n    current.release = release;\n    current.value = value;\n    current.callback = done || noop;\n    current.errorHandler = errorHandler;\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current;\n        queueTail = current;\n      } else {\n        queueHead = current;\n        queueTail = current;\n        self.saturated();\n      }\n    } else {\n      _running++;\n      worker.call(context, current.value, current.worked);\n    }\n  }\n\n  function unshift(value, done) {\n    var current = cache.get();\n    current.context = context;\n    current.release = release;\n    current.value = value;\n    current.callback = done || noop;\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead;\n        queueHead = current;\n      } else {\n        queueHead = current;\n        queueTail = current;\n        self.saturated();\n      }\n    } else {\n      _running++;\n      worker.call(context, current.value, current.worked);\n    }\n  }\n\n  function release(holder) {\n    if (holder) {\n      cache.release(holder);\n    }\n\n    var next = queueHead;\n\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null;\n        }\n\n        queueHead = next.next;\n        next.next = null;\n        worker.call(context, next.value, next.worked);\n\n        if (queueTail === null) {\n          self.empty();\n        }\n      } else {\n        _running--;\n      }\n    } else if (--_running === 0) {\n      self.drain();\n    }\n  }\n\n  function kill() {\n    queueHead = null;\n    queueTail = null;\n    self.drain = noop;\n  }\n\n  function killAndDrain() {\n    queueHead = null;\n    queueTail = null;\n    self.drain();\n    self.drain = noop;\n  }\n\n  function error(handler) {\n    errorHandler = handler;\n  }\n}\n\nfunction noop() {}\n\nfunction Task() {\n  this.value = null;\n  this.callback = noop;\n  this.next = null;\n  this.release = noop;\n  this.context = null;\n  this.errorHandler = null;\n  var self = this;\n\n  this.worked = function worked(err, result) {\n    var callback = self.callback;\n    var errorHandler = self.errorHandler;\n    var val = self.value;\n    self.value = null;\n    self.callback = noop;\n\n    if (self.errorHandler) {\n      errorHandler(err, val);\n    }\n\n    callback.call(self.context, err, result);\n    self.release(self);\n  };\n}\n\nmodule.exports = fastqueue;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/fastq/queue.js"],"names":["reusify","require","fastqueue","context","worker","concurrency","cache","Task","queueHead","queueTail","_running","errorHandler","self","push","drain","noop","saturated","pause","paused","running","resume","idle","length","getQueue","unshift","empty","kill","killAndDrain","error","current","counter","next","tasks","value","i","release","done","get","callback","call","worked","holder","handler","err","result","val","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAArB;;AAEA,SAASC,SAAT,CAAoBC,OAApB,EAA6BC,MAA7B,EAAqCC,WAArC,EAAkD;AAChD,MAAI,OAAOF,OAAP,KAAmB,UAAvB,EAAmC;AACjCE,IAAAA,WAAW,GAAGD,MAAd;AACAA,IAAAA,MAAM,GAAGD,OAAT;AACAA,IAAAA,OAAO,GAAG,IAAV;AACD;;AAED,MAAIG,KAAK,GAAGN,OAAO,CAACO,IAAD,CAAnB;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,YAAY,GAAG,IAAnB;AAEA,MAAIC,IAAI,GAAG;AACTC,IAAAA,IAAI,EAAEA,IADG;AAETC,IAAAA,KAAK,EAAEC,IAFE;AAGTC,IAAAA,SAAS,EAAED,IAHF;AAITE,IAAAA,KAAK,EAAEA,KAJE;AAKTC,IAAAA,MAAM,EAAE,KALC;AAMTb,IAAAA,WAAW,EAAEA,WANJ;AAOTc,IAAAA,OAAO,EAAEA,OAPA;AAQTC,IAAAA,MAAM,EAAEA,MARC;AASTC,IAAAA,IAAI,EAAEA,IATG;AAUTC,IAAAA,MAAM,EAAEA,MAVC;AAWTC,IAAAA,QAAQ,EAAEA,QAXD;AAYTC,IAAAA,OAAO,EAAEA,OAZA;AAaTC,IAAAA,KAAK,EAAEV,IAbE;AAcTW,IAAAA,IAAI,EAAEA,IAdG;AAeTC,IAAAA,YAAY,EAAEA,YAfL;AAgBTC,IAAAA,KAAK,EAAEA;AAhBE,GAAX;AAmBA,SAAOhB,IAAP;;AAEA,WAASO,OAAT,GAAoB;AAClB,WAAOT,QAAP;AACD;;AAED,WAASO,KAAT,GAAkB;AAChBL,IAAAA,IAAI,CAACM,MAAL,GAAc,IAAd;AACD;;AAED,WAASI,MAAT,GAAmB;AACjB,QAAIO,OAAO,GAAGrB,SAAd;AACA,QAAIsB,OAAO,GAAG,CAAd;;AAEA,WAAOD,OAAP,EAAgB;AACdA,MAAAA,OAAO,GAAGA,OAAO,CAACE,IAAlB;AACAD,MAAAA,OAAO;AACR;;AAED,WAAOA,OAAP;AACD;;AAED,WAASP,QAAT,GAAqB;AACnB,QAAIM,OAAO,GAAGrB,SAAd;AACA,QAAIwB,KAAK,GAAG,EAAZ;;AAEA,WAAOH,OAAP,EAAgB;AACdG,MAAAA,KAAK,CAACnB,IAAN,CAAWgB,OAAO,CAACI,KAAnB;AACAJ,MAAAA,OAAO,GAAGA,OAAO,CAACE,IAAlB;AACD;;AAED,WAAOC,KAAP;AACD;;AAED,WAASZ,MAAT,GAAmB;AACjB,QAAI,CAACR,IAAI,CAACM,MAAV,EAAkB;AAClBN,IAAAA,IAAI,CAACM,MAAL,GAAc,KAAd;;AACA,SAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,IAAI,CAACP,WAAzB,EAAsC6B,CAAC,EAAvC,EAA2C;AACzCxB,MAAAA,QAAQ;AACRyB,MAAAA,OAAO;AACR;AACF;;AAED,WAASd,IAAT,GAAiB;AACf,WAAOX,QAAQ,KAAK,CAAb,IAAkBE,IAAI,CAACU,MAAL,OAAkB,CAA3C;AACD;;AAED,WAAST,IAAT,CAAeoB,KAAf,EAAsBG,IAAtB,EAA4B;AAC1B,QAAIP,OAAO,GAAGvB,KAAK,CAAC+B,GAAN,EAAd;AAEAR,IAAAA,OAAO,CAAC1B,OAAR,GAAkBA,OAAlB;AACA0B,IAAAA,OAAO,CAACM,OAAR,GAAkBA,OAAlB;AACAN,IAAAA,OAAO,CAACI,KAAR,GAAgBA,KAAhB;AACAJ,IAAAA,OAAO,CAACS,QAAR,GAAmBF,IAAI,IAAIrB,IAA3B;AACAc,IAAAA,OAAO,CAAClB,YAAR,GAAuBA,YAAvB;;AAEA,QAAID,QAAQ,KAAKE,IAAI,CAACP,WAAlB,IAAiCO,IAAI,CAACM,MAA1C,EAAkD;AAChD,UAAIT,SAAJ,EAAe;AACbA,QAAAA,SAAS,CAACsB,IAAV,GAAiBF,OAAjB;AACApB,QAAAA,SAAS,GAAGoB,OAAZ;AACD,OAHD,MAGO;AACLrB,QAAAA,SAAS,GAAGqB,OAAZ;AACApB,QAAAA,SAAS,GAAGoB,OAAZ;AACAjB,QAAAA,IAAI,CAACI,SAAL;AACD;AACF,KATD,MASO;AACLN,MAAAA,QAAQ;AACRN,MAAAA,MAAM,CAACmC,IAAP,CAAYpC,OAAZ,EAAqB0B,OAAO,CAACI,KAA7B,EAAoCJ,OAAO,CAACW,MAA5C;AACD;AACF;;AAED,WAAShB,OAAT,CAAkBS,KAAlB,EAAyBG,IAAzB,EAA+B;AAC7B,QAAIP,OAAO,GAAGvB,KAAK,CAAC+B,GAAN,EAAd;AAEAR,IAAAA,OAAO,CAAC1B,OAAR,GAAkBA,OAAlB;AACA0B,IAAAA,OAAO,CAACM,OAAR,GAAkBA,OAAlB;AACAN,IAAAA,OAAO,CAACI,KAAR,GAAgBA,KAAhB;AACAJ,IAAAA,OAAO,CAACS,QAAR,GAAmBF,IAAI,IAAIrB,IAA3B;;AAEA,QAAIL,QAAQ,KAAKE,IAAI,CAACP,WAAlB,IAAiCO,IAAI,CAACM,MAA1C,EAAkD;AAChD,UAAIV,SAAJ,EAAe;AACbqB,QAAAA,OAAO,CAACE,IAAR,GAAevB,SAAf;AACAA,QAAAA,SAAS,GAAGqB,OAAZ;AACD,OAHD,MAGO;AACLrB,QAAAA,SAAS,GAAGqB,OAAZ;AACApB,QAAAA,SAAS,GAAGoB,OAAZ;AACAjB,QAAAA,IAAI,CAACI,SAAL;AACD;AACF,KATD,MASO;AACLN,MAAAA,QAAQ;AACRN,MAAAA,MAAM,CAACmC,IAAP,CAAYpC,OAAZ,EAAqB0B,OAAO,CAACI,KAA7B,EAAoCJ,OAAO,CAACW,MAA5C;AACD;AACF;;AAED,WAASL,OAAT,CAAkBM,MAAlB,EAA0B;AACxB,QAAIA,MAAJ,EAAY;AACVnC,MAAAA,KAAK,CAAC6B,OAAN,CAAcM,MAAd;AACD;;AACD,QAAIV,IAAI,GAAGvB,SAAX;;AACA,QAAIuB,IAAJ,EAAU;AACR,UAAI,CAACnB,IAAI,CAACM,MAAV,EAAkB;AAChB,YAAIT,SAAS,KAAKD,SAAlB,EAA6B;AAC3BC,UAAAA,SAAS,GAAG,IAAZ;AACD;;AACDD,QAAAA,SAAS,GAAGuB,IAAI,CAACA,IAAjB;AACAA,QAAAA,IAAI,CAACA,IAAL,GAAY,IAAZ;AACA3B,QAAAA,MAAM,CAACmC,IAAP,CAAYpC,OAAZ,EAAqB4B,IAAI,CAACE,KAA1B,EAAiCF,IAAI,CAACS,MAAtC;;AACA,YAAI/B,SAAS,KAAK,IAAlB,EAAwB;AACtBG,UAAAA,IAAI,CAACa,KAAL;AACD;AACF,OAVD,MAUO;AACLf,QAAAA,QAAQ;AACT;AACF,KAdD,MAcO,IAAI,EAAEA,QAAF,KAAe,CAAnB,EAAsB;AAC3BE,MAAAA,IAAI,CAACE,KAAL;AACD;AACF;;AAED,WAASY,IAAT,GAAiB;AACflB,IAAAA,SAAS,GAAG,IAAZ;AACAC,IAAAA,SAAS,GAAG,IAAZ;AACAG,IAAAA,IAAI,CAACE,KAAL,GAAaC,IAAb;AACD;;AAED,WAASY,YAAT,GAAyB;AACvBnB,IAAAA,SAAS,GAAG,IAAZ;AACAC,IAAAA,SAAS,GAAG,IAAZ;AACAG,IAAAA,IAAI,CAACE,KAAL;AACAF,IAAAA,IAAI,CAACE,KAAL,GAAaC,IAAb;AACD;;AAED,WAASa,KAAT,CAAgBc,OAAhB,EAAyB;AACvB/B,IAAAA,YAAY,GAAG+B,OAAf;AACD;AACF;;AAED,SAAS3B,IAAT,GAAiB,CAAE;;AAEnB,SAASR,IAAT,GAAiB;AACf,OAAK0B,KAAL,GAAa,IAAb;AACA,OAAKK,QAAL,GAAgBvB,IAAhB;AACA,OAAKgB,IAAL,GAAY,IAAZ;AACA,OAAKI,OAAL,GAAepB,IAAf;AACA,OAAKZ,OAAL,GAAe,IAAf;AACA,OAAKQ,YAAL,GAAoB,IAApB;AAEA,MAAIC,IAAI,GAAG,IAAX;;AAEA,OAAK4B,MAAL,GAAc,SAASA,MAAT,CAAiBG,GAAjB,EAAsBC,MAAtB,EAA8B;AAC1C,QAAIN,QAAQ,GAAG1B,IAAI,CAAC0B,QAApB;AACA,QAAI3B,YAAY,GAAGC,IAAI,CAACD,YAAxB;AACA,QAAIkC,GAAG,GAAGjC,IAAI,CAACqB,KAAf;AACArB,IAAAA,IAAI,CAACqB,KAAL,GAAa,IAAb;AACArB,IAAAA,IAAI,CAAC0B,QAAL,GAAgBvB,IAAhB;;AACA,QAAIH,IAAI,CAACD,YAAT,EAAuB;AACrBA,MAAAA,YAAY,CAACgC,GAAD,EAAME,GAAN,CAAZ;AACD;;AACDP,IAAAA,QAAQ,CAACC,IAAT,CAAc3B,IAAI,CAACT,OAAnB,EAA4BwC,GAA5B,EAAiCC,MAAjC;AACAhC,IAAAA,IAAI,CAACuB,OAAL,CAAavB,IAAb;AACD,GAXD;AAYD;;AAEDkC,MAAM,CAACC,OAAP,GAAiB7C,SAAjB","sourcesContent":["'use strict'\n\nvar reusify = require('reusify')\n\nfunction fastqueue (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  var cache = reusify(Task)\n  var queueHead = null\n  var queueTail = null\n  var _running = 0\n  var errorHandler = null\n\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  }\n\n  return self\n\n  function running () {\n    return _running\n  }\n\n  function pause () {\n    self.paused = true\n  }\n\n  function length () {\n    var current = queueHead\n    var counter = 0\n\n    while (current) {\n      current = current.next\n      counter++\n    }\n\n    return counter\n  }\n\n  function getQueue () {\n    var current = queueHead\n    var tasks = []\n\n    while (current) {\n      tasks.push(current.value)\n      current = current.next\n    }\n\n    return tasks\n  }\n\n  function resume () {\n    if (!self.paused) return\n    self.paused = false\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++\n      release()\n    }\n  }\n\n  function idle () {\n    return _running === 0 && self.length() === 0\n  }\n\n  function push (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n    current.errorHandler = errorHandler\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current\n        queueTail = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function unshift (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead\n        queueHead = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function release (holder) {\n    if (holder) {\n      cache.release(holder)\n    }\n    var next = queueHead\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null\n        }\n        queueHead = next.next\n        next.next = null\n        worker.call(context, next.value, next.worked)\n        if (queueTail === null) {\n          self.empty()\n        }\n      } else {\n        _running--\n      }\n    } else if (--_running === 0) {\n      self.drain()\n    }\n  }\n\n  function kill () {\n    queueHead = null\n    queueTail = null\n    self.drain = noop\n  }\n\n  function killAndDrain () {\n    queueHead = null\n    queueTail = null\n    self.drain()\n    self.drain = noop\n  }\n\n  function error (handler) {\n    errorHandler = handler\n  }\n}\n\nfunction noop () {}\n\nfunction Task () {\n  this.value = null\n  this.callback = noop\n  this.next = null\n  this.release = noop\n  this.context = null\n  this.errorHandler = null\n\n  var self = this\n\n  this.worked = function worked (err, result) {\n    var callback = self.callback\n    var errorHandler = self.errorHandler\n    var val = self.value\n    self.value = null\n    self.callback = noop\n    if (self.errorHandler) {\n      errorHandler(err, val)\n    }\n    callback.call(self.context, err, result)\n    self.release(self)\n  }\n}\n\nmodule.exports = fastqueue\n"]},"metadata":{},"sourceType":"script"}