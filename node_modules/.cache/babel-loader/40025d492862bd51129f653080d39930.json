{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\n\nconst getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');\n\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\n\nconst isAfterComment = require('../../utils/isAfterComment');\n\nconst isBlocklessAtRuleAfterBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterBlocklessAtRule');\n\nconst isBlocklessAtRuleAfterSameNameBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule');\n\nconst isFirstNested = require('../../utils/isFirstNested');\n\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\n\nconst isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'at-rule-empty-line-before';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected empty line before at-rule',\n  rejected: 'Unexpected empty line before at-rule'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    }, {\n      actual: options,\n      possible: {\n        except: ['after-same-name', 'inside-block', 'blockless-after-same-name-blockless', 'blockless-after-blockless', 'first-nested'],\n        ignore: ['after-comment', 'first-nested', 'inside-block', 'blockless-after-same-name-blockless', 'blockless-after-blockless'],\n        ignoreAtRules: [_.isString]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(atRule => {\n      const isNested = atRule.parent.type !== 'root'; // Ignore the first node\n\n      if (isFirstNodeOfRoot(atRule)) {\n        return;\n      }\n\n      if (!isStandardSyntaxAtRule(atRule)) {\n        return;\n      } // Return early if at-rule is to be ignored\n\n\n      if (optionsMatches(options, 'ignoreAtRules', atRule.name)) {\n        return;\n      } // Optionally ignore the expectation if the node is blockless\n\n\n      if (optionsMatches(options, 'ignore', 'blockless-after-blockless') && isBlocklessAtRuleAfterBlocklessAtRule(atRule)) {\n        return;\n      } // Optionally ignore the node if it is the first nested\n\n\n      if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(atRule)) {\n        return;\n      } // Optionally ignore the expectation if the node is blockless\n      // and following another blockless at-rule with the same name\n\n\n      if (optionsMatches(options, 'ignore', 'blockless-after-same-name-blockless') && isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule)) {\n        return;\n      } // Optionally ignore the expectation if the node is inside a block\n\n\n      if (optionsMatches(options, 'ignore', 'inside-block') && isNested) {\n        return;\n      } // Optionally ignore the expectation if a comment precedes this node\n\n\n      if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(atRule)) {\n        return;\n      }\n\n      const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before);\n      let expectEmptyLineBefore = expectation === 'always'; // Optionally reverse the expectation if any exceptions apply\n\n      if (optionsMatches(options, 'except', 'after-same-name') && isAtRuleAfterSameNameAtRule(atRule) || optionsMatches(options, 'except', 'inside-block') && isNested || optionsMatches(options, 'except', 'first-nested') && isFirstNested(atRule) || optionsMatches(options, 'except', 'blockless-after-blockless') && isBlocklessAtRuleAfterBlocklessAtRule(atRule) || optionsMatches(options, 'except', 'blockless-after-same-name-blockless') && isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule)) {\n        expectEmptyLineBefore = !expectEmptyLineBefore;\n      } // Return if the expectation is met\n\n\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      } // Fix\n\n\n      if (context.fix) {\n        if (expectEmptyLineBefore) {\n          addEmptyLineBefore(atRule, context.newline);\n        } else {\n          removeEmptyLinesBefore(atRule, context.newline);\n        }\n\n        return;\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n      report({\n        message,\n        node: atRule,\n        result,\n        ruleName\n      });\n    });\n  };\n}\n\nfunction isAtRuleAfterSameNameAtRule(atRule) {\n  const previousNode = getPreviousNonSharedLineCommentNode(atRule);\n  return previousNode && previousNode.type === 'atrule' && previousNode.name === atRule.name;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/at-rule-empty-line-before/index.js"],"names":["_","require","addEmptyLineBefore","getPreviousNonSharedLineCommentNode","hasEmptyLine","isAfterComment","isBlocklessAtRuleAfterBlocklessAtRule","isBlocklessAtRuleAfterSameNameBlocklessAtRule","isFirstNested","isFirstNodeOfRoot","isStandardSyntaxAtRule","optionsMatches","removeEmptyLinesBefore","report","ruleMessages","validateOptions","ruleName","messages","expected","rejected","rule","expectation","options","context","root","result","validOptions","actual","possible","except","ignore","ignoreAtRules","isString","optional","walkAtRules","atRule","isNested","parent","type","name","hasEmptyLineBefore","raws","before","expectEmptyLineBefore","isAtRuleAfterSameNameAtRule","fix","newline","message","node","previousNode","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\nconst getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\nconst isAfterComment = require('../../utils/isAfterComment');\nconst isBlocklessAtRuleAfterBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterBlocklessAtRule');\nconst isBlocklessAtRuleAfterSameNameBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule');\nconst isFirstNested = require('../../utils/isFirstNested');\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\nconst isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'at-rule-empty-line-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected empty line before at-rule',\n\trejected: 'Unexpected empty line before at-rule',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['always', 'never'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\texcept: [\n\t\t\t\t\t\t'after-same-name',\n\t\t\t\t\t\t'inside-block',\n\t\t\t\t\t\t'blockless-after-same-name-blockless',\n\t\t\t\t\t\t'blockless-after-blockless',\n\t\t\t\t\t\t'first-nested',\n\t\t\t\t\t],\n\t\t\t\t\tignore: [\n\t\t\t\t\t\t'after-comment',\n\t\t\t\t\t\t'first-nested',\n\t\t\t\t\t\t'inside-block',\n\t\t\t\t\t\t'blockless-after-same-name-blockless',\n\t\t\t\t\t\t'blockless-after-blockless',\n\t\t\t\t\t],\n\t\t\t\t\tignoreAtRules: [_.isString],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkAtRules((atRule) => {\n\t\t\tconst isNested = atRule.parent.type !== 'root';\n\n\t\t\t// Ignore the first node\n\t\t\tif (isFirstNodeOfRoot(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isStandardSyntaxAtRule(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return early if at-rule is to be ignored\n\t\t\tif (optionsMatches(options, 'ignoreAtRules', atRule.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the expectation if the node is blockless\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'ignore', 'blockless-after-blockless') &&\n\t\t\t\tisBlocklessAtRuleAfterBlocklessAtRule(atRule)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if it is the first nested\n\t\t\tif (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the expectation if the node is blockless\n\t\t\t// and following another blockless at-rule with the same name\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'ignore', 'blockless-after-same-name-blockless') &&\n\t\t\t\tisBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the expectation if the node is inside a block\n\t\t\tif (optionsMatches(options, 'ignore', 'inside-block') && isNested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the expectation if a comment precedes this node\n\t\t\tif (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst hasEmptyLineBefore = hasEmptyLine(atRule.raws.before);\n\t\t\tlet expectEmptyLineBefore = expectation === 'always';\n\n\t\t\t// Optionally reverse the expectation if any exceptions apply\n\t\t\tif (\n\t\t\t\t(optionsMatches(options, 'except', 'after-same-name') &&\n\t\t\t\t\tisAtRuleAfterSameNameAtRule(atRule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'inside-block') && isNested) ||\n\t\t\t\t(optionsMatches(options, 'except', 'first-nested') && isFirstNested(atRule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'blockless-after-blockless') &&\n\t\t\t\t\tisBlocklessAtRuleAfterBlocklessAtRule(atRule)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'blockless-after-same-name-blockless') &&\n\t\t\t\t\tisBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))\n\t\t\t) {\n\t\t\t\texpectEmptyLineBefore = !expectEmptyLineBefore;\n\t\t\t}\n\n\t\t\t// Return if the expectation is met\n\t\t\tif (expectEmptyLineBefore === hasEmptyLineBefore) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fix\n\t\t\tif (context.fix) {\n\t\t\t\tif (expectEmptyLineBefore) {\n\t\t\t\t\taddEmptyLineBefore(atRule, context.newline);\n\t\t\t\t} else {\n\t\t\t\t\tremoveEmptyLinesBefore(atRule, context.newline);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n\t\t\treport({ message, node: atRule, result, ruleName });\n\t\t});\n\t};\n}\n\nfunction isAtRuleAfterSameNameAtRule(atRule) {\n\tconst previousNode = getPreviousNonSharedLineCommentNode(atRule);\n\n\treturn previousNode && previousNode.type === 'atrule' && previousNode.name === atRule.name;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}