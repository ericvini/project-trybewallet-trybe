{"ast":null,"code":"'use strict';\n/*\n * merge2\n * https://github.com/teambition/merge2\n *\n * Copyright (c) 2014-2020 Teambition\n * Licensed under the MIT license.\n */\n\nconst Stream = require('stream');\n\nconst PassThrough = Stream.PassThrough;\nconst slice = Array.prototype.slice;\nmodule.exports = merge2;\n\nfunction merge2() {\n  const streamsQueue = [];\n  const args = slice.call(arguments);\n  let merging = false;\n  let options = args[args.length - 1];\n\n  if (options && !Array.isArray(options) && options.pipe == null) {\n    args.pop();\n  } else {\n    options = {};\n  }\n\n  const doEnd = options.end !== false;\n  const doPipeError = options.pipeError === true;\n\n  if (options.objectMode == null) {\n    options.objectMode = true;\n  }\n\n  if (options.highWaterMark == null) {\n    options.highWaterMark = 64 * 1024;\n  }\n\n  const mergedStream = PassThrough(options);\n\n  function addStream() {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options));\n    }\n\n    mergeStream();\n    return this;\n  }\n\n  function mergeStream() {\n    if (merging) {\n      return;\n    }\n\n    merging = true;\n    let streams = streamsQueue.shift();\n\n    if (!streams) {\n      process.nextTick(endStream);\n      return;\n    }\n\n    if (!Array.isArray(streams)) {\n      streams = [streams];\n    }\n\n    let pipesCount = streams.length + 1;\n\n    function next() {\n      if (--pipesCount > 0) {\n        return;\n      }\n\n      merging = false;\n      mergeStream();\n    }\n\n    function pipe(stream) {\n      function onend() {\n        stream.removeListener('merge2UnpipeEnd', onend);\n        stream.removeListener('end', onend);\n\n        if (doPipeError) {\n          stream.removeListener('error', onerror);\n        }\n\n        next();\n      }\n\n      function onerror(err) {\n        mergedStream.emit('error', err);\n      } // skip ended stream\n\n\n      if (stream._readableState.endEmitted) {\n        return next();\n      }\n\n      stream.on('merge2UnpipeEnd', onend);\n      stream.on('end', onend);\n\n      if (doPipeError) {\n        stream.on('error', onerror);\n      }\n\n      stream.pipe(mergedStream, {\n        end: false\n      }); // compatible for old stream\n\n      stream.resume();\n    }\n\n    for (let i = 0; i < streams.length; i++) {\n      pipe(streams[i]);\n    }\n\n    next();\n  }\n\n  function endStream() {\n    merging = false; // emit 'queueDrain' when all streams merged.\n\n    mergedStream.emit('queueDrain');\n\n    if (doEnd) {\n      mergedStream.end();\n    }\n  }\n\n  mergedStream.setMaxListeners(0);\n  mergedStream.add = addStream;\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd');\n  });\n\n  if (args.length) {\n    addStream.apply(null, args);\n  }\n\n  return mergedStream;\n} // check and pause streams for pipe.\n\n\nfunction pauseStreams(streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) {\n      streams = streams.pipe(PassThrough(options));\n    }\n\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.');\n    }\n\n    streams.pause();\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) {\n      streams[i] = pauseStreams(streams[i], options);\n    }\n  }\n\n  return streams;\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/merge2/index.js"],"names":["Stream","require","PassThrough","slice","Array","prototype","module","exports","merge2","streamsQueue","args","call","arguments","merging","options","length","isArray","pipe","pop","doEnd","end","doPipeError","pipeError","objectMode","highWaterMark","mergedStream","addStream","i","len","push","pauseStreams","mergeStream","streams","shift","process","nextTick","endStream","pipesCount","next","stream","onend","removeListener","onerror","err","emit","_readableState","endEmitted","on","resume","setMaxListeners","add","apply","pause","Error"],"mappings":"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","sourcesContent":["'use strict'\n/*\n * merge2\n * https://github.com/teambition/merge2\n *\n * Copyright (c) 2014-2020 Teambition\n * Licensed under the MIT license.\n */\nconst Stream = require('stream')\nconst PassThrough = Stream.PassThrough\nconst slice = Array.prototype.slice\n\nmodule.exports = merge2\n\nfunction merge2 () {\n  const streamsQueue = []\n  const args = slice.call(arguments)\n  let merging = false\n  let options = args[args.length - 1]\n\n  if (options && !Array.isArray(options) && options.pipe == null) {\n    args.pop()\n  } else {\n    options = {}\n  }\n\n  const doEnd = options.end !== false\n  const doPipeError = options.pipeError === true\n  if (options.objectMode == null) {\n    options.objectMode = true\n  }\n  if (options.highWaterMark == null) {\n    options.highWaterMark = 64 * 1024\n  }\n  const mergedStream = PassThrough(options)\n\n  function addStream () {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options))\n    }\n    mergeStream()\n    return this\n  }\n\n  function mergeStream () {\n    if (merging) {\n      return\n    }\n    merging = true\n\n    let streams = streamsQueue.shift()\n    if (!streams) {\n      process.nextTick(endStream)\n      return\n    }\n    if (!Array.isArray(streams)) {\n      streams = [streams]\n    }\n\n    let pipesCount = streams.length + 1\n\n    function next () {\n      if (--pipesCount > 0) {\n        return\n      }\n      merging = false\n      mergeStream()\n    }\n\n    function pipe (stream) {\n      function onend () {\n        stream.removeListener('merge2UnpipeEnd', onend)\n        stream.removeListener('end', onend)\n        if (doPipeError) {\n          stream.removeListener('error', onerror)\n        }\n        next()\n      }\n      function onerror (err) {\n        mergedStream.emit('error', err)\n      }\n      // skip ended stream\n      if (stream._readableState.endEmitted) {\n        return next()\n      }\n\n      stream.on('merge2UnpipeEnd', onend)\n      stream.on('end', onend)\n\n      if (doPipeError) {\n        stream.on('error', onerror)\n      }\n\n      stream.pipe(mergedStream, { end: false })\n      // compatible for old stream\n      stream.resume()\n    }\n\n    for (let i = 0; i < streams.length; i++) {\n      pipe(streams[i])\n    }\n\n    next()\n  }\n\n  function endStream () {\n    merging = false\n    // emit 'queueDrain' when all streams merged.\n    mergedStream.emit('queueDrain')\n    if (doEnd) {\n      mergedStream.end()\n    }\n  }\n\n  mergedStream.setMaxListeners(0)\n  mergedStream.add = addStream\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd')\n  })\n\n  if (args.length) {\n    addStream.apply(null, args)\n  }\n  return mergedStream\n}\n\n// check and pause streams for pipe.\nfunction pauseStreams (streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) {\n      streams = streams.pipe(PassThrough(options))\n    }\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.')\n    }\n    streams.pause()\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) {\n      streams[i] = pauseStreams(streams[i], options)\n    }\n  }\n  return streams\n}\n"]},"metadata":{},"sourceType":"script"}