{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst rangeOperators = ['>=', '<=', '>', '<', '='];\n\nconst styleSearch = require('style-search');\n\nfunction getRangeContextOperators(node) {\n  const operators = [];\n  styleSearch({\n    source: node.value,\n    target: rangeOperators\n  }, match => {\n    const before = node[match.startIndex - 1];\n\n    if (before === '>' || before === '<') {\n      return;\n    }\n\n    operators.push(match.target);\n  }); // Sorting helps when using the operators to split\n  // E.g. for \"(10em < width <= 50em)\" this returns [\"<=\", \"<\"]\n\n  return operators.sort((a, b) => b.length - a.length);\n}\n\nfunction getRangeContextName(parsedNode) {\n  // When the node is like \"(10em < width < 50em)\"\n  // The parsedNode is [\"10em\", \"width\", \"50em\"] - the name is always in the second position\n  if (parsedNode.length === 3) {\n    return parsedNode[1];\n  } // When the node is like \"(width > 10em)\" or \"(10em < width)\"\n  // Regex is needed because the name can either be in the first or second position\n\n\n  return parsedNode.find(value => value.match(/^(?!--)\\D+/) || value.match(/^(--).+/));\n}\n\nmodule.exports = function (node) {\n  const nodeValue = node.value;\n  const operators = getRangeContextOperators(node); // Remove spaces and parentheses and split by the operators\n\n  const parsedMedia = nodeValue.replace(/[()\\s]/g, '').split(new RegExp(operators.join('|')));\n  const name = getRangeContextName(parsedMedia);\n  const nameObj = {\n    value: name,\n    sourceIndex: node.sourceIndex + nodeValue.indexOf(name)\n  };\n  const values = parsedMedia.filter(parsedValue => parsedValue !== name).map(value => {\n    return {\n      value,\n      sourceIndex: node.sourceIndex + nodeValue.indexOf(value)\n    };\n  });\n  return {\n    name: nameObj,\n    values\n  };\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/rangeContextNodeParser.js"],"names":["rangeOperators","styleSearch","require","getRangeContextOperators","node","operators","source","value","target","match","before","startIndex","push","sort","a","b","length","getRangeContextName","parsedNode","find","module","exports","nodeValue","parsedMedia","replace","split","RegExp","join","name","nameObj","sourceIndex","indexOf","values","filter","parsedValue","map"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,cAAc,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,GAAlB,EAAuB,GAAvB,CAAvB;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,cAAD,CAA3B;;AAEA,SAASC,wBAAT,CAAkCC,IAAlC,EAAwC;AACvC,QAAMC,SAAS,GAAG,EAAlB;AAEAJ,EAAAA,WAAW,CAAC;AAAEK,IAAAA,MAAM,EAAEF,IAAI,CAACG,KAAf;AAAsBC,IAAAA,MAAM,EAAER;AAA9B,GAAD,EAAkDS,KAAD,IAAW;AACtE,UAAMC,MAAM,GAAGN,IAAI,CAACK,KAAK,CAACE,UAAN,GAAmB,CAApB,CAAnB;;AAEA,QAAID,MAAM,KAAK,GAAX,IAAkBA,MAAM,KAAK,GAAjC,EAAsC;AACrC;AACA;;AAEDL,IAAAA,SAAS,CAACO,IAAV,CAAeH,KAAK,CAACD,MAArB;AACA,GARU,CAAX,CAHuC,CAavC;AACA;;AACA,SAAOH,SAAS,CAACQ,IAAV,CAAe,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAACC,MAAF,GAAWF,CAAC,CAACE,MAAtC,CAAP;AACA;;AAED,SAASC,mBAAT,CAA6BC,UAA7B,EAAyC;AACxC;AACA;AACA,MAAIA,UAAU,CAACF,MAAX,KAAsB,CAA1B,EAA6B;AAC5B,WAAOE,UAAU,CAAC,CAAD,CAAjB;AACA,GALuC,CAOxC;AACA;;;AACA,SAAOA,UAAU,CAACC,IAAX,CAAiBZ,KAAD,IAAWA,KAAK,CAACE,KAAN,CAAY,YAAZ,KAA6BF,KAAK,CAACE,KAAN,CAAY,SAAZ,CAAxD,CAAP;AACA;;AAEDW,MAAM,CAACC,OAAP,GAAiB,UAAUjB,IAAV,EAAgB;AAChC,QAAMkB,SAAS,GAAGlB,IAAI,CAACG,KAAvB;AAEA,QAAMF,SAAS,GAAGF,wBAAwB,CAACC,IAAD,CAA1C,CAHgC,CAKhC;;AACA,QAAMmB,WAAW,GAAGD,SAAS,CAACE,OAAV,CAAkB,SAAlB,EAA6B,EAA7B,EAAiCC,KAAjC,CAAuC,IAAIC,MAAJ,CAAWrB,SAAS,CAACsB,IAAV,CAAe,GAAf,CAAX,CAAvC,CAApB;AAEA,QAAMC,IAAI,GAAGX,mBAAmB,CAACM,WAAD,CAAhC;AACA,QAAMM,OAAO,GAAG;AACftB,IAAAA,KAAK,EAAEqB,IADQ;AAEfE,IAAAA,WAAW,EAAE1B,IAAI,CAAC0B,WAAL,GAAmBR,SAAS,CAACS,OAAV,CAAkBH,IAAlB;AAFjB,GAAhB;AAKA,QAAMI,MAAM,GAAGT,WAAW,CACxBU,MADa,CACLC,WAAD,IAAiBA,WAAW,KAAKN,IAD3B,EAEbO,GAFa,CAER5B,KAAD,IAAW;AACf,WAAO;AACNA,MAAAA,KADM;AAENuB,MAAAA,WAAW,EAAE1B,IAAI,CAAC0B,WAAL,GAAmBR,SAAS,CAACS,OAAV,CAAkBxB,KAAlB;AAF1B,KAAP;AAIA,GAPa,CAAf;AASA,SAAO;AACNqB,IAAAA,IAAI,EAAEC,OADA;AAENG,IAAAA;AAFM,GAAP;AAIA,CA3BD","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst rangeOperators = ['>=', '<=', '>', '<', '='];\nconst styleSearch = require('style-search');\n\nfunction getRangeContextOperators(node) {\n\tconst operators = [];\n\n\tstyleSearch({ source: node.value, target: rangeOperators }, (match) => {\n\t\tconst before = node[match.startIndex - 1];\n\n\t\tif (before === '>' || before === '<') {\n\t\t\treturn;\n\t\t}\n\n\t\toperators.push(match.target);\n\t});\n\n\t// Sorting helps when using the operators to split\n\t// E.g. for \"(10em < width <= 50em)\" this returns [\"<=\", \"<\"]\n\treturn operators.sort((a, b) => b.length - a.length);\n}\n\nfunction getRangeContextName(parsedNode) {\n\t// When the node is like \"(10em < width < 50em)\"\n\t// The parsedNode is [\"10em\", \"width\", \"50em\"] - the name is always in the second position\n\tif (parsedNode.length === 3) {\n\t\treturn parsedNode[1];\n\t}\n\n\t// When the node is like \"(width > 10em)\" or \"(10em < width)\"\n\t// Regex is needed because the name can either be in the first or second position\n\treturn parsedNode.find((value) => value.match(/^(?!--)\\D+/) || value.match(/^(--).+/));\n}\n\nmodule.exports = function (node) {\n\tconst nodeValue = node.value;\n\n\tconst operators = getRangeContextOperators(node);\n\n\t// Remove spaces and parentheses and split by the operators\n\tconst parsedMedia = nodeValue.replace(/[()\\s]/g, '').split(new RegExp(operators.join('|')));\n\n\tconst name = getRangeContextName(parsedMedia);\n\tconst nameObj = {\n\t\tvalue: name,\n\t\tsourceIndex: node.sourceIndex + nodeValue.indexOf(name),\n\t};\n\n\tconst values = parsedMedia\n\t\t.filter((parsedValue) => parsedValue !== name)\n\t\t.map((value) => {\n\t\t\treturn {\n\t\t\t\tvalue,\n\t\t\t\tsourceIndex: node.sourceIndex + nodeValue.indexOf(value),\n\t\t\t};\n\t\t});\n\n\treturn {\n\t\tname: nameObj,\n\t\tvalues,\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}