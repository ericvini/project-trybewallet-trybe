{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst putIfAbsent = require('./utils/putIfAbsent');\n/** @typedef {import('postcss/lib/comment')} PostcssComment */\n\n/** @typedef {import('stylelint').DisabledRange} DisabledRange */\n\n/** @typedef {import('stylelint').RangeType} RangeType */\n\n/** @typedef {import('stylelint').DisableReportRange} DisableReportRange */\n\n/**\n * @param {import('stylelint').StylelintResult[]} results\n */\n\n\nmodule.exports = function (results) {\n  results.forEach(result => {\n    // File with `CssSyntaxError` have not `_postcssResult`\n    if (!result._postcssResult) {\n      return;\n    }\n    /** @type {{[ruleName: string]: Array<DisabledRange>}} */\n\n\n    const rangeData = _.cloneDeep(result._postcssResult.stylelint.disabledRanges);\n\n    if (!rangeData) {\n      return;\n    }\n\n    const disabledWarnings = result._postcssResult.stylelint.disabledWarnings || []; // A map from `stylelint-disable` comments to the set of rules that\n    // are usefully disabled by each comment. We track this\n    // comment-by-comment rather than range-by-range because ranges that\n    // disable *all* rules are duplicated for each rule they apply to in\n    // practice.\n\n    /** @type {Map<PostcssComment, Set<string>>}} */\n\n    const usefulDisables = new Map();\n\n    for (const warning of disabledWarnings) {\n      const rule = warning.rule;\n      const ruleRanges = rangeData[rule];\n\n      if (ruleRanges) {\n        for (const range of ruleRanges) {\n          if (isWarningInRange(warning, range)) {\n            putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);\n          }\n        }\n      }\n\n      for (const range of rangeData.all) {\n        if (isWarningInRange(warning, range)) {\n          putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);\n        }\n      }\n    }\n\n    const rangeEntries = Object.entries(rangeData); // Get rid of the duplicated ranges for each `all` rule. We only care\n    // if the entire `all` rule is useful as a whole or not.\n\n    for (const range of rangeData.all) {\n      for (const [rule, ranges] of rangeEntries) {\n        if (rule === 'all') continue;\n\n        _.remove(ranges, otherRange => range.comment === otherRange.comment);\n      }\n    }\n\n    for (const [rule, ranges] of rangeEntries) {\n      for (const range of ranges) {\n        const useful = usefulDisables.get(range.comment) || new Set(); // Only emit a warning if this range's comment isn't useful for this rule.\n        // For the special rule \"all\", only emit a warning if it's not useful for\n        // *any* // rules, becuase it covers all of them.\n\n        if (rule === 'all' ? useful.size !== 0 : useful.has(rule)) continue; // If the comment doesn't have a location, we can't report a useful error.\n        // In practice we expect all comments to have locations, though.\n\n        if (!range.comment.source || !range.comment.source.start) continue;\n        result.warnings.push({\n          text: `Needless disable for \"${rule}\"`,\n          rule: '--report-needless-disables',\n          line: range.comment.source.start.line,\n          column: range.comment.source.start.column,\n          severity: 'error'\n        });\n      }\n    }\n  });\n};\n/**\n * @param {import('stylelint').DisabledWarning} warning\n * @param {RangeType} range\n * @return {boolean}\n */\n\n\nfunction isWarningInRange(warning, range) {\n  const line = warning.line; // Need to check if range.end exist, because line number type cannot be compared to undefined\n\n  return range.start <= line && (range.end !== undefined && range.end >= line || range.end === undefined);\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/needlessDisables.js"],"names":["_","require","putIfAbsent","module","exports","results","forEach","result","_postcssResult","rangeData","cloneDeep","stylelint","disabledRanges","disabledWarnings","usefulDisables","Map","warning","rule","ruleRanges","range","isWarningInRange","comment","Set","add","all","rangeEntries","Object","entries","ranges","remove","otherRange","useful","get","size","has","source","start","warnings","push","text","line","column","severity","end","undefined"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst putIfAbsent = require('./utils/putIfAbsent');\n\n/** @typedef {import('postcss/lib/comment')} PostcssComment */\n/** @typedef {import('stylelint').DisabledRange} DisabledRange */\n/** @typedef {import('stylelint').RangeType} RangeType */\n/** @typedef {import('stylelint').DisableReportRange} DisableReportRange */\n\n/**\n * @param {import('stylelint').StylelintResult[]} results\n */\nmodule.exports = function (results) {\n\tresults.forEach((result) => {\n\t\t// File with `CssSyntaxError` have not `_postcssResult`\n\t\tif (!result._postcssResult) {\n\t\t\treturn;\n\t\t}\n\n\t\t/** @type {{[ruleName: string]: Array<DisabledRange>}} */\n\t\tconst rangeData = _.cloneDeep(result._postcssResult.stylelint.disabledRanges);\n\n\t\tif (!rangeData) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst disabledWarnings = result._postcssResult.stylelint.disabledWarnings || [];\n\n\t\t// A map from `stylelint-disable` comments to the set of rules that\n\t\t// are usefully disabled by each comment. We track this\n\t\t// comment-by-comment rather than range-by-range because ranges that\n\t\t// disable *all* rules are duplicated for each rule they apply to in\n\t\t// practice.\n\t\t/** @type {Map<PostcssComment, Set<string>>}} */\n\t\tconst usefulDisables = new Map();\n\n\t\tfor (const warning of disabledWarnings) {\n\t\t\tconst rule = warning.rule;\n\t\t\tconst ruleRanges = rangeData[rule];\n\n\t\t\tif (ruleRanges) {\n\t\t\t\tfor (const range of ruleRanges) {\n\t\t\t\t\tif (isWarningInRange(warning, range)) {\n\t\t\t\t\t\tputIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const range of rangeData.all) {\n\t\t\t\tif (isWarningInRange(warning, range)) {\n\t\t\t\t\tputIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst rangeEntries = Object.entries(rangeData);\n\n\t\t// Get rid of the duplicated ranges for each `all` rule. We only care\n\t\t// if the entire `all` rule is useful as a whole or not.\n\t\tfor (const range of rangeData.all) {\n\t\t\tfor (const [rule, ranges] of rangeEntries) {\n\t\t\t\tif (rule === 'all') continue;\n\n\t\t\t\t_.remove(ranges, (otherRange) => range.comment === otherRange.comment);\n\t\t\t}\n\t\t}\n\n\t\tfor (const [rule, ranges] of rangeEntries) {\n\t\t\tfor (const range of ranges) {\n\t\t\t\tconst useful = usefulDisables.get(range.comment) || new Set();\n\n\t\t\t\t// Only emit a warning if this range's comment isn't useful for this rule.\n\t\t\t\t// For the special rule \"all\", only emit a warning if it's not useful for\n\t\t\t\t// *any* // rules, becuase it covers all of them.\n\t\t\t\tif (rule === 'all' ? useful.size !== 0 : useful.has(rule)) continue;\n\n\t\t\t\t// If the comment doesn't have a location, we can't report a useful error.\n\t\t\t\t// In practice we expect all comments to have locations, though.\n\t\t\t\tif (!range.comment.source || !range.comment.source.start) continue;\n\n\t\t\t\tresult.warnings.push({\n\t\t\t\t\ttext: `Needless disable for \"${rule}\"`,\n\t\t\t\t\trule: '--report-needless-disables',\n\t\t\t\t\tline: range.comment.source.start.line,\n\t\t\t\t\tcolumn: range.comment.source.start.column,\n\t\t\t\t\tseverity: 'error',\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n};\n\n/**\n * @param {import('stylelint').DisabledWarning} warning\n * @param {RangeType} range\n * @return {boolean}\n */\nfunction isWarningInRange(warning, range) {\n\tconst line = warning.line;\n\n\t// Need to check if range.end exist, because line number type cannot be compared to undefined\n\treturn (\n\t\trange.start <= line &&\n\t\t((range.end !== undefined && range.end >= line) || range.end === undefined)\n\t);\n}\n"]},"metadata":{},"sourceType":"script"}