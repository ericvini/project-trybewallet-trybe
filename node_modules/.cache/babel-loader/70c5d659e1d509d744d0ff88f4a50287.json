{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\n\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\n\nconst isAfterComment = require('../../utils/isAfterComment');\n\nconst isFirstNested = require('../../utils/isFirstNested');\n\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\n\nconst isSharedLineComment = require('../../utils/isSharedLineComment');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'comment-empty-line-before';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected empty line before comment',\n  rejected: 'Unexpected empty line before comment'\n});\nconst stylelintCommandPrefix = 'stylelint-';\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    }, {\n      actual: options,\n      possible: {\n        except: ['first-nested'],\n        ignore: ['stylelint-commands', 'after-comment'],\n        ignoreComments: [_.isString, _.isRegExp]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkComments(comment => {\n      // Ignore the first node\n      if (isFirstNodeOfRoot(comment)) {\n        return;\n      } // Optionally ignore stylelint commands\n\n\n      if (comment.text.startsWith(stylelintCommandPrefix) && optionsMatches(options, 'ignore', 'stylelint-commands')) {\n        return;\n      } // Optionally ignore newlines between comments\n\n\n      if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(comment)) {\n        return;\n      } // Ignore comments matching the ignoreComments option.\n\n\n      if (optionsMatches(options, 'ignoreComments', comment.text)) {\n        return;\n      } // Ignore shared-line comments\n\n\n      if (isSharedLineComment(comment)) {\n        return;\n      } // Ignore SCSS comments\n\n\n      if (comment.raws.inline || comment.inline) {\n        return;\n      }\n\n      const expectEmptyLineBefore = (() => {\n        if (optionsMatches(options, 'except', 'first-nested') && isFirstNested(comment)) {\n          return false;\n        }\n\n        return expectation === 'always';\n      })();\n\n      const before = comment.raws.before || '';\n      const hasEmptyLineBefore = hasEmptyLine(before); // Return if the expectation is met\n\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      } // Fix\n\n\n      if (context.fix) {\n        if (expectEmptyLineBefore) {\n          addEmptyLineBefore(comment, context.newline);\n        } else {\n          removeEmptyLinesBefore(comment, context.newline);\n        }\n\n        return;\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n      report({\n        message,\n        node: comment,\n        result,\n        ruleName\n      });\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/comment-empty-line-before/index.js"],"names":["_","require","addEmptyLineBefore","hasEmptyLine","isAfterComment","isFirstNested","isFirstNodeOfRoot","isSharedLineComment","optionsMatches","removeEmptyLinesBefore","report","ruleMessages","validateOptions","ruleName","messages","expected","rejected","stylelintCommandPrefix","rule","expectation","options","context","root","result","validOptions","actual","possible","except","ignore","ignoreComments","isString","isRegExp","optional","walkComments","comment","text","startsWith","raws","inline","expectEmptyLineBefore","before","hasEmptyLineBefore","fix","newline","message","node","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,gCAAD,CAAlC;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,4BAAD,CAA9B;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMK,iBAAiB,GAAGL,OAAO,CAAC,+BAAD,CAAjC;;AACA,MAAMM,mBAAmB,GAAGN,OAAO,CAAC,iCAAD,CAAnC;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,4BAAD,CAA9B;;AACA,MAAMQ,sBAAsB,GAAGR,OAAO,CAAC,oCAAD,CAAtC;;AACA,MAAMS,MAAM,GAAGT,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMU,YAAY,GAAGV,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMW,eAAe,GAAGX,OAAO,CAAC,6BAAD,CAA/B;;AAEA,MAAMY,QAAQ,GAAG,2BAAjB;AAEA,MAAMC,QAAQ,GAAGH,YAAY,CAACE,QAAD,EAAW;AACvCE,EAAAA,QAAQ,EAAE,oCAD6B;AAEvCC,EAAAA,QAAQ,EAAE;AAF6B,CAAX,CAA7B;AAKA,MAAMC,sBAAsB,GAAG,YAA/B;;AAEA,SAASC,IAAT,CAAcC,WAAd,EAA2BC,OAA3B,EAAoCC,OAApC,EAA6C;AAC5C,SAAO,CAACC,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGZ,eAAe,CACnCW,MADmC,EAEnCV,QAFmC,EAGnC;AACCY,MAAAA,MAAM,EAAEN,WADT;AAECO,MAAAA,QAAQ,EAAE,CAAC,QAAD,EAAW,OAAX;AAFX,KAHmC,EAOnC;AACCD,MAAAA,MAAM,EAAEL,OADT;AAECM,MAAAA,QAAQ,EAAE;AACTC,QAAAA,MAAM,EAAE,CAAC,cAAD,CADC;AAETC,QAAAA,MAAM,EAAE,CAAC,oBAAD,EAAuB,eAAvB,CAFC;AAGTC,QAAAA,cAAc,EAAE,CAAC7B,CAAC,CAAC8B,QAAH,EAAa9B,CAAC,CAAC+B,QAAf;AAHP,OAFX;AAOCC,MAAAA,QAAQ,EAAE;AAPX,KAPmC,CAApC;;AAkBA,QAAI,CAACR,YAAL,EAAmB;AAClB;AACA;;AAEDF,IAAAA,IAAI,CAACW,YAAL,CAAmBC,OAAD,IAAa;AAC9B;AACA,UAAI5B,iBAAiB,CAAC4B,OAAD,CAArB,EAAgC;AAC/B;AACA,OAJ6B,CAM9B;;;AACA,UACCA,OAAO,CAACC,IAAR,CAAaC,UAAb,CAAwBnB,sBAAxB,KACAT,cAAc,CAACY,OAAD,EAAU,QAAV,EAAoB,oBAApB,CAFf,EAGE;AACD;AACA,OAZ6B,CAc9B;;;AACA,UAAIZ,cAAc,CAACY,OAAD,EAAU,QAAV,EAAoB,eAApB,CAAd,IAAsDhB,cAAc,CAAC8B,OAAD,CAAxE,EAAmF;AAClF;AACA,OAjB6B,CAmB9B;;;AACA,UAAI1B,cAAc,CAACY,OAAD,EAAU,gBAAV,EAA4Bc,OAAO,CAACC,IAApC,CAAlB,EAA6D;AAC5D;AACA,OAtB6B,CAwB9B;;;AACA,UAAI5B,mBAAmB,CAAC2B,OAAD,CAAvB,EAAkC;AACjC;AACA,OA3B6B,CA6B9B;;;AACA,UAAIA,OAAO,CAACG,IAAR,CAAaC,MAAb,IAAuBJ,OAAO,CAACI,MAAnC,EAA2C;AAC1C;AACA;;AAED,YAAMC,qBAAqB,GAAG,CAAC,MAAM;AACpC,YAAI/B,cAAc,CAACY,OAAD,EAAU,QAAV,EAAoB,cAApB,CAAd,IAAqDf,aAAa,CAAC6B,OAAD,CAAtE,EAAiF;AAChF,iBAAO,KAAP;AACA;;AAED,eAAOf,WAAW,KAAK,QAAvB;AACA,OAN6B,GAA9B;;AAQA,YAAMqB,MAAM,GAAGN,OAAO,CAACG,IAAR,CAAaG,MAAb,IAAuB,EAAtC;AACA,YAAMC,kBAAkB,GAAGtC,YAAY,CAACqC,MAAD,CAAvC,CA3C8B,CA6C9B;;AACA,UAAID,qBAAqB,KAAKE,kBAA9B,EAAkD;AACjD;AACA,OAhD6B,CAkD9B;;;AACA,UAAIpB,OAAO,CAACqB,GAAZ,EAAiB;AAChB,YAAIH,qBAAJ,EAA2B;AAC1BrC,UAAAA,kBAAkB,CAACgC,OAAD,EAAUb,OAAO,CAACsB,OAAlB,CAAlB;AACA,SAFD,MAEO;AACNlC,UAAAA,sBAAsB,CAACyB,OAAD,EAAUb,OAAO,CAACsB,OAAlB,CAAtB;AACA;;AAED;AACA;;AAED,YAAMC,OAAO,GAAGL,qBAAqB,GAAGzB,QAAQ,CAACC,QAAZ,GAAuBD,QAAQ,CAACE,QAArE;AAEAN,MAAAA,MAAM,CAAC;AACNkC,QAAAA,OADM;AAENC,QAAAA,IAAI,EAAEX,OAFA;AAGNX,QAAAA,MAHM;AAINV,QAAAA;AAJM,OAAD,CAAN;AAMA,KArED;AAsEA,GA7FD;AA8FA;;AAEDK,IAAI,CAACL,QAAL,GAAgBA,QAAhB;AACAK,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAgC,MAAM,CAACC,OAAP,GAAiB7B,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\nconst isAfterComment = require('../../utils/isAfterComment');\nconst isFirstNested = require('../../utils/isFirstNested');\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\nconst isSharedLineComment = require('../../utils/isSharedLineComment');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'comment-empty-line-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected empty line before comment',\n\trejected: 'Unexpected empty line before comment',\n});\n\nconst stylelintCommandPrefix = 'stylelint-';\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['always', 'never'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\texcept: ['first-nested'],\n\t\t\t\t\tignore: ['stylelint-commands', 'after-comment'],\n\t\t\t\t\tignoreComments: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkComments((comment) => {\n\t\t\t// Ignore the first node\n\t\t\tif (isFirstNodeOfRoot(comment)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore stylelint commands\n\t\t\tif (\n\t\t\t\tcomment.text.startsWith(stylelintCommandPrefix) &&\n\t\t\t\toptionsMatches(options, 'ignore', 'stylelint-commands')\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore newlines between comments\n\t\t\tif (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(comment)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore comments matching the ignoreComments option.\n\t\t\tif (optionsMatches(options, 'ignoreComments', comment.text)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore shared-line comments\n\t\t\tif (isSharedLineComment(comment)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore SCSS comments\n\t\t\tif (comment.raws.inline || comment.inline) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst expectEmptyLineBefore = (() => {\n\t\t\t\tif (optionsMatches(options, 'except', 'first-nested') && isFirstNested(comment)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn expectation === 'always';\n\t\t\t})();\n\n\t\t\tconst before = comment.raws.before || '';\n\t\t\tconst hasEmptyLineBefore = hasEmptyLine(before);\n\n\t\t\t// Return if the expectation is met\n\t\t\tif (expectEmptyLineBefore === hasEmptyLineBefore) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fix\n\t\t\tif (context.fix) {\n\t\t\t\tif (expectEmptyLineBefore) {\n\t\t\t\t\taddEmptyLineBefore(comment, context.newline);\n\t\t\t\t} else {\n\t\t\t\t\tremoveEmptyLinesBefore(comment, context.newline);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n\t\t\treport({\n\t\t\t\tmessage,\n\t\t\t\tnode: comment,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}