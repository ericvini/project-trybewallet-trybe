{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\n\nconst blockString = require('../../utils/blockString');\n\nconst getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');\n\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\n\nconst isAfterComment = require('../../utils/isAfterComment');\n\nconst isCustomProperty = require('../../utils/isCustomProperty');\n\nconst isFirstNested = require('../../utils/isFirstNested');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'custom-property-empty-line-before';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected empty line before custom property',\n  rejected: 'Unexpected empty line before custom property'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    }, {\n      actual: options,\n      possible: {\n        except: ['first-nested', 'after-comment', 'after-custom-property'],\n        ignore: ['after-comment', 'first-nested', 'inside-single-line-block']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop;\n      const parent = decl.parent;\n\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return;\n      }\n\n      if (!isCustomProperty(prop)) {\n        return;\n      } // Optionally ignore the node if a comment precedes it\n\n\n      if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(decl)) {\n        return;\n      } // Optionally ignore the node if it is the first nested\n\n\n      if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(decl)) {\n        return;\n      } // Optionally ignore nodes inside single-line blocks\n\n\n      if (optionsMatches(options, 'ignore', 'inside-single-line-block') && isSingleLineString(blockString(parent))) {\n        return;\n      }\n\n      let expectEmptyLineBefore = expectation === 'always'; // Optionally reverse the expectation if any exceptions apply\n\n      if (optionsMatches(options, 'except', 'first-nested') && isFirstNested(decl) || optionsMatches(options, 'except', 'after-comment') && isAfterComment(decl) || optionsMatches(options, 'except', 'after-custom-property') && isAfterCustomProperty(decl)) {\n        expectEmptyLineBefore = !expectEmptyLineBefore;\n      }\n\n      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before); // Return if the expectation is met\n\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      } // Fix\n\n\n      if (context.fix) {\n        if (expectEmptyLineBefore) {\n          addEmptyLineBefore(decl, context.newline);\n        } else {\n          removeEmptyLinesBefore(decl, context.newline);\n        }\n\n        return;\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n      report({\n        message,\n        node: decl,\n        result,\n        ruleName\n      });\n    });\n  };\n}\n\nfunction isAfterCustomProperty(decl) {\n  const prevNode = getPreviousNonSharedLineCommentNode(decl);\n  return prevNode && prevNode.prop && isCustomProperty(prevNode.prop);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/custom-property-empty-line-before/index.js"],"names":["addEmptyLineBefore","require","blockString","getPreviousNonSharedLineCommentNode","hasEmptyLine","isAfterComment","isCustomProperty","isFirstNested","isSingleLineString","isStandardSyntaxDeclaration","optionsMatches","removeEmptyLinesBefore","report","ruleMessages","validateOptions","ruleName","messages","expected","rejected","rule","expectation","options","context","root","result","validOptions","actual","possible","except","ignore","optional","walkDecls","decl","prop","parent","expectEmptyLineBefore","isAfterCustomProperty","hasEmptyLineBefore","raws","before","fix","newline","message","node","prevNode","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\nconst blockString = require('../../utils/blockString');\nconst getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\nconst isAfterComment = require('../../utils/isAfterComment');\nconst isCustomProperty = require('../../utils/isCustomProperty');\nconst isFirstNested = require('../../utils/isFirstNested');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'custom-property-empty-line-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected empty line before custom property',\n\trejected: 'Unexpected empty line before custom property',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['always', 'never'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\texcept: ['first-nested', 'after-comment', 'after-custom-property'],\n\t\t\t\t\tignore: ['after-comment', 'first-nested', 'inside-single-line-block'],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst prop = decl.prop;\n\t\t\tconst parent = decl.parent;\n\n\t\t\tif (!isStandardSyntaxDeclaration(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isCustomProperty(prop)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if a comment precedes it\n\t\t\tif (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if it is the first nested\n\t\t\tif (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore nodes inside single-line blocks\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'ignore', 'inside-single-line-block') &&\n\t\t\t\tisSingleLineString(blockString(parent))\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet expectEmptyLineBefore = expectation === 'always';\n\n\t\t\t// Optionally reverse the expectation if any exceptions apply\n\t\t\tif (\n\t\t\t\t(optionsMatches(options, 'except', 'first-nested') && isFirstNested(decl)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'after-comment') && isAfterComment(decl)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'after-custom-property') && isAfterCustomProperty(decl))\n\t\t\t) {\n\t\t\t\texpectEmptyLineBefore = !expectEmptyLineBefore;\n\t\t\t}\n\n\t\t\tconst hasEmptyLineBefore = hasEmptyLine(decl.raws.before);\n\n\t\t\t// Return if the expectation is met\n\t\t\tif (expectEmptyLineBefore === hasEmptyLineBefore) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fix\n\t\t\tif (context.fix) {\n\t\t\t\tif (expectEmptyLineBefore) {\n\t\t\t\t\taddEmptyLineBefore(decl, context.newline);\n\t\t\t\t} else {\n\t\t\t\t\tremoveEmptyLinesBefore(decl, context.newline);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n\t\t\treport({\n\t\t\t\tmessage,\n\t\t\t\tnode: decl,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction isAfterCustomProperty(decl) {\n\tconst prevNode = getPreviousNonSharedLineCommentNode(decl);\n\n\treturn prevNode && prevNode.prop && isCustomProperty(prevNode.prop);\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}