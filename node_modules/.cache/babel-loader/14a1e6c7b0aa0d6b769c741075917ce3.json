{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst beforeBlockString = require('../../utils/beforeBlockString');\n\nconst blurComments = require('../../utils/blurComments');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst isCustomProperty = require('../../utils/isCustomProperty');\n\nconst isLessVariable = require('../../utils/isLessVariable');\n\nconst isMathFunction = require('../../utils/isMathFunction');\n\nconst keywordSets = require('../../reference/keywordSets');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'length-zero-no-unit';\nconst messages = ruleMessages(ruleName, {\n  rejected: 'Unexpected unit'\n});\n\nfunction rule(actual, secondary, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      if (decl.prop.toLowerCase() === 'line-height') {\n        return;\n      }\n\n      const stringValue = blurComments(decl.toString());\n      const ignorableIndexes = new Array(stringValue.length).fill(false);\n      const parsedValue = valueParser(stringValue);\n      parsedValue.walk((node, nodeIndex, nodes) => {\n        if (decl.prop.toLowerCase() === 'font' && node.type === 'div' && node.value === '/') {\n          const lineHeightNode = nodes[nodeIndex + 1];\n          const lineHeightNodeValue = valueParser.stringify(lineHeightNode);\n\n          for (let i = 0; i < lineHeightNodeValue.length; i++) {\n            ignorableIndexes[lineHeightNode.sourceIndex + i] = true;\n          }\n\n          return;\n        }\n\n        if (node.type !== 'function') {\n          return;\n        } // TODO: Issue #4985\n        // eslint-disable-next-line no-shadow\n\n\n        const stringValue = valueParser.stringify(node);\n        const ignoreFlag = isMathFunction(node);\n\n        for (let i = 0; i < stringValue.length; i++) {\n          ignorableIndexes[node.sourceIndex + i] = ignoreFlag;\n        }\n      });\n      check(stringValue, decl, ignorableIndexes);\n    });\n    root.walkAtRules(atRule => {\n      // Ignore Less variables\n      if (isLessVariable(atRule)) {\n        return;\n      }\n\n      const source = hasBlock(atRule) ? beforeBlockString(atRule, {\n        noRawBefore: true\n      }) : atRule.toString();\n      check(source, atRule);\n    });\n\n    function check(value, node, ignorableIndexes = []) {\n      if (optionsMatches(secondary, 'ignore', 'custom-properties') && isCustomProperty(value)) {\n        return;\n      }\n\n      const fixPositions = [];\n      styleSearch({\n        source: value,\n        target: '0'\n      }, match => {\n        const index = match.startIndex; // Given a 0 somewhere in the full property value (not in a string, thanks\n        // to styleSearch) we need to isolate the value that contains the zero.\n        // To do so, we'll find the last index before the 0 of a character that would\n        // divide one value in a list from another, and the next index of such a\n        // character; then we build a substring from those indexes, which we can\n        // assess.\n        // If a single value includes multiple 0's (e.g. 100.01px), we don't want\n        // each 0 to be treated as a separate value, possibly resulting in multiple\n        // warnings for the same value (e.g. 0.00px).\n        //\n        // This check prevents that from happening: we build and check against a\n        // Set containing all the indexes that are part of a value already validated.\n\n        if (ignorableIndexes[index]) {\n          return;\n        }\n\n        const prevValueBreakIndex = _.findLastIndex(value.substr(0, index), char => {\n          return [' ', ',', ')', '(', '#', ':', '\\n', '\\t'].includes(char);\n        }); // Ignore hex colors\n\n\n        if (value[prevValueBreakIndex] === '#') {\n          return;\n        } // If no prev break was found, this value starts at 0\n\n\n        const valueWithZeroStart = prevValueBreakIndex === -1 ? 0 : prevValueBreakIndex + 1;\n\n        const nextValueBreakIndex = _.findIndex(value.substr(valueWithZeroStart), char => {\n          return [' ', ',', ')', '/'].includes(char);\n        }); // If no next break was found, this value ends at the end of the string\n\n\n        const valueWithZeroEnd = nextValueBreakIndex === -1 ? value.length : nextValueBreakIndex + valueWithZeroStart;\n        const valueWithZero = value.slice(valueWithZeroStart, valueWithZeroEnd);\n        const parsedValue = valueParser.unit(valueWithZero);\n\n        if (!parsedValue || parsedValue && !parsedValue.unit) {\n          return;\n        }\n\n        if (parsedValue.unit.toLowerCase() === 'fr') {\n          return;\n        } // Add the indexes to ignorableIndexes so the same value will not\n        // be checked multiple times.\n\n\n        _.range(valueWithZeroStart, valueWithZeroEnd).forEach(i => ignorableIndexes[i] = true); // Only pay attention if the value parses to 0\n        // and units with lengths\n\n\n        if (parseFloat(valueWithZero) !== 0 || !keywordSets.lengthUnits.has(parsedValue.unit.toLowerCase())) {\n          return;\n        }\n\n        if (context.fix) {\n          fixPositions.unshift({\n            startIndex: valueWithZeroStart,\n            length: valueWithZeroEnd - valueWithZeroStart\n          });\n          return;\n        }\n\n        report({\n          message: messages.rejected,\n          node,\n          index: valueWithZeroEnd - parsedValue.unit.length,\n          result,\n          ruleName\n        });\n      });\n\n      if (fixPositions.length) {\n        fixPositions.forEach(fixPosition => {\n          if (node.type === 'atrule') {\n            // Use `-1` for `@` character before each at rule\n            const realIndex = fixPosition.startIndex - node.name.length - node.raws.afterName.length - 1;\n            node.params = replaceZero(node.params, realIndex, fixPosition.length);\n          } else {\n            const realIndex = fixPosition.startIndex - node.prop.length - node.raws.between.length;\n            node.value = replaceZero(node.value, realIndex, fixPosition.length);\n          }\n        });\n      }\n    }\n  };\n}\n\nfunction replaceZero(input, startIndex, length) {\n  const stringStart = input.slice(0, startIndex);\n  const stringEnd = input.slice(startIndex + length);\n  return `${stringStart}0${stringEnd}`;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/length-zero-no-unit/index.js"],"names":["_","require","beforeBlockString","blurComments","hasBlock","isCustomProperty","isLessVariable","isMathFunction","keywordSets","optionsMatches","report","ruleMessages","styleSearch","validateOptions","valueParser","ruleName","messages","rejected","rule","actual","secondary","context","root","result","validOptions","walkDecls","decl","prop","toLowerCase","stringValue","toString","ignorableIndexes","Array","length","fill","parsedValue","walk","node","nodeIndex","nodes","type","value","lineHeightNode","lineHeightNodeValue","stringify","i","sourceIndex","ignoreFlag","check","walkAtRules","atRule","source","noRawBefore","fixPositions","target","match","index","startIndex","prevValueBreakIndex","findLastIndex","substr","char","includes","valueWithZeroStart","nextValueBreakIndex","findIndex","valueWithZeroEnd","valueWithZero","slice","unit","range","forEach","parseFloat","lengthUnits","has","fix","unshift","message","fixPosition","realIndex","name","raws","afterName","params","replaceZero","between","input","stringStart","stringEnd","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst beforeBlockString = require('../../utils/beforeBlockString');\nconst blurComments = require('../../utils/blurComments');\nconst hasBlock = require('../../utils/hasBlock');\nconst isCustomProperty = require('../../utils/isCustomProperty');\nconst isLessVariable = require('../../utils/isLessVariable');\nconst isMathFunction = require('../../utils/isMathFunction');\nconst keywordSets = require('../../reference/keywordSets');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'length-zero-no-unit';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: 'Unexpected unit',\n});\n\nfunction rule(actual, secondary, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, { actual });\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tif (decl.prop.toLowerCase() === 'line-height') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stringValue = blurComments(decl.toString());\n\t\t\tconst ignorableIndexes = new Array(stringValue.length).fill(false);\n\t\t\tconst parsedValue = valueParser(stringValue);\n\n\t\t\tparsedValue.walk((node, nodeIndex, nodes) => {\n\t\t\t\tif (decl.prop.toLowerCase() === 'font' && node.type === 'div' && node.value === '/') {\n\t\t\t\t\tconst lineHeightNode = nodes[nodeIndex + 1];\n\t\t\t\t\tconst lineHeightNodeValue = valueParser.stringify(lineHeightNode);\n\n\t\t\t\t\tfor (let i = 0; i < lineHeightNodeValue.length; i++) {\n\t\t\t\t\t\tignorableIndexes[lineHeightNode.sourceIndex + i] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (node.type !== 'function') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// TODO: Issue #4985\n\t\t\t\t// eslint-disable-next-line no-shadow\n\t\t\t\tconst stringValue = valueParser.stringify(node);\n\t\t\t\tconst ignoreFlag = isMathFunction(node);\n\n\t\t\t\tfor (let i = 0; i < stringValue.length; i++) {\n\t\t\t\t\tignorableIndexes[node.sourceIndex + i] = ignoreFlag;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcheck(stringValue, decl, ignorableIndexes);\n\t\t});\n\n\t\troot.walkAtRules((atRule) => {\n\t\t\t// Ignore Less variables\n\t\t\tif (isLessVariable(atRule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst source = hasBlock(atRule)\n\t\t\t\t? beforeBlockString(atRule, { noRawBefore: true })\n\t\t\t\t: atRule.toString();\n\n\t\t\tcheck(source, atRule);\n\t\t});\n\n\t\tfunction check(value, node, ignorableIndexes = []) {\n\t\t\tif (optionsMatches(secondary, 'ignore', 'custom-properties') && isCustomProperty(value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fixPositions = [];\n\n\t\t\tstyleSearch({ source: value, target: '0' }, (match) => {\n\t\t\t\tconst index = match.startIndex;\n\n\t\t\t\t// Given a 0 somewhere in the full property value (not in a string, thanks\n\t\t\t\t// to styleSearch) we need to isolate the value that contains the zero.\n\t\t\t\t// To do so, we'll find the last index before the 0 of a character that would\n\t\t\t\t// divide one value in a list from another, and the next index of such a\n\t\t\t\t// character; then we build a substring from those indexes, which we can\n\t\t\t\t// assess.\n\n\t\t\t\t// If a single value includes multiple 0's (e.g. 100.01px), we don't want\n\t\t\t\t// each 0 to be treated as a separate value, possibly resulting in multiple\n\t\t\t\t// warnings for the same value (e.g. 0.00px).\n\t\t\t\t//\n\t\t\t\t// This check prevents that from happening: we build and check against a\n\t\t\t\t// Set containing all the indexes that are part of a value already validated.\n\t\t\t\tif (ignorableIndexes[index]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst prevValueBreakIndex = _.findLastIndex(value.substr(0, index), (char) => {\n\t\t\t\t\treturn [' ', ',', ')', '(', '#', ':', '\\n', '\\t'].includes(char);\n\t\t\t\t});\n\n\t\t\t\t// Ignore hex colors\n\t\t\t\tif (value[prevValueBreakIndex] === '#') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If no prev break was found, this value starts at 0\n\t\t\t\tconst valueWithZeroStart = prevValueBreakIndex === -1 ? 0 : prevValueBreakIndex + 1;\n\n\t\t\t\tconst nextValueBreakIndex = _.findIndex(value.substr(valueWithZeroStart), (char) => {\n\t\t\t\t\treturn [' ', ',', ')', '/'].includes(char);\n\t\t\t\t});\n\n\t\t\t\t// If no next break was found, this value ends at the end of the string\n\t\t\t\tconst valueWithZeroEnd =\n\t\t\t\t\tnextValueBreakIndex === -1 ? value.length : nextValueBreakIndex + valueWithZeroStart;\n\n\t\t\t\tconst valueWithZero = value.slice(valueWithZeroStart, valueWithZeroEnd);\n\t\t\t\tconst parsedValue = valueParser.unit(valueWithZero);\n\n\t\t\t\tif (!parsedValue || (parsedValue && !parsedValue.unit)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (parsedValue.unit.toLowerCase() === 'fr') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Add the indexes to ignorableIndexes so the same value will not\n\t\t\t\t// be checked multiple times.\n\t\t\t\t_.range(valueWithZeroStart, valueWithZeroEnd).forEach((i) => (ignorableIndexes[i] = true));\n\n\t\t\t\t// Only pay attention if the value parses to 0\n\t\t\t\t// and units with lengths\n\t\t\t\tif (\n\t\t\t\t\tparseFloat(valueWithZero) !== 0 ||\n\t\t\t\t\t!keywordSets.lengthUnits.has(parsedValue.unit.toLowerCase())\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tfixPositions.unshift({\n\t\t\t\t\t\tstartIndex: valueWithZeroStart,\n\t\t\t\t\t\tlength: valueWithZeroEnd - valueWithZeroStart,\n\t\t\t\t\t});\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.rejected,\n\t\t\t\t\tnode,\n\t\t\t\t\tindex: valueWithZeroEnd - parsedValue.unit.length,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (fixPositions.length) {\n\t\t\t\tfixPositions.forEach((fixPosition) => {\n\t\t\t\t\tif (node.type === 'atrule') {\n\t\t\t\t\t\t// Use `-1` for `@` character before each at rule\n\t\t\t\t\t\tconst realIndex =\n\t\t\t\t\t\t\tfixPosition.startIndex - node.name.length - node.raws.afterName.length - 1;\n\n\t\t\t\t\t\tnode.params = replaceZero(node.params, realIndex, fixPosition.length);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst realIndex = fixPosition.startIndex - node.prop.length - node.raws.between.length;\n\n\t\t\t\t\t\tnode.value = replaceZero(node.value, realIndex, fixPosition.length);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction replaceZero(input, startIndex, length) {\n\tconst stringStart = input.slice(0, startIndex);\n\tconst stringEnd = input.slice(startIndex + length);\n\n\treturn `${stringStart}0${stringEnd}`;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}