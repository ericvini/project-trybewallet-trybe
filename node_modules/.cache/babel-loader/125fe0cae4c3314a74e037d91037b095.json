{"ast":null,"code":"// @ts-nocheck\n\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\nvar parser = function () {\n  // See also:\n  // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n  // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n  // with userland code which might access the derived class in a 'classic' way.\n  function JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n      enumerable: false,\n      writable: false,\n      value: 'JisonParserError'\n    });\n    if (msg == null) msg = '???';\n    Object.defineProperty(this, 'message', {\n      enumerable: false,\n      writable: true,\n      value: msg\n    });\n    this.hash = hash;\n    var stacktrace;\n\n    if (hash && hash.exception instanceof Error) {\n      var ex2 = hash.exception;\n      this.message = ex2.message || msg;\n      stacktrace = ex2.stack;\n    }\n\n    if (!stacktrace) {\n      if (Error.hasOwnProperty('captureStackTrace')) {\n        // V8/Chrome engine\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        stacktrace = new Error(msg).stack;\n      }\n    }\n\n    if (stacktrace) {\n      Object.defineProperty(this, 'stack', {\n        enumerable: false,\n        writable: false,\n        value: stacktrace\n      });\n    }\n  }\n\n  if (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n  } else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n  }\n\n  JisonParserError.prototype.constructor = JisonParserError;\n  JisonParserError.prototype.name = 'JisonParserError'; // helper: reconstruct the productions[] table\n\n  function bp(s) {\n    var rv = [];\n    var p = s.pop;\n    var r = s.rule;\n\n    for (var i = 0, l = p.length; i < l; i++) {\n      rv.push([p[i], r[i]]);\n    }\n\n    return rv;\n  } // helper: reconstruct the defaultActions[] table\n\n\n  function bda(s) {\n    var rv = {};\n    var d = s.idx;\n    var g = s.goto;\n\n    for (var i = 0, l = d.length; i < l; i++) {\n      var j = d[i];\n      rv[j] = g[i];\n    }\n\n    return rv;\n  } // helper: reconstruct the 'goto' table\n\n\n  function bt(s) {\n    var rv = [];\n    var d = s.len;\n    var y = s.symbol;\n    var t = s.type;\n    var a = s.state;\n    var m = s.mode;\n    var g = s.goto;\n\n    for (var i = 0, l = d.length; i < l; i++) {\n      var n = d[i];\n      var q = {};\n\n      for (var j = 0; j < n; j++) {\n        var z = y.shift();\n\n        switch (t.shift()) {\n          case 2:\n            q[z] = [m.shift(), g.shift()];\n            break;\n\n          case 0:\n            q[z] = a.shift();\n            break;\n\n          default:\n            // type === 1: accept\n            q[z] = [3];\n        }\n      }\n\n      rv.push(q);\n    }\n\n    return rv;\n  } // helper: runlength encoding with increment step: code, length: step (default step = 0)\n  // `this` references an array\n\n\n  function s(c, l, a) {\n    a = a || 0;\n\n    for (var i = 0; i < l; i++) {\n      this.push(c);\n      c += a;\n    }\n  } // helper: duplicate sequence from *relative* offset and length.\n  // `this` references an array\n\n\n  function c(i, l) {\n    i = this.length - i;\n\n    for (l += i; i < l; i++) {\n      this.push(this[i]);\n    }\n  } // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n\n\n  function u(a) {\n    var rv = [];\n\n    for (var i = 0, l = a.length; i < l; i++) {\n      var e = a[i]; // Is this entry a helper function?\n\n      if (typeof e === 'function') {\n        i++;\n        e.apply(rv, a[i]);\n      } else {\n        rv.push(e);\n      }\n    }\n\n    return rv;\n  }\n\n  var parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"classic\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... false\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n    trace: function no_op_trace() {},\n    JisonParserError: JisonParserError,\n    yy: {},\n    options: {\n      type: \"lalr\",\n      hasPartialLrUpgradeOnConflict: true,\n      errorRecoveryTokenDiscardCount: 3,\n      caseInsensitive: true\n    },\n    symbols_: {\n      \"$accept\": 0,\n      \"$end\": 1,\n      \"ADD\": 6,\n      \"ANGLE\": 13,\n      \"CALC\": 3,\n      \"DIV\": 9,\n      \"EOF\": 1,\n      \"FREQ\": 15,\n      \"FUNCTION\": 11,\n      \"LENGTH\": 12,\n      \"LPAREN\": 4,\n      \"MUL\": 8,\n      \"NUMBER\": 10,\n      \"PERCENTAGE\": 17,\n      \"RES\": 16,\n      \"RPAREN\": 5,\n      \"SUB\": 7,\n      \"TIME\": 14,\n      \"UNKNOWN\": 18,\n      \"css_value\": 23,\n      \"error\": 2,\n      \"expression\": 19,\n      \"function\": 22,\n      \"math_expression\": 20,\n      \"value\": 21\n    },\n    terminals_: {\n      1: \"EOF\",\n      2: \"error\",\n      3: \"CALC\",\n      4: \"LPAREN\",\n      5: \"RPAREN\",\n      6: \"ADD\",\n      7: \"SUB\",\n      8: \"MUL\",\n      9: \"DIV\",\n      10: \"NUMBER\",\n      11: \"FUNCTION\",\n      12: \"LENGTH\",\n      13: \"ANGLE\",\n      14: \"TIME\",\n      15: \"FREQ\",\n      16: \"RES\",\n      17: \"PERCENTAGE\",\n      18: \"UNKNOWN\"\n    },\n    TERROR: 2,\n    EOF: 1,\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n    __reentrant_call_depth: 0,\n    // INTERNAL USE ONLY\n    __error_infos: [],\n    // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],\n    // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n    // Helper APIs\n    // -----------\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n      return '\"' + id_str + '\"';\n    },\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n      if (this.terminals_[symbol]) {\n        return this.terminals_[symbol];\n      } // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n      //\n      // An example of this may be where a rule's action code contains a call like this:\n      //\n      //      parser.getSymbolName(#$)\n      //\n      // to obtain a human-readable name of the current grammar rule.\n\n\n      var s = this.symbols_;\n\n      for (var key in s) {\n        if (s[key] === symbol) {\n          return key;\n        }\n      }\n\n      return null;\n    },\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n      if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n        return this.terminal_descriptions_[symbol];\n      } else if (symbol === this.EOF) {\n        return 'end of input';\n      }\n\n      var id = this.getSymbolName(symbol);\n\n      if (id) {\n        return this.quoteName(id);\n      }\n\n      return null;\n    },\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n      var TERROR = this.TERROR;\n      var tokenset = [];\n      var check = {}; // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n      // If so, use that one instead of the less palatable token set.\n\n      if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n        return [this.state_descriptions_[state]];\n      }\n\n      for (var p in this.table[state]) {\n        p = +p;\n\n        if (p !== TERROR) {\n          var d = do_not_describe ? p : this.describeSymbol(p);\n\n          if (d && !check[d]) {\n            tokenset.push(d);\n            check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.\n          }\n        }\n      }\n\n      return tokenset;\n    },\n    productions_: bp({\n      pop: u([19, s, [20, 11], 21, 22, s, [23, 7]]),\n      rule: u([2, 4, s, [3, 4], 2, 2, 3, s, [1, 12]])\n    }),\n    performAction: function parser__PerformAction(yyloc, yystate\n    /* action[1] */\n    , yysp, yyvstack, yylstack) {\n      /* this == yyval */\n      // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n      var yy = this.yy;\n      var yyparser = yy.parser;\n      var yylexer = yy.lexer;\n\n      switch (yystate) {\n        case 0:\n          /*! Production::    $accept : expression $end */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n          this.$ = yyvstack[yysp - 1];\n          this._$ = yylstack[yysp - 1]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n\n          break;\n\n        case 1:\n          /*! Production::    expression : math_expression EOF */\n          // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n          this.$ = yyvstack[yysp - 1];\n          this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp); // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n\n          return yyvstack[yysp - 1];\n          break;\n\n        case 2:\n          /*! Production::    math_expression : CALC LPAREN math_expression RPAREN */\n          // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp); // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = yyvstack[yysp - 1];\n          this.$.source.start = {\n            index: yylstack[yysp - 3].range[0]\n          };\n          this.$.source.end = {\n            index: yylstack[yysp].range[1]\n          };\n          break;\n\n        case 3:\n        /*! Production::    math_expression : math_expression ADD math_expression */\n\n        case 4:\n        /*! Production::    math_expression : math_expression SUB math_expression */\n\n        case 5:\n        /*! Production::    math_expression : math_expression MUL math_expression */\n\n        case 6:\n          /*! Production::    math_expression : math_expression DIV math_expression */\n          // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp); // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'MathExpression',\n            operator: yyvstack[yysp - 1],\n            left: yyvstack[yysp - 2],\n            right: yyvstack[yysp],\n            source: {\n              start: yyvstack[yysp - 2].source.start,\n              end: yyvstack[yysp].source.end,\n              operator: {\n                start: {\n                  index: yylstack[yysp - 1].range[0]\n                },\n                end: {\n                  index: yylstack[yysp - 1].range[1]\n                }\n              }\n            }\n          };\n          break;\n\n        case 7:\n          /*! Production::    math_expression : SUB math_expression */\n          // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp); // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n\n          if (yylstack[yysp - 1].range[1] !== yyvstack[yysp].source.start.index) {\n            throw new Error('Unexpected spaces was found between sign and value');\n          }\n\n          if (typeof yyvstack[yysp].value !== 'number') {\n            throw new Error('Unexpected sign');\n          }\n\n          if (yyvstack[yysp].sign) {\n            throw new Error('Unexpected continuous sign');\n          }\n\n          this.$ = yyvstack[yysp];\n          this.$.sign = '-';\n          this.$.value = -yyvstack[yysp].value;\n          this.$.source.start.index = yylstack[yysp - 1].range[0];\n          break;\n\n        case 8:\n          /*! Production::    math_expression : ADD math_expression */\n          // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp); // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n\n          if (yylstack[yysp - 1].range[1] !== yyvstack[yysp].source.start.index) {\n            throw new Error('Unexpected spaces was found between sign and value');\n          }\n\n          if (typeof yyvstack[yysp].value !== 'number') {\n            throw new Error('Unexpected sign');\n          }\n\n          if (yyvstack[yysp].sign) {\n            throw new Error('Unexpected continuous sign');\n          }\n\n          this.$ = yyvstack[yysp];\n          this.$.sign = '+';\n          this.$.source.start.index = yylstack[yysp - 1].range[0];\n          break;\n\n        case 9:\n          /*! Production::    math_expression : LPAREN math_expression RPAREN */\n          // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp); // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = yyvstack[yysp - 1];\n          this.$.source.start = {\n            index: yylstack[yysp - 2].range[0]\n          };\n          this.$.source.end = {\n            index: yylstack[yysp].range[1]\n          };\n          break;\n\n        case 10:\n        /*! Production::    math_expression : function */\n\n        case 11:\n        /*! Production::    math_expression : css_value */\n\n        case 12:\n          /*! Production::    math_expression : value */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = yyvstack[yysp];\n          break;\n\n        case 13:\n          /*! Production::    value : NUMBER */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'Value',\n            value: parseFloat(yyvstack[yysp]),\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 14:\n          /*! Production::    function : FUNCTION */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'Function',\n            value: yyvstack[yysp],\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 15:\n          /*! Production::    css_value : LENGTH */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'LengthValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/i.exec(yyvstack[yysp])[0],\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 16:\n          /*! Production::    css_value : ANGLE */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'AngleValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/i.exec(yyvstack[yysp])[0],\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 17:\n          /*! Production::    css_value : TIME */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'TimeValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/i.exec(yyvstack[yysp])[0],\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 18:\n          /*! Production::    css_value : FREQ */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'FrequencyValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/i.exec(yyvstack[yysp])[0],\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 19:\n          /*! Production::    css_value : RES */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'ResolutionValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/i.exec(yyvstack[yysp])[0],\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 20:\n          /*! Production::    css_value : PERCENTAGE */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'PercentageValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: '%',\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n\n        case 21:\n          /*! Production::    css_value : UNKNOWN */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n          this._$ = yylstack[yysp]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n          this.$ = {\n            type: 'UnknownValue',\n            value: yyvstack[yysp],\n            unit: '',\n            source: {\n              start: {\n                index: yylstack[yysp].range[0]\n              },\n              end: {\n                index: yylstack[yysp].range[1]\n              }\n            }\n          };\n          break;\n      }\n    },\n    table: bt({\n      len: u([18, 1, 5, 1, s, [17, 3], s, [0, 13], s, [17, 5], 0, 0, 5, 6, 6, c, [5, 3], 0, 0]),\n      symbol: u([3, 4, 6, 7, s, [10, 14, 1], 1, 1, s, [6, 4, 1], 4, c, [25, 13], c, [24, 4], c, [17, 119], s, [5, 5, 1], 1, c, [6, 11], c, [5, 5]]),\n      type: u([s, [2, 13], s, [0, 5], 1, s, [2, 19], s, [0, 4], c, [17, 132], s, [2, 9]]),\n      state: u([1, 2, 9, 7, 8, 25, c, [4, 3], 26, c, [4, 3], 27, c, [4, 3], 28, c, [4, 3], 29, c, [4, 3], 30, c, [4, 3], 31, c, [4, 3], 32, c, [4, 3]]),\n      mode: u([s, [1, 128], s, [2, 4], c, [6, 8], s, [1, 5]]),\n      goto: u([3, 6, 5, 4, 18, s, [10, 8, 1], s, [19, 6, 1], c, [19, 13], c, [13, 91], 33, c, [110, 4], s, [3, 4], 22, 23, s, [4, 4], 22, 23, 34, c, [17, 4]])\n    }),\n    defaultActions: bda({\n      idx: u([s, [7, 13, 1], 25, 26, 30, 31, 33, 34]),\n      goto: u([10, 11, 12, s, [14, 8, 1], 13, 1, 7, 8, 5, 6, 9, 2])\n    }),\n    parseError: function parseError(str, hash, ExceptionClass) {\n      if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n          this.trace(str);\n        }\n\n        hash.destroy(); // destroy... well, *almost*!\n      } else {\n        if (typeof this.trace === 'function') {\n          this.trace(str);\n        }\n\n        if (!ExceptionClass) {\n          ExceptionClass = this.JisonParserError;\n        }\n\n        throw new ExceptionClass(str, hash);\n      }\n    },\n    parse: function parse(input) {\n      var self = this;\n      var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)\n\n      var sstack = new Array(128); // state stack: stores states (column storage)\n\n      var vstack = new Array(128); // semantic value stack\n\n      var lstack = new Array(128); // location stack\n\n      var table = this.table;\n      var sp = 0; // 'stack pointer': index into the stacks\n\n      var yyloc;\n      var symbol = 0;\n      var TERROR = this.TERROR;\n      var EOF = this.EOF;\n      var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;\n      var NO_ACTION = [0, 35\n      /* === table.length :: ensures that anyone using this new state will fail dramatically! */\n      ];\n      var lexer;\n\n      if (this.__lexer__) {\n        lexer = this.__lexer__;\n      } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n      }\n\n      var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n\n      };\n      var ASSERT;\n\n      if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n          if (!cond) {\n            throw new Error('assertion failed: ' + (msg || '***'));\n          }\n        };\n      } else {\n        ASSERT = assert;\n      }\n\n      this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n      }; // shallow clone objects, straight copy of simple `src` values\n      // e.g. `lexer.yytext` MAY be a complex value object,\n      // rather than a simple string/value.\n\n\n      function shallow_copy(src) {\n        if (typeof src === 'object') {\n          var dst = {};\n\n          for (var k in src) {\n            if (Object.prototype.hasOwnProperty.call(src, k)) {\n              dst[k] = src[k];\n            }\n          }\n\n          return dst;\n        }\n\n        return src;\n      }\n\n      function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n          if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n            dst[k] = src[k];\n          }\n        }\n      }\n\n      function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n\n        if (rv && rv.range) {\n          rv.range = rv.range.slice(0);\n        }\n\n        return rv;\n      } // copy state\n\n\n      shallow_copy_noclobber(sharedState_yy, this.yy);\n      sharedState_yy.lexer = lexer;\n      sharedState_yy.parser = this; // Does the shared state override the default `parseError` that already comes with this instance?\n\n      if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n          if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n          }\n\n          return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n      } else {\n        this.parseError = this.originalParseError;\n      } // Does the shared state override the default `quoteName` that already comes with this instance?\n\n\n      if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n          return sharedState_yy.quoteName.call(this, id_str);\n        };\n      } else {\n        this.quoteName = this.originalQuoteName;\n      } // set up the cleanup function; make it an API so that external code can re-use this one in case of\n      // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n      // case this parse() API method doesn't come with a `finally { ... }` block any more!\n      //\n      // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n      //       or else your `sharedState`, etc. references will be *wrong*!\n\n\n      this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n          var hash;\n\n          if (sharedState_yy.post_parse || this.post_parse) {\n            // create an error hash info instance: we re-use this API in a **non-error situation**\n            // as this one delivers all parser internals ready for access by userland code.\n            hash = this.constructParseErrorInfo(null\n            /* no error! */\n            , null\n            /* no exception! */\n            , null, false);\n          }\n\n          if (sharedState_yy.post_parse) {\n            rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n            if (typeof rv !== 'undefined') resultValue = rv;\n          }\n\n          if (this.post_parse) {\n            rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n            if (typeof rv !== 'undefined') resultValue = rv;\n          } // cleanup:\n\n\n          if (hash && hash.destroy) {\n            hash.destroy();\n          }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.\n        // clean up the lingering lexer structures as well:\n\n        if (lexer.cleanupAfterLex) {\n          lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        } // prevent lingering circular references from causing memory leaks:\n\n\n        if (sharedState_yy) {\n          sharedState_yy.lexer = undefined;\n          sharedState_yy.parser = undefined;\n\n          if (lexer.yy === sharedState_yy) {\n            lexer.yy = undefined;\n          }\n        }\n\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName; // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n\n        stack.length = 0; // fastest way to nuke an array without overly bothering the GC\n\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0; // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n\n        if (!do_not_nuke_errorinfos) {\n          for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n            var el = this.__error_infos[i];\n\n            if (el && typeof el.destroy === 'function') {\n              el.destroy();\n            }\n          }\n\n          this.__error_infos.length = 0;\n        }\n\n        return resultValue;\n      }; // merge yylloc info into a new yylloc instance.\n      //\n      // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n      //\n      // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n      // case these override the corresponding first/last indexes.\n      //\n      // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n      // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n      // yylloc info.\n      //\n      // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n\n\n      this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv; // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n          if (first_index != null) {\n            for (var i = i1; i <= i2; i++) {\n              l1 = lstack[i];\n\n              if (l1) {\n                break;\n              }\n            }\n          }\n        }\n\n        if (!l2) {\n          if (last_index != null) {\n            for (var i = i2; i >= i1; i--) {\n              l2 = lstack[i];\n\n              if (l2) {\n                break;\n              }\n            }\n          }\n        } // - detect if an epsilon rule is being processed and act accordingly:\n\n\n        if (!l1 && first_index == null) {\n          // epsilon rule span merger. With optional look-ahead in l2.\n          if (!dont_look_back) {\n            for (var i = (i1 || sp) - 1; i >= 0; i--) {\n              l1 = lstack[i];\n\n              if (l1) {\n                break;\n              }\n            }\n          }\n\n          if (!l1) {\n            if (!l2) {\n              // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n              // without look-ahead and no preceding terms and/or `dont_look_back` set:\n              // in that case we ca do nothing but return NULL/UNDEFINED:\n              return undefined;\n            } else {\n              // shallow-copy L2: after all, we MAY be looking\n              // at unconventional yylloc info objects...\n              rv = shallow_copy(l2);\n\n              if (rv.range) {\n                // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                rv.range = rv.range.slice(0);\n              }\n\n              return rv;\n            }\n          } else {\n            // shallow-copy L1, then adjust first col/row 1 column past the end.\n            rv = shallow_copy(l1);\n            rv.first_line = rv.last_line;\n            rv.first_column = rv.last_column;\n\n            if (rv.range) {\n              // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n              rv.range = rv.range.slice(0);\n              rv.range[0] = rv.range[1];\n            }\n\n            if (l2) {\n              // shallow-mixin L2, then adjust last col/row accordingly.\n              shallow_copy_noclobber(rv, l2);\n              rv.last_line = l2.last_line;\n              rv.last_column = l2.last_column;\n\n              if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n              }\n            }\n\n            return rv;\n          }\n        }\n\n        if (!l1) {\n          l1 = l2;\n          l2 = null;\n        }\n\n        if (!l1) {\n          return undefined;\n        } // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n\n\n        rv = shallow_copy(l1); // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n\n        if (rv.range) {\n          // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n          rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n          shallow_copy_noclobber(rv, l2);\n          rv.last_line = l2.last_line;\n          rv.last_column = l2.last_column;\n\n          if (rv.range && l2.range) {\n            rv.range[1] = l2.range[1];\n          }\n        }\n\n        return rv;\n      }; // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n      //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n\n\n      this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n          errStr: msg,\n          exception: ex,\n          text: lexer.match,\n          value: lexer.yytext,\n          token: this.describeSymbol(symbol) || symbol,\n          token_id: symbol,\n          line: lexer.yylineno,\n          loc: copy_yylloc(lexer.yylloc),\n          expected: expected,\n          recoverable: recoverable,\n          state: state,\n          action: action,\n          new_state: newState,\n          symbol_stack: stack,\n          state_stack: sstack,\n          value_stack: vstack,\n          location_stack: lstack,\n          stack_pointer: sp,\n          yy: sharedState_yy,\n          lexer: lexer,\n          parser: this,\n          // and make sure the error info doesn't stay due to potential\n          // ref cycle via userland code manipulations.\n          // These would otherwise all be memory leak opportunities!\n          //\n          // Note that only array and object references are nuked as those\n          // constitute the set of elements which can produce a cyclic ref.\n          // The rest of the members is kept intact as they are harmless.\n          destroy: function destructParseErrorInfo() {\n            // remove cyclic references added to error info:\n            // info.yy = null;\n            // info.lexer = null;\n            // info.value = null;\n            // info.value_stack = null;\n            // ...\n            var rec = !!this.recoverable;\n\n            for (var key in this) {\n              if (this.hasOwnProperty(key) && typeof key === 'object') {\n                this[key] = undefined;\n              }\n            }\n\n            this.recoverable = rec;\n          }\n        }; // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n\n        this.__error_infos.push(pei);\n\n        return pei;\n      };\n\n      function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n\n        if (!tokenName) {\n          tokenName = symbol;\n        }\n\n        return tokenName;\n      }\n\n      function stdLex() {\n        var token = lexer.lex(); // if token isn't its numeric value, convert\n\n        if (typeof token !== 'number') {\n          token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n      }\n\n      function fastLex() {\n        var token = lexer.fastLex(); // if token isn't its numeric value, convert\n\n        if (typeof token !== 'number') {\n          token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n      }\n\n      var lex = stdLex;\n      var state, action, r, t;\n      var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n      };\n      var p;\n      var yyrulelen;\n      var this_production;\n      var newState;\n      var retval = false;\n\n      try {\n        this.__reentrant_call_depth++;\n        lexer.setInput(input, sharedState_yy); // NOTE: we *assume* no lexer pre/post handlers are set up *after*\n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n\n        if (typeof lexer.canIUse === 'function') {\n          var lexerInfo = lexer.canIUse();\n\n          if (lexerInfo.fastLex && typeof fastLex === 'function') {\n            lex = fastLex;\n          }\n        }\n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        if (this.pre_parse) {\n          this.pre_parse.call(this, sharedState_yy);\n        }\n\n        if (sharedState_yy.pre_parse) {\n          sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n\n        for (;;) {\n          // retrieve state number from top of stack\n          state = newState; // sstack[sp - 1];\n          // use default actions if available\n\n          if (this.defaultActions[state]) {\n            action = 2;\n            newState = this.defaultActions[state];\n          } else {\n            // The single `==` condition below covers both these `===` comparisons in a single\n            // operation:\n            //\n            //     if (symbol === null || typeof symbol === 'undefined') ...\n            if (!symbol) {\n              symbol = lex();\n            } // read action for current state and first input\n\n\n            t = table[state] && table[state][symbol] || NO_ACTION;\n            newState = t[1];\n            action = t[0]; // handle parse error\n\n            if (!action) {\n              var errStr;\n              var errSymbolDescr = this.describeSymbol(symbol) || symbol;\n              var expected = this.collect_expected_token_set(state); // Report error\n\n              if (typeof lexer.yylineno === 'number') {\n                errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n              } else {\n                errStr = 'Parse error: ';\n              }\n\n              if (typeof lexer.showPosition === 'function') {\n                errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n              }\n\n              if (expected.length) {\n                errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n              } else {\n                errStr += 'Unexpected ' + errSymbolDescr;\n              } // we cannot recover from the error!\n\n\n              p = this.constructParseErrorInfo(errStr, null, expected, false);\n              r = this.parseError(p.errStr, p, this.JisonParserError);\n\n              if (typeof r !== 'undefined') {\n                retval = r;\n              }\n\n              break;\n            }\n          }\n\n          switch (action) {\n            // catch misc. parse failures:\n            default:\n              // this shouldn't happen, unless resolve defaults are off\n              if (action instanceof Array) {\n                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n\n                if (typeof r !== 'undefined') {\n                  retval = r;\n                }\n\n                break;\n              } // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n              // or a buggy LUT (LookUp Table):\n\n\n              p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n              r = this.parseError(p.errStr, p, this.JisonParserError);\n\n              if (typeof r !== 'undefined') {\n                retval = r;\n              }\n\n              break;\n            // shift:\n\n            case 1:\n              stack[sp] = symbol;\n              vstack[sp] = lexer.yytext;\n              lstack[sp] = copy_yylloc(lexer.yylloc);\n              sstack[sp] = newState; // push state\n\n              ++sp;\n              symbol = 0; // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n              yyloc = lexer.yylloc;\n              continue;\n            // reduce:\n\n            case 2:\n              this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n\n              yyrulelen = this_production[1];\n              r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);\n\n              if (typeof r !== 'undefined') {\n                retval = r;\n                break;\n              } // pop off stack\n\n\n              sp -= yyrulelen; // don't overwrite the `symbol` variable: use a local var to speed things up:\n\n              var ntsymbol = this_production[0]; // push nonterminal (reduce)\n\n              stack[sp] = ntsymbol;\n              vstack[sp] = yyval.$;\n              lstack[sp] = yyval._$; // goto new state = table[STATE][NONTERMINAL]\n\n              newState = table[sstack[sp - 1]][ntsymbol];\n              sstack[sp] = newState;\n              ++sp;\n              continue;\n            // accept:\n\n            case 3:\n              if (sp !== -2) {\n                retval = true; // Return the `$accept` rule's `$$` result, if available.\n                //\n                // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                // default, action):\n                //\n                //     $accept: <startSymbol> $end\n                //                  %{ $$ = $1; @$ = @1; %}\n                //\n                // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                //\n                // In code:\n                //\n                //                  %{\n                //                      @$ = @1;            // if location tracking support is included\n                //                      if (typeof $1 !== 'undefined')\n                //                          return $1;\n                //                      else\n                //                          return true;           // the default parse result if the rule actions don't produce anything\n                //                  %}\n\n                sp--;\n\n                if (typeof vstack[sp] !== 'undefined') {\n                  retval = vstack[sp];\n                }\n              }\n\n              break;\n          } // break out of loop: we accept or fail with error\n\n\n          break;\n        }\n      } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n          throw ex;\n        } else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n          throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n\n        if (typeof r !== 'undefined') {\n          retval = r;\n        }\n      } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n      } // /finally\n\n\n      return retval;\n    }\n  };\n  parser.originalParseError = parser.parseError;\n  parser.originalQuoteName = parser.quoteName;\n  /* lexer generated by jison-lex 0.6.1-215 */\n\n  /*\n   * Returns a Lexer object of the following structure:\n   *\n   *  Lexer: {\n   *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n   *               the real \"shared state\" `yy` passed around to\n   *               the rule actions, etc. is a direct reference!\n   *\n   *               This \"shared context\" object was passed to the lexer by way of\n   *               the `lexer.setInput(str, yy)` API before you may use it.\n   *\n   *               This \"shared context\" object is passed to the lexer action code in `performAction()`\n   *               so userland code in the lexer actions may communicate with the outside world\n   *               and/or other lexer rules' actions in more or less complex ways.\n   *\n   *  }\n   *\n   *  Lexer.prototype: {\n   *    EOF: 1,\n   *    ERROR: 2,\n   *\n   *    yy:        The overall \"shared context\" object reference.\n   *\n   *    JisonLexerError: function(msg, hash),\n   *\n   *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n   *\n   *               The function parameters and `this` have the following value/meaning:\n   *               - `this`    : reference to the `lexer` instance.\n   *                               `yy_` is an alias for `this` lexer instance reference used internally.\n   *\n   *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\n   *                             by way of the `lexer.setInput(str, yy)` API before.\n   *\n   *                             Note:\n   *                             The extra arguments you specified in the `%parse-param` statement in your\n   *                             **parser** grammar definition file are passed to the lexer via this object\n   *                             reference as member variables.\n   *\n   *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\n   *\n   *               - `YY_START`: the current lexer \"start condition\" state.\n   *\n   *    parseError: function(str, hash, ExceptionClass),\n   *\n   *    constructLexErrorInfo: function(error_message, is_recoverable),\n   *               Helper function.\n   *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n   *               See it's use in this lexer kernel in many places; example usage:\n   *\n   *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\n   *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n   *\n   *    options: { ... lexer %options ... },\n   *\n   *    lex: function(),\n   *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\n   *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\n   *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n   *\n   *               WARNING:\n   *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\n   *               any attributes already added to `yy` by the **parser** or the jison run-time;\n   *               when such a collision is detected an exception is thrown to prevent the generated run-time\n   *               from silently accepting this confusing and potentially hazardous situation!\n   *\n   *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n   *               Helper function.\n   *\n   *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n   *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired.\n   *\n   *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n   *\n   *    setInput: function(input, [yy]),\n   *\n   *\n   *    input: function(),\n   *\n   *\n   *    unput: function(str),\n   *\n   *\n   *    more: function(),\n   *\n   *\n   *    reject: function(),\n   *\n   *\n   *    less: function(n),\n   *\n   *\n   *    pastInput: function(n),\n   *\n   *\n   *    upcomingInput: function(n),\n   *\n   *\n   *    showPosition: function(),\n   *\n   *\n   *    test_match: function(regex_match_array, rule_index),\n   *\n   *\n   *    next: function(),\n   *\n   *\n   *    begin: function(condition),\n   *\n   *\n   *    pushState: function(condition),\n   *\n   *\n   *    popState: function(),\n   *\n   *\n   *    topState: function(),\n   *\n   *\n   *    _currentRules: function(),\n   *\n   *\n   *    stateStackSize: function(),\n   *\n   *\n   *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n   *\n   *\n   *    rules: [...],\n   *\n   *\n   *    conditions: {associative list: name ==> set},\n   *  }\n   *\n   *\n   *  token location info (`yylloc`): {\n   *    first_line: n,\n   *    last_line: n,\n   *    first_column: n,\n   *    last_column: n,\n   *    range: [start_number, end_number]\n   *               (where the numbers are indexes into the input string, zero-based)\n   *  }\n   *\n   * ---\n   *\n   * The `parseError` function receives a 'hash' object with these members for lexer errors:\n   *\n   *  {\n   *    text:        (matched text)\n   *    token:       (the produced terminal token, if any)\n   *    token_id:    (the produced terminal token numeric ID, if any)\n   *    line:        (yylineno)\n   *    loc:         (yylloc)\n   *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n   *                  available for this particular error)\n   *    yy:          (object: the current parser internal \"shared state\" `yy`\n   *                  as is also available in the rule actions; this can be used,\n   *                  for instance, for advanced error analysis and reporting)\n   *    lexer:       (reference to the current lexer instance used by the parser)\n   *  }\n   *\n   * while `this` will reference the current lexer instance.\n   *\n   * When `parseError` is invoked by the lexer, the default implementation will\n   * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\n   * it will try to invoke `yy.parseError()` instead. When that callback is also not\n   * provided, a `JisonLexerError` exception will be thrown containing the error\n   * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\n   *\n   * Note that the lexer's `JisonLexerError` error class is passed via the\n   * `ExceptionClass` argument, which is invoked to construct the exception\n   * instance to be thrown, so technically `parseError` will throw the object\n   * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\n   *\n   * ---\n   *\n   * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\n   * These options are available:\n   *\n   * (Options are permanent.)\n   *\n   *  yy: {\n   *      parseError: function(str, hash, ExceptionClass)\n   *                 optional: overrides the default `parseError` function.\n   *  }\n   *\n   *  lexer.options: {\n   *      pre_lex:  function()\n   *                 optional: is invoked before the lexer is invoked to produce another token.\n   *                 `this` refers to the Lexer object.\n   *      post_lex: function(token) { return token; }\n   *                 optional: is invoked when the lexer has produced a token `token`;\n   *                 this function can override the returned token value by returning another.\n   *                 When it does not return any (truthy) value, the lexer will return\n   *                 the original `token`.\n   *                 `this` refers to the Lexer object.\n   *\n   * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n   * the lexer as per when it was compiled!\n   *\n   *      ranges: boolean\n   *                 optional: `true` ==> token location info will include a .range[] member.\n   *      flex: boolean\n   *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n   *                 exhaustively to find the longest match.\n   *      backtrack_lexer: boolean\n   *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n   *                 the lexer terminates the scan when a token is returned by the action code.\n   *      xregexp: boolean\n   *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n   *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\n   *                 rule regexes have been written as standard JavaScript RegExp expressions.\n   *  }\n   */\n\n  var lexer = function () {\n    /**\n     * See also:\n     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n     * with userland code which might access the derived class in a 'classic' way.\n     *\n     * @public\n     * @constructor\n     * @nocollapse\n     */\n    function JisonLexerError(msg, hash) {\n      Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonLexerError'\n      });\n      if (msg == null) msg = '???';\n      Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n      });\n      this.hash = hash;\n      var stacktrace;\n\n      if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n      }\n\n      if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {\n          // V8\n          Error.captureStackTrace(this, this.constructor);\n        } else {\n          stacktrace = new Error(msg).stack;\n        }\n      }\n\n      if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n          enumerable: false,\n          writable: false,\n          value: stacktrace\n        });\n      }\n    }\n\n    if (typeof Object.setPrototypeOf === 'function') {\n      Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n    } else {\n      JisonLexerError.prototype = Object.create(Error.prototype);\n    }\n\n    JisonLexerError.prototype.constructor = JisonLexerError;\n    JisonLexerError.prototype.name = 'JisonLexerError';\n    var lexer = {\n      // Code Generator Information Report\n      // ---------------------------------\n      //\n      // Options:\n      //\n      //   backtracking: .................... false\n      //   location.ranges: ................. false\n      //   location line+column tracking: ... true\n      //\n      //\n      // Forwarded Parser Analysis flags:\n      //\n      //   uses yyleng: ..................... false\n      //   uses yylineno: ................... false\n      //   uses yytext: ..................... false\n      //   uses yylloc: ..................... false\n      //   uses lexer values: ............... true / true\n      //   location tracking: ............... true\n      //   location assignment: ............. true\n      //\n      //\n      // Lexer Analysis flags:\n      //\n      //   uses yyleng: ..................... ???\n      //   uses yylineno: ................... ???\n      //   uses yytext: ..................... ???\n      //   uses yylloc: ..................... ???\n      //   uses ParseError API: ............. ???\n      //   uses yyerror: .................... ???\n      //   uses location tracking & editing:  ???\n      //   uses more() API: ................. ???\n      //   uses unput() API: ................ ???\n      //   uses reject() API: ............... ???\n      //   uses less() API: ................. ???\n      //   uses display APIs pastInput(), upcomingInput(), showPosition():\n      //        ............................. ???\n      //   uses describeYYLLOC() API: ....... ???\n      //\n      // --------- END OF REPORT -----------\n      EOF: 1,\n      ERROR: 2,\n      // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n      // options: {},                             /// <-- injected by the code generator\n      // yy: ...,                                 /// <-- injected by setInput()\n      __currentRuleSet__: null,\n      /// INTERNAL USE ONLY: internal rule set cache for the current lexer state\n      __error_infos: [],\n      /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup\n      __decompressed: false,\n      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use\n      done: false,\n      /// INTERNAL USE ONLY\n      _backtrack: false,\n      /// INTERNAL USE ONLY\n      _input: '',\n      /// INTERNAL USE ONLY\n      _more: false,\n      /// INTERNAL USE ONLY\n      _signaled_error_token: false,\n      /// INTERNAL USE ONLY\n      conditionStack: [],\n      /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`\n      match: '',\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!\n      matched: '',\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far\n      matches: false,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt\n      yytext: '',\n      /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.\n      offset: 0,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far\n      yyleng: 0,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)\n      yylineno: 0,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located\n      yylloc: null,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction\n\n      /**\n       * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n        msg = '' + msg; // heuristic to determine if the error message already contains a (partial) source code dump\n        // as produced by either `showPosition()` or `prettyPrintRange()`:\n\n        if (show_input_position == undefined) {\n          show_input_position = !(msg.indexOf('\\n') > 0 && msg.indexOf('^') > 0);\n        }\n\n        if (this.yylloc && show_input_position) {\n          if (typeof this.prettyPrintRange === 'function') {\n            var pretty_src = this.prettyPrintRange(this.yylloc);\n\n            if (!/\\n\\s*$/.test(msg)) {\n              msg += '\\n';\n            }\n\n            msg += '\\n  Erroneous area:\\n' + this.prettyPrintRange(this.yylloc);\n          } else if (typeof this.showPosition === 'function') {\n            var pos_str = this.showPosition();\n\n            if (pos_str) {\n              if (msg.length && msg[msg.length - 1] !== '\\n' && pos_str[0] !== '\\n') {\n                msg += '\\n' + pos_str;\n              } else {\n                msg += pos_str;\n              }\n            }\n          }\n        }\n        /** @constructor */\n\n\n        var pei = {\n          errStr: msg,\n          recoverable: !!recoverable,\n          text: this.match,\n          // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...\n          token: null,\n          line: this.yylineno,\n          loc: this.yylloc,\n          yy: this.yy,\n          lexer: this,\n\n          /**\n           * and make sure the error info doesn't stay due to potential\n           * ref cycle via userland code manipulations.\n           * These would otherwise all be memory leak opportunities!\n           *\n           * Note that only array and object references are nuked as those\n           * constitute the set of elements which can produce a cyclic ref.\n           * The rest of the members is kept intact as they are harmless.\n           *\n           * @public\n           * @this {LexErrorInfo}\n           */\n          destroy: function destructLexErrorInfo() {\n            // remove cyclic references added to error info:\n            // info.yy = null;\n            // info.lexer = null;\n            // ...\n            var rec = !!this.recoverable;\n\n            for (var key in this) {\n              if (this.hasOwnProperty(key) && typeof key === 'object') {\n                this[key] = undefined;\n              }\n            }\n\n            this.recoverable = rec;\n          }\n        }; // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n\n        this.__error_infos.push(pei);\n\n        return pei;\n      },\n\n      /**\n       * handler which is invoked when a lexer error occurs.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      parseError: function lexer_parseError(str, hash, ExceptionClass) {\n        if (!ExceptionClass) {\n          ExceptionClass = this.JisonLexerError;\n        }\n\n        if (this.yy) {\n          if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {\n            return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n          } else if (typeof this.yy.parseError === 'function') {\n            return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n          }\n        }\n\n        throw new ExceptionClass(str, hash);\n      },\n\n      /**\n       * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      yyerror: function yyError(str\n      /*, ...args */\n      ) {\n        var lineno_msg = '';\n\n        if (this.yylloc) {\n          lineno_msg = ' on line ' + (this.yylineno + 1);\n        }\n\n        var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': ' + str, this.options.lexerErrorsAreRecoverable); // Add any extra args to the hash under the name `extra_error_attributes`:\n\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        if (args.length) {\n          p.extra_error_attributes = args;\n        }\n\n        return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n      },\n\n      /**\n       * final cleanup function for when we have completed lexing the input;\n       * make it an API so that external code can use this one once userland\n       * code has decided it's time to destroy any lingering lexer error\n       * hash object instances and the like: this function helps to clean\n       * up these constructs, which *may* carry cyclic references which would\n       * otherwise prevent the instances from being properly and timely\n       * garbage-collected, i.e. this function helps prevent memory leaks!\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n        // prevent lingering circular references from causing memory leaks:\n        this.setInput('', {}); // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n\n        if (!do_not_nuke_errorinfos) {\n          for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n            var el = this.__error_infos[i];\n\n            if (el && typeof el.destroy === 'function') {\n              el.destroy();\n            }\n          }\n\n          this.__error_infos.length = 0;\n        }\n\n        return this;\n      },\n\n      /**\n       * clear the lexer token context; intended for internal use only\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      clear: function lexer_clear() {\n        this.yytext = '';\n        this.yyleng = 0;\n        this.match = ''; // - DO NOT reset `this.matched`\n\n        this.matches = false;\n        this._more = false;\n        this._backtrack = false;\n        var col = this.yylloc ? this.yylloc.last_column : 0;\n        this.yylloc = {\n          first_line: this.yylineno + 1,\n          first_column: col,\n          last_line: this.yylineno + 1,\n          last_column: col,\n          range: [this.offset, this.offset]\n        };\n      },\n\n      /**\n       * resets the lexer, sets new input\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      setInput: function lexer_setInput(input, yy) {\n        this.yy = yy || this.yy || {}; // also check if we've fully initialized the lexer instance,\n        // including expansion work to be done to go from a loaded\n        // lexer to a usable lexer:\n\n        if (!this.__decompressed) {\n          // step 1: decompress the regex list:\n          var rules = this.rules;\n\n          for (var i = 0, len = rules.length; i < len; i++) {\n            var rule_re = rules[i]; // compression: is the RE an xref to another RE slot in the rules[] table?\n\n            if (typeof rule_re === 'number') {\n              rules[i] = rules[rule_re];\n            }\n          } // step 2: unfold the conditions[] set to make these ready for use:\n\n\n          var conditions = this.conditions;\n\n          for (var k in conditions) {\n            var spec = conditions[k];\n            var rule_ids = spec.rules;\n            var len = rule_ids.length;\n            var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!\n\n            var rule_new_ids = new Array(len + 1);\n\n            for (var i = 0; i < len; i++) {\n              var idx = rule_ids[i];\n              var rule_re = rules[idx];\n              rule_regexes[i + 1] = rule_re;\n              rule_new_ids[i + 1] = idx;\n            }\n\n            spec.rules = rule_new_ids;\n            spec.__rule_regexes = rule_regexes;\n            spec.__rule_count = len;\n          }\n\n          this.__decompressed = true;\n        }\n\n        this._input = input || '';\n        this.clear();\n        this._signaled_error_token = false;\n        this.done = false;\n        this.yylineno = 0;\n        this.matched = '';\n        this.conditionStack = ['INITIAL'];\n        this.__currentRuleSet__ = null;\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0,\n          range: [0, 0]\n        };\n        this.offset = 0;\n        return this;\n      },\n\n      /**\n       * edit the remaining input via user-specified callback.\n       * This can be used to forward-adjust the input-to-parse,\n       * e.g. inserting macro expansions and alike in the\n       * input which has yet to be lexed.\n       * The behaviour of this API contrasts the `unput()` et al\n       * APIs as those act on the *consumed* input, while this\n       * one allows one to manipulate the future, without impacting\n       * the current `yyloc` cursor location or any history.\n       *\n       * Use this API to help implement C-preprocessor-like\n       * `#include` statements, etc.\n       *\n       * The provided callback must be synchronous and is\n       * expected to return the edited input (string).\n       *\n       * The `cpsArg` argument value is passed to the callback\n       * as-is.\n       *\n       * `callback` interface:\n       * `function callback(input, cpsArg)`\n       *\n       * - `input` will carry the remaining-input-to-lex string\n       *   from the lexer.\n       * - `cpsArg` is `cpsArg` passed into this API.\n       *\n       * The `this` reference for the callback will be set to\n       * reference this lexer instance so that userland code\n       * in the callback can easily and quickly access any lexer\n       * API.\n       *\n       * When the callback returns a non-string-type falsey value,\n       * we assume the callback did not edit the input and we\n       * will using the input as-is.\n       *\n       * When the callback returns a non-string-type value, it\n       * is converted to a string for lexing via the `\"\" + retval`\n       * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html\n       * -- that way any returned object's `toValue()` and `toString()`\n       * methods will be invoked in a proper/desirable order.)\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n        var rv = callback.call(this, this._input, cpsArg);\n\n        if (typeof rv !== 'string') {\n          if (rv) {\n            this._input = '' + rv;\n          } // else: keep `this._input` as is.\n\n        } else {\n          this._input = rv;\n        }\n\n        return this;\n      },\n\n      /**\n       * consumes and returns one char from the input\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      input: function lexer_input() {\n        if (!this._input) {\n          //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n          return null;\n        }\n\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch; // Count the linenumber up when we hit the LF (or a stand-alone CR).\n        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n        // and we advance immediately past the LF as well, returning both together as if\n        // it was all a single 'character' only.\n\n        var slice_len = 1;\n        var lines = false;\n\n        if (ch === '\\n') {\n          lines = true;\n        } else if (ch === '\\r') {\n          lines = true;\n          var ch2 = this._input[1];\n\n          if (ch2 === '\\n') {\n            slice_len++;\n            ch += ch2;\n            this.yytext += ch2;\n            this.yyleng++;\n            this.offset++;\n            this.match += ch2;\n            this.matched += ch2;\n            this.yylloc.range[1]++;\n          }\n        }\n\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n        } else {\n          this.yylloc.last_column++;\n        }\n\n        this.yylloc.range[1]++;\n        this._input = this._input.slice(slice_len);\n        return ch;\n      },\n\n      /**\n       * unshifts one char (or an entire string) into the input\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      unput: function lexer_unput(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.yyleng = this.yytext.length;\n        this.offset -= len;\n        this.match = this.match.substr(0, this.match.length - len);\n        this.matched = this.matched.substr(0, this.matched.length - len);\n\n        if (lines.length > 1) {\n          this.yylineno -= lines.length - 1;\n          this.yylloc.last_line = this.yylineno + 1; // Get last entirely matched line into the `pre_lines[]` array's\n          // last index slot; we don't mind when other previously\n          // matched lines end up in the array too.\n\n          var pre = this.match;\n          var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n\n          if (pre_lines.length === 1) {\n            pre = this.matched;\n            pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n          }\n\n          this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n        } else {\n          this.yylloc.last_column -= len;\n        }\n\n        this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n        this.done = false;\n        return this;\n      },\n\n      /**\n       * cache matched text and append it on next action\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      more: function lexer_more() {\n        this._more = true;\n        return this;\n      },\n\n      /**\n       * signal the lexer that this rule fails to match the input, so the\n       * next matching rule (regex) should be tested instead.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      reject: function lexer_reject() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          // when the `parseError()` call returns, we MUST ensure that the error is registered.\n          // We accomplish this by signaling an 'error' token to be produced for the current\n          // `.lex()` run.\n          var lineno_msg = '';\n\n          if (this.yylloc) {\n            lineno_msg = ' on line ' + (this.yylineno + 1);\n          }\n\n          var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).', false);\n          this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n        }\n\n        return this;\n      },\n\n      /**\n       * retain first n characters of the match\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      less: function lexer_less(n) {\n        return this.unput(this.match.slice(n));\n      },\n\n      /**\n       * return (part of the) already matched input, i.e. for error\n       * messages.\n       *\n       * Limit the returned string length to `maxSize` (default: 20).\n       *\n       * Limit the returned string to the `maxLines` number of lines of\n       * input (default: 1).\n       *\n       * Negative limit values equal *unlimited*.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      pastInput: function lexer_pastInput(maxSize, maxLines) {\n        var past = this.matched.substring(0, this.matched.length - this.match.length);\n        if (maxSize < 0) maxSize = past.length;else if (!maxSize) maxSize = 20;\n        if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this!\n        else if (!maxLines) maxLines = 1; // `substr` anticipation: treat \\r\\n as a single character and take a little\n        // more than necessary so that we can still properly check against maxSize\n        // after we've transformed and limited the newLines in here:\n\n        past = past.substr(-maxSize * 2 - 2); // now that we have a significantly reduced string to process, transform the newlines\n        // and chop them, then limit them:\n\n        var a = past.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n        a = a.slice(-maxLines);\n        past = a.join('\\n'); // When, after limiting to maxLines, we still have too much to return,\n        // do add an ellipsis prefix...\n\n        if (past.length > maxSize) {\n          past = '...' + past.substr(-maxSize);\n        }\n\n        return past;\n      },\n\n      /**\n       * return (part of the) upcoming input, i.e. for error messages.\n       *\n       * Limit the returned string length to `maxSize` (default: 20).\n       *\n       * Limit the returned string to the `maxLines` number of lines of input (default: 1).\n       *\n       * Negative limit values equal *unlimited*.\n       *\n       * > ### NOTE ###\n       * >\n       * > *\"upcoming input\"* is defined as the whole of the both\n       * > the *currently lexed* input, together with any remaining input\n       * > following that. *\"currently lexed\"* input is the input\n       * > already recognized by the lexer but not yet returned with\n       * > the lexer token. This happens when you are invoking this API\n       * > from inside any lexer rule action code block.\n       * >\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n        var next = this.match;\n        if (maxSize < 0) maxSize = next.length + this._input.length;else if (!maxSize) maxSize = 20;\n        if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this!\n        else if (!maxLines) maxLines = 1; // `substring` anticipation: treat \\r\\n as a single character and take a little\n        // more than necessary so that we can still properly check against maxSize\n        // after we've transformed and limited the newLines in here:\n\n        if (next.length < maxSize * 2 + 2) {\n          next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8\n        } // now that we have a significantly reduced string to process, transform the newlines\n        // and chop them, then limit them:\n\n\n        var a = next.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n        a = a.slice(0, maxLines);\n        next = a.join('\\n'); // When, after limiting to maxLines, we still have too much to return,\n        // do add an ellipsis postfix...\n\n        if (next.length > maxSize) {\n          next = next.substring(0, maxSize) + '...';\n        }\n\n        return next;\n      },\n\n      /**\n       * return a string which displays the character position where the\n       * lexing error occurred, i.e. for error messages\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n        var pre = this.pastInput(maxPrefix).replace(/\\s/g, ' ');\n        var c = new Array(pre.length + 1).join('-');\n        return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, ' ') + '\\n' + c + '^';\n      },\n\n      /**\n       * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\n       * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\n       * it MAY be NULL) and you MUST have a valid location info object anyway:\n       * then we take the given context of the `preceding` and `following` locations, IFF those are available,\n       * and reconstruct the `actual` location info from those.\n       * If this fails, the heuristic is to take the `current` location, IFF available.\n       * If this fails as well, we assume the sought location is at/around the current lexer position\n       * and then produce that one as a response. DO NOTE that these heuristic/derived location info\n       * values MAY be inaccurate!\n       *\n       * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\n       * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n        var loc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0,\n          range: [0, 0]\n        };\n\n        if (actual) {\n          loc.first_line = actual.first_line | 0;\n          loc.last_line = actual.last_line | 0;\n          loc.first_column = actual.first_column | 0;\n          loc.last_column = actual.last_column | 0;\n\n          if (actual.range) {\n            loc.range[0] = actual.range[0] | 0;\n            loc.range[1] = actual.range[1] | 0;\n          }\n        }\n\n        if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n          // plan B: heuristic using preceding and following:\n          if (loc.first_line <= 0 && preceding) {\n            loc.first_line = preceding.last_line | 0;\n            loc.first_column = preceding.last_column | 0;\n\n            if (preceding.range) {\n              loc.range[0] = actual.range[1] | 0;\n            }\n          }\n\n          if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n            loc.last_line = following.first_line | 0;\n            loc.last_column = following.first_column | 0;\n\n            if (following.range) {\n              loc.range[1] = actual.range[0] | 0;\n            }\n          } // plan C?: see if the 'current' location is useful/sane too:\n\n\n          if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n            loc.first_line = current.first_line | 0;\n            loc.first_column = current.first_column | 0;\n\n            if (current.range) {\n              loc.range[0] = current.range[0] | 0;\n            }\n          }\n\n          if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n            loc.last_line = current.last_line | 0;\n            loc.last_column = current.last_column | 0;\n\n            if (current.range) {\n              loc.range[1] = current.range[1] | 0;\n            }\n          }\n        } // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\n        // or plan D heuristics to produce a 'sensible' last_line value:\n\n\n        if (loc.last_line <= 0) {\n          if (loc.first_line <= 0) {\n            loc.first_line = this.yylloc.first_line;\n            loc.last_line = this.yylloc.last_line;\n            loc.first_column = this.yylloc.first_column;\n            loc.last_column = this.yylloc.last_column;\n            loc.range[0] = this.yylloc.range[0];\n            loc.range[1] = this.yylloc.range[1];\n          } else {\n            loc.last_line = this.yylloc.last_line;\n            loc.last_column = this.yylloc.last_column;\n            loc.range[1] = this.yylloc.range[1];\n          }\n        }\n\n        if (loc.first_line <= 0) {\n          loc.first_line = loc.last_line;\n          loc.first_column = 0; // loc.last_column;\n\n          loc.range[1] = loc.range[0];\n        }\n\n        if (loc.first_column < 0) {\n          loc.first_column = 0;\n        }\n\n        if (loc.last_column < 0) {\n          loc.last_column = loc.first_column > 0 ? loc.first_column : 80;\n        }\n\n        return loc;\n      },\n\n      /**\n       * return a string which displays the lines & columns of input which are referenced\n       * by the given location info range, plus a few lines of context.\n       *\n       * This function pretty-prints the indicated section of the input, with line numbers\n       * and everything!\n       *\n       * This function is very useful to provide highly readable error reports, while\n       * the location range may be specified in various flexible ways:\n       *\n       * - `loc` is the location info object which references the area which should be\n       *   displayed and 'marked up': these lines & columns of text are marked up by `^`\n       *   characters below each character in the entire input range.\n       *\n       * - `context_loc` is the *optional* location info object which instructs this\n       *   pretty-printer how much *leading* context should be displayed alongside\n       *   the area referenced by `loc`. This can help provide context for the displayed\n       *   error, etc.\n       *\n       *   When this location info is not provided, a default context of 3 lines is\n       *   used.\n       *\n       * - `context_loc2` is another *optional* location info object, which serves\n       *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\n       *   context lines to display in the pretty-print output.\n       *\n       *   When this location info is not provided, a default context of 1 line only is\n       *   used.\n       *\n       * Special Notes:\n       *\n       * - when the `loc`-indicated range is very large (about 5 lines or more), then\n       *   only the first and last few lines of this block are printed while a\n       *   `...continued...` message will be printed between them.\n       *\n       *   This serves the purpose of not printing a huge amount of text when the `loc`\n       *   range happens to be huge: this way a manageable & readable output results\n       *   for arbitrary large ranges.\n       *\n       * - this function can display lines of input which whave not yet been lexed.\n       *   `prettyPrintRange()` can access the entire input!\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n        loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\n        const CONTEXT = 3;\n        const CONTEXT_TAIL = 1;\n        const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n        var input = this.matched + this._input;\n        var lines = input.split('\\n');\n        var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);\n        var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);\n        var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\n        var ws_prefix = new Array(lineno_display_width).join(' ');\n        var nonempty_line_indexes = [];\n        var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n          var lno = index + l0;\n          var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n          var rv = lno_pfx + ': ' + line;\n          var errpfx = new Array(lineno_display_width + 1).join('^');\n          var offset = 2 + 1;\n          var len = 0;\n\n          if (lno === loc.first_line) {\n            offset += loc.first_column;\n            len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);\n          } else if (lno === loc.last_line) {\n            len = Math.max(2, loc.last_column + 1);\n          } else if (lno > loc.first_line && lno < loc.last_line) {\n            len = Math.max(2, line.length + 1);\n          }\n\n          if (len) {\n            var lead = new Array(offset).join('.');\n            var mark = new Array(len).join('^');\n            rv += '\\n' + errpfx + lead + mark;\n\n            if (line.trim().length > 0) {\n              nonempty_line_indexes.push(index);\n            }\n          }\n\n          rv = rv.replace(/\\t/g, ' ');\n          return rv;\n        }); // now make sure we don't print an overly large amount of error area: limit it\n        // to the top and bottom line count:\n\n        if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n          var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n          var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n          var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';\n          intermediate_line += '\\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';\n          rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n        }\n\n        return rv.join('\\n');\n      },\n\n      /**\n       * helper function, used to produce a human readable description as a string, given\n       * the input `yylloc` location object.\n       *\n       * Set `display_range_too` to TRUE to include the string character index position(s)\n       * in the description if the `yylloc.range` is available.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n        var l1 = yylloc.first_line;\n        var l2 = yylloc.last_line;\n        var c1 = yylloc.first_column;\n        var c2 = yylloc.last_column;\n        var dl = l2 - l1;\n        var dc = c2 - c1;\n        var rv;\n\n        if (dl === 0) {\n          rv = 'line ' + l1 + ', ';\n\n          if (dc <= 1) {\n            rv += 'column ' + c1;\n          } else {\n            rv += 'columns ' + c1 + ' .. ' + c2;\n          }\n        } else {\n          rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';\n        }\n\n        if (yylloc.range && display_range_too) {\n          var r1 = yylloc.range[0];\n          var r2 = yylloc.range[1] - 1;\n\n          if (r2 <= r1) {\n            rv += ' {String Offset: ' + r1 + '}';\n          } else {\n            rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';\n          }\n        }\n\n        return rv;\n      },\n\n      /**\n       * test the lexed token: return FALSE when not a match, otherwise return token.\n       *\n       * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\n       * contains the actually matched text string.\n       *\n       * Also move the input cursor forward and update the match collectors:\n       *\n       * - `yytext`\n       * - `yyleng`\n       * - `match`\n       * - `matches`\n       * - `yylloc`\n       * - `offset`\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      test_match: function lexer_test_match(match, indexed_rule) {\n        var token, lines, backup, match_str, match_str_len;\n\n        if (this.options.backtrack_lexer) {\n          // save context\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.yylloc.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column,\n              range: this.yylloc.range.slice(0)\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            //_signaled_error_token: this._signaled_error_token,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n        }\n\n        match_str = match[0];\n        match_str_len = match_str.length; // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\n\n        lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n\n        if (lines.length > 1) {\n          this.yylineno += lines.length - 1;\n          this.yylloc.last_line = this.yylineno + 1;\n          this.yylloc.last_column = lines[lines.length - 1].length;\n        } else {\n          this.yylloc.last_column += match_str_len;\n        } // }\n\n\n        this.yytext += match_str;\n        this.match += match_str;\n        this.matched += match_str;\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        this.yylloc.range[1] += match_str_len; // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n        // those rules will already have moved this `offset` forward matching their match lengths,\n        // hence we must only add our own match length now:\n\n        this.offset += match_str_len;\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match_str_len); // calling this method:\n        //\n        //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n\n        token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1]\n        /* = YY_START */\n        ); // otherwise, when the action codes are all simple return token statements:\n        //token = this.simpleCaseActionClusters[indexed_rule];\n\n        if (this.done && this._input) {\n          this.done = false;\n        }\n\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          // recover context\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n\n          this.__currentRuleSet__ = null;\n          return false; // rule action called reject() implying the next rule should be tested instead.\n        } else if (this._signaled_error_token) {\n          // produce one 'error' token as `.parseError()` in `reject()`\n          // did not guarantee a failure signal by throwing an exception!\n          token = this._signaled_error_token;\n          this._signaled_error_token = false;\n          return token;\n        }\n\n        return false;\n      },\n\n      /**\n       * return next match in input\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      next: function lexer_next() {\n        if (this.done) {\n          this.clear();\n          return this.EOF;\n        }\n\n        if (!this._input) {\n          this.done = true;\n        }\n\n        var token, match, tempMatch, index;\n\n        if (!this._more) {\n          this.clear();\n        }\n\n        var spec = this.__currentRuleSet__;\n\n        if (!spec) {\n          // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n          // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n          // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n          // speed up those activities a tiny bit.\n          spec = this.__currentRuleSet__ = this._currentRules(); // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n          // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n\n          if (!spec || !spec.rules) {\n            var lineno_msg = '';\n\n            if (this.options.trackPosition) {\n              lineno_msg = ' on line ' + (this.yylineno + 1);\n            }\n\n            var p = this.constructLexErrorInfo('Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!', false); // produce one 'error' token until this situation has been resolved, most probably by parse termination!\n\n            return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n          }\n        }\n\n        var rule_ids = spec.rules;\n        var regexes = spec.__rule_regexes;\n        var len = spec.__rule_count; // Note: the arrays are 1-based, while `len` itself is a valid index,\n        // hence the non-standard less-or-equal check in the next loop condition!\n\n        for (var i = 1; i <= len; i++) {\n          tempMatch = this._input.match(regexes[i]);\n\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rule_ids[i]);\n\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = undefined;\n                continue; // rule action called reject() implying a rule MISmatch.\n              } else {\n                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n\n        if (match) {\n          token = this.test_match(match, rule_ids[index]);\n\n          if (token !== false) {\n            return token;\n          } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n\n\n          return false;\n        }\n\n        if (!this._input) {\n          this.done = true;\n          this.clear();\n          return this.EOF;\n        } else {\n          var lineno_msg = '';\n\n          if (this.options.trackPosition) {\n            lineno_msg = ' on line ' + (this.yylineno + 1);\n          }\n\n          var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': Unrecognized text.', this.options.lexerErrorsAreRecoverable);\n          var pendingInput = this._input;\n          var activeCondition = this.topState();\n          var conditionStackDepth = this.conditionStack.length;\n          token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n\n          if (token === this.ERROR) {\n            // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\n            // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n            // has not consumed/modified any pending input or changed state in the error handler:\n            if (!this.matches && // and make sure the input has been modified/consumed ...\n            pendingInput === this._input && // ...or the lexer state has been modified significantly enough\n            // to merit a non-consuming error handling action right now.\n            activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\n              this.input();\n            }\n          }\n\n          return token;\n        }\n      },\n\n      /**\n       * return next match that has a token\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      lex: function lexer_lex() {\n        var r; // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n\n        if (typeof this.pre_lex === 'function') {\n          r = this.pre_lex.call(this, 0);\n        }\n\n        if (typeof this.options.pre_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.options.pre_lex.call(this, r) || r;\n        }\n\n        if (this.yy && typeof this.yy.pre_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.yy.pre_lex.call(this, r) || r;\n        }\n\n        while (!r) {\n          r = this.next();\n        }\n\n        if (this.yy && typeof this.yy.post_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.yy.post_lex.call(this, r) || r;\n        }\n\n        if (typeof this.options.post_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.options.post_lex.call(this, r) || r;\n        }\n\n        if (typeof this.post_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.post_lex.call(this, r) || r;\n        }\n\n        return r;\n      },\n\n      /**\n       * return next match that has a token. Identical to the `lex()` API but does not invoke any of the\n       * `pre_lex()` nor any of the `post_lex()` callbacks.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      fastLex: function lexer_fastLex() {\n        var r;\n\n        while (!r) {\n          r = this.next();\n        }\n\n        return r;\n      },\n\n      /**\n       * return info about the lexer state that can help a parser or other lexer API user to use the\n       * most efficient means available. This API is provided to aid run-time performance for larger\n       * systems which employ this lexer.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      canIUse: function lexer_canIUse() {\n        var rv = {\n          fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'\n        };\n        return rv;\n      },\n\n      /**\n       * backwards compatible alias for `pushState()`;\n       * the latter is symmetrical with `popState()` and we advise to use\n       * those APIs in any modern lexer code, rather than `begin()`.\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      begin: function lexer_begin(condition) {\n        return this.pushState(condition);\n      },\n\n      /**\n       * activates a new lexer condition state (pushes the new lexer\n       * condition state onto the condition stack)\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      pushState: function lexer_pushState(condition) {\n        this.conditionStack.push(condition);\n        this.__currentRuleSet__ = null;\n        return this;\n      },\n\n      /**\n       * pop the previously active lexer condition state off the condition\n       * stack\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      popState: function lexer_popState() {\n        var n = this.conditionStack.length - 1;\n\n        if (n > 0) {\n          this.__currentRuleSet__ = null;\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      },\n\n      /**\n       * return the currently active lexer condition state; when an index\n       * argument is provided it produces the N-th previous condition state,\n       * if available\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      topState: function lexer_topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return 'INITIAL';\n        }\n      },\n\n      /**\n       * (internal) determine the lexer rule set which is active for the\n       * currently active lexer condition state\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      _currentRules: function lexer__currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n        } else {\n          return this.conditions['INITIAL'];\n        }\n      },\n\n      /**\n       * return the number of states currently on the stack\n       *\n       * @public\n       * @this {RegExpLexer}\n       */\n      stateStackSize: function lexer_stateStackSize() {\n        return this.conditionStack.length;\n      },\n      options: {\n        trackPosition: true,\n        caseInsensitive: true\n      },\n      JisonLexerError: JisonLexerError,\n      performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\n        var yy_ = this;\n        var YYSTATE = YY_START;\n\n        switch (yyrulenumber) {\n          case 0:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       \\s+ */\n\n            /* skip whitespace */\n            break;\n\n          case 7:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)em\\b */\n            return 12; // em\n\n            break;\n\n          case 8:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)ex\\b */\n            return 12; // ex\n\n            break;\n\n          case 9:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)ch\\b */\n            return 12; // ch\n\n            break;\n\n          case 10:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)rem\\b */\n            return 12; // rem\n\n            break;\n\n          case 11:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vw\\b */\n            return 12; // vw\n\n            break;\n\n          case 12:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vh\\b */\n            return 12; // vh\n\n            break;\n\n          case 13:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vmin\\b */\n            return 12; // vmin\n\n            break;\n\n          case 14:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vmax\\b */\n            return 12; // vmax\n\n            break;\n\n          case 15:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vm\\b */\n            return 12; // vm (non-standard name)\n\n            break;\n\n          case 16:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)px\\b */\n            return 12; // px\n\n            break;\n\n          case 17:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)mm\\b */\n            return 12; // mm\n\n            break;\n\n          case 18:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)cm\\b */\n            return 12; // cm\n\n            break;\n\n          case 19:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)in\\b */\n            return 12; // in\n\n            break;\n\n          case 20:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)pt\\b */\n            return 12; // pt\n\n            break;\n\n          case 21:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)pc\\b */\n            return 12; // pc\n\n            break;\n\n          case 22:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)Q\\b */\n            return 12; // Q\n\n            break;\n\n          case 23:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)fr\\b */\n            return 12; // fr\n\n            break;\n\n          case 24:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)deg\\b */\n            return 13; // deg\n\n            break;\n\n          case 25:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)grad\\b */\n            return 13; // grad\n\n            break;\n\n          case 26:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)turn\\b */\n            return 13; // turn\n\n            break;\n\n          case 27:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)rad\\b */\n            return 13; // rad\n\n            break;\n\n          case 28:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)s\\b */\n            return 14; // s\n\n            break;\n\n          case 29:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)ms\\b */\n            return 14; // ms\n\n            break;\n\n          case 30:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)Hz\\b */\n            return 15; // Hz\n\n            break;\n\n          case 31:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)kHz\\b */\n            return 15; // kHz\n\n            break;\n\n          case 32:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)dpi\\b */\n            return 16; // dpi\n\n            break;\n\n          case 33:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)dpcm\\b */\n            return 16; // dpcm\n\n            break;\n\n          case 34:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)dppx\\b */\n            return 16; // dppm\n\n            break;\n\n          case 39:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       #\\{([\\s\\S]*?)\\} */\n            return 18; // scss variable\n\n            break;\n\n          case 40:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       @\\{([\\s\\S]*?)\\} */\n            return 18; // less variable\n\n            break;\n\n          default:\n            return this.simpleCaseActionClusters[yyrulenumber];\n        }\n      },\n      simpleCaseActionClusters: {\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       (-(webkit|moz)-)?calc\\b */\n        1: 3,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       [a-z][a-z0-9-]*\\s*\\((?:(?:\"(?:\\\\.|[^\\\"\\\\])*\"|'(?:\\\\.|[^\\'\\\\])*')|\\([^)]*\\)|[^\\(\\)]*)*\\) */\n        2: 11,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\* */\n        3: 8,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\/ */\n        4: 9,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\+ */\n        5: 6,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       - */\n        6: 7,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)% */\n        35: 17,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)\\b */\n        36: 10,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\( */\n        37: 4,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\) */\n        38: 5,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\S[^\\s()*\\/+-]* */\n        41: 18,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       $ */\n        42: 1\n      },\n      rules: [\n      /*  0: */\n      /^(?:\\s+)/i,\n      /*  1: */\n      /^(?:(-(webkit|moz)-)?calc\\b)/i,\n      /*  2: */\n      /^(?:[a-z][\\d\\-a-z]*\\s*\\((?:(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*')|\\([^)]*\\)|[^()]*)*\\))/i,\n      /*  3: */\n      /^(?:\\*)/i,\n      /*  4: */\n      /^(?:\\/)/i,\n      /*  5: */\n      /^(?:\\+)/i,\n      /*  6: */\n      /^(?:-)/i,\n      /*  7: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)em\\b)/i,\n      /*  8: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)ex\\b)/i,\n      /*  9: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)ch\\b)/i,\n      /* 10: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)rem\\b)/i,\n      /* 11: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vw\\b)/i,\n      /* 12: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vh\\b)/i,\n      /* 13: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vmin\\b)/i,\n      /* 14: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vmax\\b)/i,\n      /* 15: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vm\\b)/i,\n      /* 16: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)px\\b)/i,\n      /* 17: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)mm\\b)/i,\n      /* 18: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)cm\\b)/i,\n      /* 19: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)in\\b)/i,\n      /* 20: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)pt\\b)/i,\n      /* 21: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)pc\\b)/i,\n      /* 22: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)Q\\b)/i,\n      /* 23: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)fr\\b)/i,\n      /* 24: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)deg\\b)/i,\n      /* 25: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)grad\\b)/i,\n      /* 26: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)turn\\b)/i,\n      /* 27: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)rad\\b)/i,\n      /* 28: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)s\\b)/i,\n      /* 29: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)ms\\b)/i,\n      /* 30: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)Hz\\b)/i,\n      /* 31: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)kHz\\b)/i,\n      /* 32: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)dpi\\b)/i,\n      /* 33: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)dpcm\\b)/i,\n      /* 34: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)dppx\\b)/i,\n      /* 35: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)%)/i,\n      /* 36: */\n      /^(?:(\\d+(\\.\\d+)?|\\.\\d+)\\b)/i,\n      /* 37: */\n      /^(?:\\()/i,\n      /* 38: */\n      /^(?:\\))/i,\n      /* 39: */\n      /^(?:#\\{([\\s\\S]*?)\\})/i,\n      /* 40: */\n      /^(?:@\\{([\\s\\S]*?)\\})/i,\n      /* 41: */\n      /^(?:\\S[^\\s()*\\/+-]*)/i,\n      /* 42: */\n      /^(?:$)/i],\n      conditions: {\n        'INITIAL': {\n          rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42],\n          inclusive: true\n        }\n      }\n    };\n    return lexer;\n  }();\n\n  parser.lexer = lexer;\n\n  function Parser() {\n    this.yy = {};\n  }\n\n  Parser.prototype = parser;\n  parser.Parser = Parser;\n  return new Parser();\n}();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = parser;\n  exports.Parser = parser.Parser;\n\n  exports.parse = function () {\n    return parser.parse.apply(parser, arguments);\n  };\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/utils/parseCalcExpression/parser.js"],"names":["parser","JisonParserError","msg","hash","Object","defineProperty","enumerable","writable","value","stacktrace","exception","Error","ex2","message","stack","hasOwnProperty","captureStackTrace","constructor","setPrototypeOf","prototype","create","name","bp","s","rv","p","pop","r","rule","i","l","length","push","bda","d","idx","g","goto","j","bt","len","y","symbol","t","type","a","state","m","mode","n","q","z","shift","c","u","e","apply","trace","no_op_trace","yy","options","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","caseInsensitive","symbols_","terminals_","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","parser_quoteName","id_str","getSymbolName","parser_getSymbolName","key","describeSymbol","parser_describeSymbol","terminal_descriptions_","id","collect_expected_token_set","parser_collect_expected_token_set","do_not_describe","tokenset","check","state_descriptions_","table","productions_","performAction","parser__PerformAction","yyloc","yystate","yysp","yyvstack","yylstack","yyparser","yylexer","lexer","$","_$","source","start","index","range","end","operator","left","right","sign","parseFloat","unit","exec","defaultActions","parseError","str","ExceptionClass","recoverable","destroy","parse","input","self","Array","sstack","vstack","lstack","sp","ERROR_RECOVERY_TOKEN_DISCARD_COUNT","NO_ACTION","__lexer__","sharedState_yy","undefined","pre_parse","post_parse","pre_lex","post_lex","ASSERT","assert","JisonAssert","cond","yyGetSharedState","shallow_copy","src","dst","k","call","shallow_copy_noclobber","copy_yylloc","loc","slice","parseErrorAlt","quoteNameAlt","parser_cleanupAfterParse","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","parser_yyMergeLocationInfo","first_index","last_index","first_yylloc","last_yylloc","dont_look_back","i1","i2","l1","l2","first_line","last_line","first_column","last_column","parser_constructParseErrorInfo","ex","expected","pei","errStr","text","match","yytext","token","token_id","line","yylineno","yylloc","action","new_state","newState","symbol_stack","state_stack","value_stack","location_stack","stack_pointer","destructParseErrorInfo","rec","getNonTerminalFromCode","tokenName","stdLex","lex","fastLex","yyval","yyrulelen","this_production","retval","setInput","canIUse","lexerInfo","errSymbolDescr","showPosition","join","ntsymbol","JisonLexerError","ERROR","__currentRuleSet__","__decompressed","done","_backtrack","_input","_more","_signaled_error_token","conditionStack","matched","matches","offset","yyleng","constructLexErrorInfo","lexer_constructLexErrorInfo","show_input_position","indexOf","prettyPrintRange","pretty_src","test","pos_str","destructLexErrorInfo","lexer_parseError","yyerror","yyError","lineno_msg","lexerErrorsAreRecoverable","args","arguments","extra_error_attributes","lexer_cleanupAfterLex","clear","lexer_clear","col","lexer_setInput","rules","rule_re","conditions","spec","rule_ids","rule_regexes","rule_new_ids","__rule_regexes","__rule_count","editRemainingInput","lexer_editRemainingInput","callback","cpsArg","lexer_input","ch","slice_len","lines","ch2","unput","lexer_unput","split","substr","pre","pre_lines","more","lexer_more","reject","lexer_reject","backtrack_lexer","less","lexer_less","pastInput","lexer_pastInput","maxSize","maxLines","past","substring","replace","upcomingInput","lexer_upcomingInput","next","lexer_showPosition","maxPrefix","maxPostfix","deriveLocationInfo","lexer_deriveYYLLOC","actual","preceding","following","current","lexer_prettyPrintRange","context_loc","context_loc2","CONTEXT","CONTEXT_TAIL","MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT","l0","Math","max","lineno_display_width","log10","ws_prefix","nonempty_line_indexes","map","injectLineNumber","lno","lno_pfx","errpfx","lead","mark","trim","clip_start","clip_end","intermediate_line","splice","describeYYLLOC","lexer_describe_yylloc","display_range_too","c1","c2","dl","dc","r1","r2","test_match","lexer_test_match","indexed_rule","backup","match_str","match_str_len","lexer_next","tempMatch","_currentRules","trackPosition","topState","regexes","flex","pendingInput","activeCondition","conditionStackDepth","lexer_lex","lexer_fastLex","lexer_canIUse","begin","lexer_begin","condition","pushState","lexer_pushState","popState","lexer_popState","lexer_topState","abs","lexer__currentRules","stateStackSize","lexer_stateStackSize","lexer__performAction","yyrulenumber","YY_START","yy_","YYSTATE","simpleCaseActionClusters","inclusive","Parser","require","exports"],"mappings":"AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIY,IAAIA,MAAM,GAAI,YAAY;AAGtC;AACA;AACA;AACA;AACA,WAASC,gBAAT,CAA0BC,GAA1B,EAA+BC,IAA/B,EAAqC;AACjCC,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,MAA5B,EAAoC;AAChCC,MAAAA,UAAU,EAAE,KADoB;AAEhCC,MAAAA,QAAQ,EAAE,KAFsB;AAGhCC,MAAAA,KAAK,EAAE;AAHyB,KAApC;AAMA,QAAIN,GAAG,IAAI,IAAX,EAAiBA,GAAG,GAAG,KAAN;AAEjBE,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACnCC,MAAAA,UAAU,EAAE,KADuB;AAEnCC,MAAAA,QAAQ,EAAE,IAFyB;AAGnCC,MAAAA,KAAK,EAAEN;AAH4B,KAAvC;AAMA,SAAKC,IAAL,GAAYA,IAAZ;AAEA,QAAIM,UAAJ;;AACA,QAAIN,IAAI,IAAIA,IAA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kBAAP,GAA4BrE,MAAM,CAACuH,UAAnC;AACAvH,EAAAA,MAAM,CAACoE,iBAAP,GAA2BpE,MAAM,CAAC4E,SAAlC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAI2B,KAAK,GAAG,YAAW;AA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","sourcesContent":["\n// @ts-nocheck\n\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n\n\n            var parser = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n\n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n\n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n\n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n\n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"classic\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... false\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3,\n  caseInsensitive: true\n},\nsymbols_: {\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"ADD\": 6,\n  \"ANGLE\": 13,\n  \"CALC\": 3,\n  \"DIV\": 9,\n  \"EOF\": 1,\n  \"FREQ\": 15,\n  \"FUNCTION\": 11,\n  \"LENGTH\": 12,\n  \"LPAREN\": 4,\n  \"MUL\": 8,\n  \"NUMBER\": 10,\n  \"PERCENTAGE\": 17,\n  \"RES\": 16,\n  \"RPAREN\": 5,\n  \"SUB\": 7,\n  \"TIME\": 14,\n  \"UNKNOWN\": 18,\n  \"css_value\": 23,\n  \"error\": 2,\n  \"expression\": 19,\n  \"function\": 22,\n  \"math_expression\": 20,\n  \"value\": 21\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"CALC\",\n  4: \"LPAREN\",\n  5: \"RPAREN\",\n  6: \"ADD\",\n  7: \"SUB\",\n  8: \"MUL\",\n  9: \"DIV\",\n  10: \"NUMBER\",\n  11: \"FUNCTION\",\n  12: \"LENGTH\",\n  13: \"ANGLE\",\n  14: \"TIME\",\n  15: \"FREQ\",\n  16: \"RES\",\n  17: \"PERCENTAGE\",\n  18: \"UNKNOWN\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  19,\n  s,\n  [20, 11],\n  21,\n  22,\n  s,\n  [23, 7]\n]),\n  rule: u([\n  2,\n  4,\n  s,\n  [3, 4],\n  2,\n  2,\n  3,\n  s,\n  [1, 12]\n])\n}),\nperformAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n\n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : expression $end */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = yyvstack[yysp - 1];\n    this._$ = yylstack[yysp - 1];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    break;\n\ncase 1:\n    /*! Production::    expression : math_expression EOF */\n\n    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n    this.$ = yyvstack[yysp - 1];\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n\n\n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    math_expression : CALC LPAREN math_expression RPAREN */\n\n    // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = yyvstack[yysp - 1];\n    this.$.source.start = { index: yylstack[yysp - 3].range[0] };\n    this.$.source.end = { index: yylstack[yysp].range[1] };\n    break;\n\ncase 3:\n    /*! Production::    math_expression : math_expression ADD math_expression */\ncase 4:\n    /*! Production::    math_expression : math_expression SUB math_expression */\ncase 5:\n    /*! Production::    math_expression : math_expression MUL math_expression */\ncase 6:\n    /*! Production::    math_expression : math_expression DIV math_expression */\n\n    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = {\n      type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp],\n      source: {\n        start: yyvstack[yysp - 2].source.start, end: yyvstack[yysp].source.end,\n        operator: { start: { index: yylstack[yysp - 1].range[0] }, end: { index: yylstack[yysp - 1].range[1] } }\n      }\n    };\n    break;\n\ncase 7:\n    /*! Production::    math_expression : SUB math_expression */\n\n    // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n\n\n    if (yylstack[yysp - 1].range[1] !== yyvstack[yysp].source.start.index) {\n      throw new Error('Unexpected spaces was found between sign and value');\n    }\n    if (typeof yyvstack[yysp].value !== 'number') {\n      throw new Error('Unexpected sign');\n    }\n    if (yyvstack[yysp].sign) {\n      throw new Error('Unexpected continuous sign');\n    }\n    this.$ = yyvstack[yysp];\n    this.$.sign = '-'\n    this.$.value = -yyvstack[yysp].value;\n    this.$.source.start.index = yylstack[yysp - 1].range[0];\n    break;\n\ncase 8:\n    /*! Production::    math_expression : ADD math_expression */\n\n    // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n\n\n    if (yylstack[yysp - 1].range[1] !== yyvstack[yysp].source.start.index) {\n      throw new Error('Unexpected spaces was found between sign and value');\n    }\n    if (typeof yyvstack[yysp].value !== 'number') {\n      throw new Error('Unexpected sign');\n    }\n    if (yyvstack[yysp].sign) {\n      throw new Error('Unexpected continuous sign');\n    }\n    this.$ = yyvstack[yysp];\n    this.$.sign = '+'\n    this.$.source.start.index = yylstack[yysp - 1].range[0];\n    break;\n\ncase 9:\n    /*! Production::    math_expression : LPAREN math_expression RPAREN */\n\n    // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = yyvstack[yysp - 1];\n    this.$.source.start = { index: yylstack[yysp - 2].range[0] };\n    this.$.source.end = { index: yylstack[yysp].range[1] };\n    break;\n\ncase 10:\n    /*! Production::    math_expression : function */\ncase 11:\n    /*! Production::    math_expression : css_value */\ncase 12:\n    /*! Production::    math_expression : value */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = yyvstack[yysp];\n    break;\n\ncase 13:\n    /*! Production::    value : NUMBER */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]), source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 14:\n    /*! Production::    function : FUNCTION */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'Function', value: yyvstack[yysp], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 15:\n    /*! Production::    css_value : LENGTH */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 16:\n    /*! Production::    css_value : ANGLE */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 17:\n    /*! Production::    css_value : TIME */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 18:\n    /*! Production::    css_value : FREQ */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 19:\n    /*! Production::    css_value : RES */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 20:\n    /*! Production::    css_value : PERCENTAGE */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%', source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\ncase 21:\n    /*! Production::    css_value : UNKNOWN */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n\n\n    this.$ = { type: 'UnknownValue', value: yyvstack[yysp], unit: '', source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  18,\n  1,\n  5,\n  1,\n  s,\n  [17, 3],\n  s,\n  [0, 13],\n  s,\n  [17, 5],\n  0,\n  0,\n  5,\n  6,\n  6,\n  c,\n  [5, 3],\n  0,\n  0\n]),\n  symbol: u([\n  3,\n  4,\n  6,\n  7,\n  s,\n  [10, 14, 1],\n  1,\n  1,\n  s,\n  [6, 4, 1],\n  4,\n  c,\n  [25, 13],\n  c,\n  [24, 4],\n  c,\n  [17, 119],\n  s,\n  [5, 5, 1],\n  1,\n  c,\n  [6, 11],\n  c,\n  [5, 5]\n]),\n  type: u([\n  s,\n  [2, 13],\n  s,\n  [0, 5],\n  1,\n  s,\n  [2, 19],\n  s,\n  [0, 4],\n  c,\n  [17, 132],\n  s,\n  [2, 9]\n]),\n  state: u([\n  1,\n  2,\n  9,\n  7,\n  8,\n  25,\n  c,\n  [4, 3],\n  26,\n  c,\n  [4, 3],\n  27,\n  c,\n  [4, 3],\n  28,\n  c,\n  [4, 3],\n  29,\n  c,\n  [4, 3],\n  30,\n  c,\n  [4, 3],\n  31,\n  c,\n  [4, 3],\n  32,\n  c,\n  [4, 3]\n]),\n  mode: u([\n  s,\n  [1, 128],\n  s,\n  [2, 4],\n  c,\n  [6, 8],\n  s,\n  [1, 5]\n]),\n  goto: u([\n  3,\n  6,\n  5,\n  4,\n  18,\n  s,\n  [10, 8, 1],\n  s,\n  [19, 6, 1],\n  c,\n  [19, 13],\n  c,\n  [13, 91],\n  33,\n  c,\n  [110, 4],\n  s,\n  [3, 4],\n  22,\n  23,\n  s,\n  [4, 4],\n  22,\n  23,\n  34,\n  c,\n  [17, 4]\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  s,\n  [7, 13, 1],\n  25,\n  26,\n  30,\n  31,\n  33,\n  34\n]),\n  goto: u([\n  10,\n  11,\n  12,\n  s,\n  [14, 8, 1],\n  13,\n  1,\n  7,\n  8,\n  5,\n  6,\n  9,\n  2\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n    var yyloc;\n\n\n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 35 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === 'object') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after*\n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        }\n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n\n\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n/* lexer generated by jison-lex 0.6.1-215 */\n\n/*\n * Returns a Lexer object of the following structure:\n *\n *  Lexer: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a direct reference!\n *\n *               This \"shared context\" object was passed to the lexer by way of\n *               the `lexer.setInput(str, yy)` API before you may use it.\n *\n *               This \"shared context\" object is passed to the lexer action code in `performAction()`\n *               so userland code in the lexer actions may communicate with the outside world\n *               and/or other lexer rules' actions in more or less complex ways.\n *\n *  }\n *\n *  Lexer.prototype: {\n *    EOF: 1,\n *    ERROR: 2,\n *\n *    yy:        The overall \"shared context\" object reference.\n *\n *    JisonLexerError: function(msg, hash),\n *\n *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `lexer` instance.\n *                               `yy_` is an alias for `this` lexer instance reference used internally.\n *\n *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\n *                             by way of the `lexer.setInput(str, yy)` API before.\n *\n *                             Note:\n *                             The extra arguments you specified in the `%parse-param` statement in your\n *                             **parser** grammar definition file are passed to the lexer via this object\n *                             reference as member variables.\n *\n *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\n *\n *               - `YY_START`: the current lexer \"start condition\" state.\n *\n *    parseError: function(str, hash, ExceptionClass),\n *\n *    constructLexErrorInfo: function(error_message, is_recoverable),\n *               Helper function.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this lexer kernel in many places; example usage:\n *\n *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\n *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n *\n *    options: { ... lexer %options ... },\n *\n *    lex: function(),\n *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the **parser** or the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n *               Helper function.\n *\n *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired.\n *\n *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n *\n *    setInput: function(input, [yy]),\n *\n *\n *    input: function(),\n *\n *\n *    unput: function(str),\n *\n *\n *    more: function(),\n *\n *\n *    reject: function(),\n *\n *\n *    less: function(n),\n *\n *\n *    pastInput: function(n),\n *\n *\n *    upcomingInput: function(n),\n *\n *\n *    showPosition: function(),\n *\n *\n *    test_match: function(regex_match_array, rule_index),\n *\n *\n *    next: function(),\n *\n *\n *    begin: function(condition),\n *\n *\n *    pushState: function(condition),\n *\n *\n *    popState: function(),\n *\n *\n *    topState: function(),\n *\n *\n *    _currentRules: function(),\n *\n *\n *    stateStackSize: function(),\n *\n *\n *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n *\n *\n *    rules: [...],\n *\n *\n *    conditions: {associative list: name ==> set},\n *  }\n *\n *\n *  token location info (`yylloc`): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *  }\n *\n * while `this` will reference the current lexer instance.\n *\n * When `parseError` is invoked by the lexer, the default implementation will\n * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\n * it will try to invoke `yy.parseError()` instead. When that callback is also not\n * provided, a `JisonLexerError` exception will be thrown containing the error\n * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\n *\n * Note that the lexer's `JisonLexerError` error class is passed via the\n * `ExceptionClass` argument, which is invoked to construct the exception\n * instance to be thrown, so technically `parseError` will throw the object\n * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\n *\n * ---\n *\n * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\n * These options are available:\n *\n * (Options are permanent.)\n *\n *  yy: {\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *  }\n *\n *  lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n * the lexer as per when it was compiled!\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n\nvar lexer = function() {\n  /**\n   * See also:\n   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n   * with userland code which might access the derived class in a 'classic' way.\n   *\n   * @public\n   * @constructor\n   * @nocollapse\n   */\n  function JisonLexerError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n      enumerable: false,\n      writable: false,\n      value: 'JisonLexerError'\n    });\n\n    if (msg == null)\n      msg = '???';\n\n    Object.defineProperty(this, 'message', {\n      enumerable: false,\n      writable: true,\n      value: msg\n    });\n\n    this.hash = hash;\n    var stacktrace;\n\n    if (hash && hash.exception instanceof Error) {\n      var ex2 = hash.exception;\n      this.message = ex2.message || msg;\n      stacktrace = ex2.stack;\n    }\n\n    if (!stacktrace) {\n      if (Error.hasOwnProperty('captureStackTrace')) {\n        // V8\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        stacktrace = new Error(msg).stack;\n      }\n    }\n\n    if (stacktrace) {\n      Object.defineProperty(this, 'stack', {\n        enumerable: false,\n        writable: false,\n        value: stacktrace\n      });\n    }\n  }\n\n  if (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n  } else {\n    JisonLexerError.prototype = Object.create(Error.prototype);\n  }\n\n  JisonLexerError.prototype.constructor = JisonLexerError;\n  JisonLexerError.prototype.name = 'JisonLexerError';\n\n  var lexer = {\n\n// Code Generator Information Report\n// ---------------------------------\n//\n// Options:\n//\n//   backtracking: .................... false\n//   location.ranges: ................. false\n//   location line+column tracking: ... true\n//\n//\n// Forwarded Parser Analysis flags:\n//\n//   uses yyleng: ..................... false\n//   uses yylineno: ................... false\n//   uses yytext: ..................... false\n//   uses yylloc: ..................... false\n//   uses lexer values: ............... true / true\n//   location tracking: ............... true\n//   location assignment: ............. true\n//\n//\n// Lexer Analysis flags:\n//\n//   uses yyleng: ..................... ???\n//   uses yylineno: ................... ???\n//   uses yytext: ..................... ???\n//   uses yylloc: ..................... ???\n//   uses ParseError API: ............. ???\n//   uses yyerror: .................... ???\n//   uses location tracking & editing:  ???\n//   uses more() API: ................. ???\n//   uses unput() API: ................ ???\n//   uses reject() API: ............... ???\n//   uses less() API: ................. ???\n//   uses display APIs pastInput(), upcomingInput(), showPosition():\n//        ............................. ???\n//   uses describeYYLLOC() API: ....... ???\n//\n// --------- END OF REPORT -----------\n\nEOF: 1,\n    ERROR: 2,\n\n    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n\n    // options: {},                             /// <-- injected by the code generator\n\n    // yy: ...,                                 /// <-- injected by setInput()\n\n    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state\n\n    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup\n    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use\n    done: false,                                /// INTERNAL USE ONLY\n    _backtrack: false,                          /// INTERNAL USE ONLY\n    _input: '',                                 /// INTERNAL USE ONLY\n    _more: false,                               /// INTERNAL USE ONLY\n    _signaled_error_token: false,               /// INTERNAL USE ONLY\n    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`\n    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!\n    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far\n    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt\n    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.\n    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far\n    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)\n    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located\n    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction\n\n    /**\n     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n      msg = '' + msg;\n\n      // heuristic to determine if the error message already contains a (partial) source code dump\n      // as produced by either `showPosition()` or `prettyPrintRange()`:\n      if (show_input_position == undefined) {\n        show_input_position = !(msg.indexOf('\\n') > 0 && msg.indexOf('^') > 0);\n      }\n\n      if (this.yylloc && show_input_position) {\n        if (typeof this.prettyPrintRange === 'function') {\n          var pretty_src = this.prettyPrintRange(this.yylloc);\n\n          if (!/\\n\\s*$/.test(msg)) {\n            msg += '\\n';\n          }\n\n          msg += '\\n  Erroneous area:\\n' + this.prettyPrintRange(this.yylloc);\n        } else if (typeof this.showPosition === 'function') {\n          var pos_str = this.showPosition();\n\n          if (pos_str) {\n            if (msg.length && msg[msg.length - 1] !== '\\n' && pos_str[0] !== '\\n') {\n              msg += '\\n' + pos_str;\n            } else {\n              msg += pos_str;\n            }\n          }\n        }\n      }\n\n      /** @constructor */\n      var pei = {\n        errStr: msg,\n        recoverable: !!recoverable,\n        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...\n        token: null,\n        line: this.yylineno,\n        loc: this.yylloc,\n        yy: this.yy,\n        lexer: this,\n\n        /**\n         * and make sure the error info doesn't stay due to potential\n         * ref cycle via userland code manipulations.\n         * These would otherwise all be memory leak opportunities!\n         *\n         * Note that only array and object references are nuked as those\n         * constitute the set of elements which can produce a cyclic ref.\n         * The rest of the members is kept intact as they are harmless.\n         *\n         * @public\n         * @this {LexErrorInfo}\n         */\n        destroy: function destructLexErrorInfo() {\n          // remove cyclic references added to error info:\n          // info.yy = null;\n          // info.lexer = null;\n          // ...\n          var rec = !!this.recoverable;\n\n          for (var key in this) {\n            if (this.hasOwnProperty(key) && typeof key === 'object') {\n              this[key] = undefined;\n            }\n          }\n\n          this.recoverable = rec;\n        }\n      };\n\n      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n      this.__error_infos.push(pei);\n\n      return pei;\n    },\n\n    /**\n     * handler which is invoked when a lexer error occurs.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    parseError: function lexer_parseError(str, hash, ExceptionClass) {\n      if (!ExceptionClass) {\n        ExceptionClass = this.JisonLexerError;\n      }\n\n      if (this.yy) {\n        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {\n          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n        } else if (typeof this.yy.parseError === 'function') {\n          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n        }\n      }\n\n      throw new ExceptionClass(str, hash);\n    },\n\n    /**\n     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    yyerror: function yyError(str /*, ...args */) {\n      var lineno_msg = '';\n\n      if (this.yylloc) {\n        lineno_msg = ' on line ' + (this.yylineno + 1);\n      }\n\n      var p = this.constructLexErrorInfo(\n        'Lexical error' + lineno_msg + ': ' + str,\n        this.options.lexerErrorsAreRecoverable\n      );\n\n      // Add any extra args to the hash under the name `extra_error_attributes`:\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if (args.length) {\n        p.extra_error_attributes = args;\n      }\n\n      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n    },\n\n    /**\n     * final cleanup function for when we have completed lexing the input;\n     * make it an API so that external code can use this one once userland\n     * code has decided it's time to destroy any lingering lexer error\n     * hash object instances and the like: this function helps to clean\n     * up these constructs, which *may* carry cyclic references which would\n     * otherwise prevent the instances from being properly and timely\n     * garbage-collected, i.e. this function helps prevent memory leaks!\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n      // prevent lingering circular references from causing memory leaks:\n      this.setInput('', {});\n\n      // nuke the error hash info instances created during this run.\n      // Userland code must COPY any data/references\n      // in the error hash instance(s) it is more permanently interested in.\n      if (!do_not_nuke_errorinfos) {\n        for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n          var el = this.__error_infos[i];\n\n          if (el && typeof el.destroy === 'function') {\n            el.destroy();\n          }\n        }\n\n        this.__error_infos.length = 0;\n      }\n\n      return this;\n    },\n\n    /**\n     * clear the lexer token context; intended for internal use only\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    clear: function lexer_clear() {\n      this.yytext = '';\n      this.yyleng = 0;\n      this.match = '';\n\n      // - DO NOT reset `this.matched`\n      this.matches = false;\n\n      this._more = false;\n      this._backtrack = false;\n      var col = (this.yylloc ? this.yylloc.last_column : 0);\n\n      this.yylloc = {\n        first_line: this.yylineno + 1,\n        first_column: col,\n        last_line: this.yylineno + 1,\n        last_column: col,\n        range: [this.offset, this.offset]\n      };\n    },\n\n    /**\n     * resets the lexer, sets new input\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    setInput: function lexer_setInput(input, yy) {\n      this.yy = yy || this.yy || {};\n\n      // also check if we've fully initialized the lexer instance,\n      // including expansion work to be done to go from a loaded\n      // lexer to a usable lexer:\n      if (!this.__decompressed) {\n        // step 1: decompress the regex list:\n        var rules = this.rules;\n\n        for (var i = 0, len = rules.length; i < len; i++) {\n          var rule_re = rules[i];\n\n          // compression: is the RE an xref to another RE slot in the rules[] table?\n          if (typeof rule_re === 'number') {\n            rules[i] = rules[rule_re];\n          }\n        }\n\n        // step 2: unfold the conditions[] set to make these ready for use:\n        var conditions = this.conditions;\n\n        for (var k in conditions) {\n          var spec = conditions[k];\n          var rule_ids = spec.rules;\n          var len = rule_ids.length;\n          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!\n          var rule_new_ids = new Array(len + 1);\n\n          for (var i = 0; i < len; i++) {\n            var idx = rule_ids[i];\n            var rule_re = rules[idx];\n            rule_regexes[i + 1] = rule_re;\n            rule_new_ids[i + 1] = idx;\n          }\n\n          spec.rules = rule_new_ids;\n          spec.__rule_regexes = rule_regexes;\n          spec.__rule_count = len;\n        }\n\n        this.__decompressed = true;\n      }\n\n      this._input = input || '';\n      this.clear();\n      this._signaled_error_token = false;\n      this.done = false;\n      this.yylineno = 0;\n      this.matched = '';\n      this.conditionStack = ['INITIAL'];\n      this.__currentRuleSet__ = null;\n\n      this.yylloc = {\n        first_line: 1,\n        first_column: 0,\n        last_line: 1,\n        last_column: 0,\n        range: [0, 0]\n      };\n\n      this.offset = 0;\n      return this;\n    },\n\n    /**\n     * edit the remaining input via user-specified callback.\n     * This can be used to forward-adjust the input-to-parse,\n     * e.g. inserting macro expansions and alike in the\n     * input which has yet to be lexed.\n     * The behaviour of this API contrasts the `unput()` et al\n     * APIs as those act on the *consumed* input, while this\n     * one allows one to manipulate the future, without impacting\n     * the current `yyloc` cursor location or any history.\n     *\n     * Use this API to help implement C-preprocessor-like\n     * `#include` statements, etc.\n     *\n     * The provided callback must be synchronous and is\n     * expected to return the edited input (string).\n     *\n     * The `cpsArg` argument value is passed to the callback\n     * as-is.\n     *\n     * `callback` interface:\n     * `function callback(input, cpsArg)`\n     *\n     * - `input` will carry the remaining-input-to-lex string\n     *   from the lexer.\n     * - `cpsArg` is `cpsArg` passed into this API.\n     *\n     * The `this` reference for the callback will be set to\n     * reference this lexer instance so that userland code\n     * in the callback can easily and quickly access any lexer\n     * API.\n     *\n     * When the callback returns a non-string-type falsey value,\n     * we assume the callback did not edit the input and we\n     * will using the input as-is.\n     *\n     * When the callback returns a non-string-type value, it\n     * is converted to a string for lexing via the `\"\" + retval`\n     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html\n     * -- that way any returned object's `toValue()` and `toString()`\n     * methods will be invoked in a proper/desirable order.)\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n      var rv = callback.call(this, this._input, cpsArg);\n\n      if (typeof rv !== 'string') {\n        if (rv) {\n          this._input = '' + rv;\n        }\n        // else: keep `this._input` as is.\n      } else {\n        this._input = rv;\n      }\n\n      return this;\n    },\n\n    /**\n     * consumes and returns one char from the input\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    input: function lexer_input() {\n      if (!this._input) {\n        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n        return null;\n      }\n\n      var ch = this._input[0];\n      this.yytext += ch;\n      this.yyleng++;\n      this.offset++;\n      this.match += ch;\n      this.matched += ch;\n\n      // Count the linenumber up when we hit the LF (or a stand-alone CR).\n      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n      // and we advance immediately past the LF as well, returning both together as if\n      // it was all a single 'character' only.\n      var slice_len = 1;\n\n      var lines = false;\n\n      if (ch === '\\n') {\n        lines = true;\n      } else if (ch === '\\r') {\n        lines = true;\n        var ch2 = this._input[1];\n\n        if (ch2 === '\\n') {\n          slice_len++;\n          ch += ch2;\n          this.yytext += ch2;\n          this.yyleng++;\n          this.offset++;\n          this.match += ch2;\n          this.matched += ch2;\n          this.yylloc.range[1]++;\n        }\n      }\n\n      if (lines) {\n        this.yylineno++;\n        this.yylloc.last_line++;\n        this.yylloc.last_column = 0;\n      } else {\n        this.yylloc.last_column++;\n      }\n\n      this.yylloc.range[1]++;\n      this._input = this._input.slice(slice_len);\n      return ch;\n    },\n\n    /**\n     * unshifts one char (or an entire string) into the input\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    unput: function lexer_unput(ch) {\n      var len = ch.length;\n      var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n      this._input = ch + this._input;\n      this.yytext = this.yytext.substr(0, this.yytext.length - len);\n      this.yyleng = this.yytext.length;\n      this.offset -= len;\n      this.match = this.match.substr(0, this.match.length - len);\n      this.matched = this.matched.substr(0, this.matched.length - len);\n\n      if (lines.length > 1) {\n        this.yylineno -= lines.length - 1;\n        this.yylloc.last_line = this.yylineno + 1;\n\n        // Get last entirely matched line into the `pre_lines[]` array's\n        // last index slot; we don't mind when other previously\n        // matched lines end up in the array too.\n        var pre = this.match;\n\n        var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n\n        if (pre_lines.length === 1) {\n          pre = this.matched;\n          pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n        }\n\n        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n      } else {\n        this.yylloc.last_column -= len;\n      }\n\n      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n      this.done = false;\n      return this;\n    },\n\n    /**\n     * cache matched text and append it on next action\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    more: function lexer_more() {\n      this._more = true;\n      return this;\n    },\n\n    /**\n     * signal the lexer that this rule fails to match the input, so the\n     * next matching rule (regex) should be tested instead.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    reject: function lexer_reject() {\n      if (this.options.backtrack_lexer) {\n        this._backtrack = true;\n      } else {\n        // when the `parseError()` call returns, we MUST ensure that the error is registered.\n        // We accomplish this by signaling an 'error' token to be produced for the current\n        // `.lex()` run.\n        var lineno_msg = '';\n\n        if (this.yylloc) {\n          lineno_msg = ' on line ' + (this.yylineno + 1);\n        }\n\n        var p = this.constructLexErrorInfo(\n          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',\n          false\n        );\n\n        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n      }\n\n      return this;\n    },\n\n    /**\n     * retain first n characters of the match\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    less: function lexer_less(n) {\n      return this.unput(this.match.slice(n));\n    },\n\n    /**\n     * return (part of the) already matched input, i.e. for error\n     * messages.\n     *\n     * Limit the returned string length to `maxSize` (default: 20).\n     *\n     * Limit the returned string to the `maxLines` number of lines of\n     * input (default: 1).\n     *\n     * Negative limit values equal *unlimited*.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    pastInput: function lexer_pastInput(maxSize, maxLines) {\n      var past = this.matched.substring(0, this.matched.length - this.match.length);\n\n      if (maxSize < 0)\n        maxSize = past.length;\n      else if (!maxSize)\n        maxSize = 20;\n\n      if (maxLines < 0)\n        maxLines = past.length;          // can't ever have more input lines than this!\n      else if (!maxLines)\n        maxLines = 1;\n\n      // `substr` anticipation: treat \\r\\n as a single character and take a little\n      // more than necessary so that we can still properly check against maxSize\n      // after we've transformed and limited the newLines in here:\n      past = past.substr(-maxSize * 2 - 2);\n\n      // now that we have a significantly reduced string to process, transform the newlines\n      // and chop them, then limit them:\n      var a = past.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n\n      a = a.slice(-maxLines);\n      past = a.join('\\n');\n\n      // When, after limiting to maxLines, we still have too much to return,\n      // do add an ellipsis prefix...\n      if (past.length > maxSize) {\n        past = '...' + past.substr(-maxSize);\n      }\n\n      return past;\n    },\n\n    /**\n     * return (part of the) upcoming input, i.e. for error messages.\n     *\n     * Limit the returned string length to `maxSize` (default: 20).\n     *\n     * Limit the returned string to the `maxLines` number of lines of input (default: 1).\n     *\n     * Negative limit values equal *unlimited*.\n     *\n     * > ### NOTE ###\n     * >\n     * > *\"upcoming input\"* is defined as the whole of the both\n     * > the *currently lexed* input, together with any remaining input\n     * > following that. *\"currently lexed\"* input is the input\n     * > already recognized by the lexer but not yet returned with\n     * > the lexer token. This happens when you are invoking this API\n     * > from inside any lexer rule action code block.\n     * >\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n      var next = this.match;\n\n      if (maxSize < 0)\n        maxSize = next.length + this._input.length;\n      else if (!maxSize)\n        maxSize = 20;\n\n      if (maxLines < 0)\n        maxLines = maxSize;          // can't ever have more input lines than this!\n      else if (!maxLines)\n        maxLines = 1;\n\n      // `substring` anticipation: treat \\r\\n as a single character and take a little\n      // more than necessary so that we can still properly check against maxSize\n      // after we've transformed and limited the newLines in here:\n      if (next.length < maxSize * 2 + 2) {\n        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8\n      }\n\n      // now that we have a significantly reduced string to process, transform the newlines\n      // and chop them, then limit them:\n      var a = next.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n\n      a = a.slice(0, maxLines);\n      next = a.join('\\n');\n\n      // When, after limiting to maxLines, we still have too much to return,\n      // do add an ellipsis postfix...\n      if (next.length > maxSize) {\n        next = next.substring(0, maxSize) + '...';\n      }\n\n      return next;\n    },\n\n    /**\n     * return a string which displays the character position where the\n     * lexing error occurred, i.e. for error messages\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n      var pre = this.pastInput(maxPrefix).replace(/\\s/g, ' ');\n      var c = new Array(pre.length + 1).join('-');\n      return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, ' ') + '\\n' + c + '^';\n    },\n\n    /**\n     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\n     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\n     * it MAY be NULL) and you MUST have a valid location info object anyway:\n     * then we take the given context of the `preceding` and `following` locations, IFF those are available,\n     * and reconstruct the `actual` location info from those.\n     * If this fails, the heuristic is to take the `current` location, IFF available.\n     * If this fails as well, we assume the sought location is at/around the current lexer position\n     * and then produce that one as a response. DO NOTE that these heuristic/derived location info\n     * values MAY be inaccurate!\n     *\n     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\n     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n      var loc = {\n        first_line: 1,\n        first_column: 0,\n        last_line: 1,\n        last_column: 0,\n        range: [0, 0]\n      };\n\n      if (actual) {\n        loc.first_line = actual.first_line | 0;\n        loc.last_line = actual.last_line | 0;\n        loc.first_column = actual.first_column | 0;\n        loc.last_column = actual.last_column | 0;\n\n        if (actual.range) {\n          loc.range[0] = actual.range[0] | 0;\n          loc.range[1] = actual.range[1] | 0;\n        }\n      }\n\n      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n        // plan B: heuristic using preceding and following:\n        if (loc.first_line <= 0 && preceding) {\n          loc.first_line = preceding.last_line | 0;\n          loc.first_column = preceding.last_column | 0;\n\n          if (preceding.range) {\n            loc.range[0] = actual.range[1] | 0;\n          }\n        }\n\n        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n          loc.last_line = following.first_line | 0;\n          loc.last_column = following.first_column | 0;\n\n          if (following.range) {\n            loc.range[1] = actual.range[0] | 0;\n          }\n        }\n\n        // plan C?: see if the 'current' location is useful/sane too:\n        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n          loc.first_line = current.first_line | 0;\n          loc.first_column = current.first_column | 0;\n\n          if (current.range) {\n            loc.range[0] = current.range[0] | 0;\n          }\n        }\n\n        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n          loc.last_line = current.last_line | 0;\n          loc.last_column = current.last_column | 0;\n\n          if (current.range) {\n            loc.range[1] = current.range[1] | 0;\n          }\n        }\n      }\n\n      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\n      // or plan D heuristics to produce a 'sensible' last_line value:\n      if (loc.last_line <= 0) {\n        if (loc.first_line <= 0) {\n          loc.first_line = this.yylloc.first_line;\n          loc.last_line = this.yylloc.last_line;\n          loc.first_column = this.yylloc.first_column;\n          loc.last_column = this.yylloc.last_column;\n          loc.range[0] = this.yylloc.range[0];\n          loc.range[1] = this.yylloc.range[1];\n        } else {\n          loc.last_line = this.yylloc.last_line;\n          loc.last_column = this.yylloc.last_column;\n          loc.range[1] = this.yylloc.range[1];\n        }\n      }\n\n      if (loc.first_line <= 0) {\n        loc.first_line = loc.last_line;\n        loc.first_column = 0;  // loc.last_column;\n        loc.range[1] = loc.range[0];\n      }\n\n      if (loc.first_column < 0) {\n        loc.first_column = 0;\n      }\n\n      if (loc.last_column < 0) {\n        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);\n      }\n\n      return loc;\n    },\n\n    /**\n     * return a string which displays the lines & columns of input which are referenced\n     * by the given location info range, plus a few lines of context.\n     *\n     * This function pretty-prints the indicated section of the input, with line numbers\n     * and everything!\n     *\n     * This function is very useful to provide highly readable error reports, while\n     * the location range may be specified in various flexible ways:\n     *\n     * - `loc` is the location info object which references the area which should be\n     *   displayed and 'marked up': these lines & columns of text are marked up by `^`\n     *   characters below each character in the entire input range.\n     *\n     * - `context_loc` is the *optional* location info object which instructs this\n     *   pretty-printer how much *leading* context should be displayed alongside\n     *   the area referenced by `loc`. This can help provide context for the displayed\n     *   error, etc.\n     *\n     *   When this location info is not provided, a default context of 3 lines is\n     *   used.\n     *\n     * - `context_loc2` is another *optional* location info object, which serves\n     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\n     *   context lines to display in the pretty-print output.\n     *\n     *   When this location info is not provided, a default context of 1 line only is\n     *   used.\n     *\n     * Special Notes:\n     *\n     * - when the `loc`-indicated range is very large (about 5 lines or more), then\n     *   only the first and last few lines of this block are printed while a\n     *   `...continued...` message will be printed between them.\n     *\n     *   This serves the purpose of not printing a huge amount of text when the `loc`\n     *   range happens to be huge: this way a manageable & readable output results\n     *   for arbitrary large ranges.\n     *\n     * - this function can display lines of input which whave not yet been lexed.\n     *   `prettyPrintRange()` can access the entire input!\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\n      const CONTEXT = 3;\n      const CONTEXT_TAIL = 1;\n      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n      var input = this.matched + this._input;\n      var lines = input.split('\\n');\n      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));\n      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));\n      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\n      var ws_prefix = new Array(lineno_display_width).join(' ');\n      var nonempty_line_indexes = [];\n\n      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n        var lno = index + l0;\n        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n        var rv = lno_pfx + ': ' + line;\n        var errpfx = new Array(lineno_display_width + 1).join('^');\n        var offset = 2 + 1;\n        var len = 0;\n\n        if (lno === loc.first_line) {\n          offset += loc.first_column;\n\n          len = Math.max(\n            2,\n            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1\n          );\n        } else if (lno === loc.last_line) {\n          len = Math.max(2, loc.last_column + 1);\n        } else if (lno > loc.first_line && lno < loc.last_line) {\n          len = Math.max(2, line.length + 1);\n        }\n\n        if (len) {\n          var lead = new Array(offset).join('.');\n          var mark = new Array(len).join('^');\n          rv += '\\n' + errpfx + lead + mark;\n\n          if (line.trim().length > 0) {\n            nonempty_line_indexes.push(index);\n          }\n        }\n\n        rv = rv.replace(/\\t/g, ' ');\n        return rv;\n      });\n\n      // now make sure we don't print an overly large amount of error area: limit it\n      // to the top and bottom line count:\n      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';\n        intermediate_line += '\\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';\n        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n      }\n\n      return rv.join('\\n');\n    },\n\n    /**\n     * helper function, used to produce a human readable description as a string, given\n     * the input `yylloc` location object.\n     *\n     * Set `display_range_too` to TRUE to include the string character index position(s)\n     * in the description if the `yylloc.range` is available.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n      var l1 = yylloc.first_line;\n      var l2 = yylloc.last_line;\n      var c1 = yylloc.first_column;\n      var c2 = yylloc.last_column;\n      var dl = l2 - l1;\n      var dc = c2 - c1;\n      var rv;\n\n      if (dl === 0) {\n        rv = 'line ' + l1 + ', ';\n\n        if (dc <= 1) {\n          rv += 'column ' + c1;\n        } else {\n          rv += 'columns ' + c1 + ' .. ' + c2;\n        }\n      } else {\n        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';\n      }\n\n      if (yylloc.range && display_range_too) {\n        var r1 = yylloc.range[0];\n        var r2 = yylloc.range[1] - 1;\n\n        if (r2 <= r1) {\n          rv += ' {String Offset: ' + r1 + '}';\n        } else {\n          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';\n        }\n      }\n\n      return rv;\n    },\n\n    /**\n     * test the lexed token: return FALSE when not a match, otherwise return token.\n     *\n     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\n     * contains the actually matched text string.\n     *\n     * Also move the input cursor forward and update the match collectors:\n     *\n     * - `yytext`\n     * - `yyleng`\n     * - `match`\n     * - `matches`\n     * - `yylloc`\n     * - `offset`\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    test_match: function lexer_test_match(match, indexed_rule) {\n      var token, lines, backup, match_str, match_str_len;\n\n      if (this.options.backtrack_lexer) {\n        // save context\n        backup = {\n          yylineno: this.yylineno,\n\n          yylloc: {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylloc.last_line,\n            first_column: this.yylloc.first_column,\n            last_column: this.yylloc.last_column,\n            range: this.yylloc.range.slice(0)\n          },\n\n          yytext: this.yytext,\n          match: this.match,\n          matches: this.matches,\n          matched: this.matched,\n          yyleng: this.yyleng,\n          offset: this.offset,\n          _more: this._more,\n          _input: this._input,\n\n          //_signaled_error_token: this._signaled_error_token,\n          yy: this.yy,\n\n          conditionStack: this.conditionStack.slice(0),\n          done: this.done\n        };\n      }\n\n      match_str = match[0];\n      match_str_len = match_str.length;\n\n      // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\n      lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n\n      if (lines.length > 1) {\n        this.yylineno += lines.length - 1;\n        this.yylloc.last_line = this.yylineno + 1;\n        this.yylloc.last_column = lines[lines.length - 1].length;\n      } else {\n        this.yylloc.last_column += match_str_len;\n      }\n\n      // }\n      this.yytext += match_str;\n\n      this.match += match_str;\n      this.matched += match_str;\n      this.matches = match;\n      this.yyleng = this.yytext.length;\n      this.yylloc.range[1] += match_str_len;\n\n      // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n      // those rules will already have moved this `offset` forward matching their match lengths,\n      // hence we must only add our own match length now:\n      this.offset += match_str_len;\n\n      this._more = false;\n      this._backtrack = false;\n      this._input = this._input.slice(match_str_len);\n\n      // calling this method:\n      //\n      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n      token = this.performAction.call(\n        this,\n        this.yy,\n        indexed_rule,\n        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */\n      );\n\n      // otherwise, when the action codes are all simple return token statements:\n      //token = this.simpleCaseActionClusters[indexed_rule];\n\n      if (this.done && this._input) {\n        this.done = false;\n      }\n\n      if (token) {\n        return token;\n      } else if (this._backtrack) {\n        // recover context\n        for (var k in backup) {\n          this[k] = backup[k];\n        }\n\n        this.__currentRuleSet__ = null;\n        return false;  // rule action called reject() implying the next rule should be tested instead.\n      } else if (this._signaled_error_token) {\n        // produce one 'error' token as `.parseError()` in `reject()`\n        // did not guarantee a failure signal by throwing an exception!\n        token = this._signaled_error_token;\n\n        this._signaled_error_token = false;\n        return token;\n      }\n\n      return false;\n    },\n\n    /**\n     * return next match in input\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    next: function lexer_next() {\n      if (this.done) {\n        this.clear();\n        return this.EOF;\n      }\n\n      if (!this._input) {\n        this.done = true;\n      }\n\n      var token, match, tempMatch, index;\n\n      if (!this._more) {\n        this.clear();\n      }\n\n      var spec = this.__currentRuleSet__;\n\n      if (!spec) {\n        // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n        // speed up those activities a tiny bit.\n        spec = this.__currentRuleSet__ = this._currentRules();\n\n        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n        if (!spec || !spec.rules) {\n          var lineno_msg = '';\n\n          if (this.options.trackPosition) {\n            lineno_msg = ' on line ' + (this.yylineno + 1);\n          }\n\n          var p = this.constructLexErrorInfo(\n            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!',\n            false\n          );\n\n          // produce one 'error' token until this situation has been resolved, most probably by parse termination!\n          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n        }\n      }\n\n      var rule_ids = spec.rules;\n      var regexes = spec.__rule_regexes;\n      var len = spec.__rule_count;\n\n      // Note: the arrays are 1-based, while `len` itself is a valid index,\n      // hence the non-standard less-or-equal check in the next loop condition!\n      for (var i = 1; i <= len; i++) {\n        tempMatch = this._input.match(regexes[i]);\n\n        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n          match = tempMatch;\n          index = i;\n\n          if (this.options.backtrack_lexer) {\n            token = this.test_match(tempMatch, rule_ids[i]);\n\n            if (token !== false) {\n              return token;\n            } else if (this._backtrack) {\n              match = undefined;\n              continue;  // rule action called reject() implying a rule MISmatch.\n            } else {\n              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n              return false;\n            }\n          } else if (!this.options.flex) {\n            break;\n          }\n        }\n      }\n\n      if (match) {\n        token = this.test_match(match, rule_ids[index]);\n\n        if (token !== false) {\n          return token;\n        }\n\n        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n        return false;\n      }\n\n      if (!this._input) {\n        this.done = true;\n        this.clear();\n        return this.EOF;\n      } else {\n        var lineno_msg = '';\n\n        if (this.options.trackPosition) {\n          lineno_msg = ' on line ' + (this.yylineno + 1);\n        }\n\n        var p = this.constructLexErrorInfo(\n          'Lexical error' + lineno_msg + ': Unrecognized text.',\n          this.options.lexerErrorsAreRecoverable\n        );\n\n        var pendingInput = this._input;\n        var activeCondition = this.topState();\n        var conditionStackDepth = this.conditionStack.length;\n        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n\n        if (token === this.ERROR) {\n          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\n          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n          // has not consumed/modified any pending input or changed state in the error handler:\n          if (!this.matches && // and make sure the input has been modified/consumed ...\n          pendingInput === this._input && // ...or the lexer state has been modified significantly enough\n          // to merit a non-consuming error handling action right now.\n          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\n            this.input();\n          }\n        }\n\n        return token;\n      }\n    },\n\n    /**\n     * return next match that has a token\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    lex: function lexer_lex() {\n      var r;\n\n      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n      if (typeof this.pre_lex === 'function') {\n        r = this.pre_lex.call(this, 0);\n      }\n\n      if (typeof this.options.pre_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.options.pre_lex.call(this, r) || r;\n      }\n\n      if (this.yy && typeof this.yy.pre_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.yy.pre_lex.call(this, r) || r;\n      }\n\n      while (!r) {\n        r = this.next();\n      }\n\n      if (this.yy && typeof this.yy.post_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.yy.post_lex.call(this, r) || r;\n      }\n\n      if (typeof this.options.post_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.options.post_lex.call(this, r) || r;\n      }\n\n      if (typeof this.post_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.post_lex.call(this, r) || r;\n      }\n\n      return r;\n    },\n\n    /**\n     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the\n     * `pre_lex()` nor any of the `post_lex()` callbacks.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    fastLex: function lexer_fastLex() {\n      var r;\n\n      while (!r) {\n        r = this.next();\n      }\n\n      return r;\n    },\n\n    /**\n     * return info about the lexer state that can help a parser or other lexer API user to use the\n     * most efficient means available. This API is provided to aid run-time performance for larger\n     * systems which employ this lexer.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    canIUse: function lexer_canIUse() {\n      var rv = {\n        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'\n      };\n\n      return rv;\n    },\n\n    /**\n     * backwards compatible alias for `pushState()`;\n     * the latter is symmetrical with `popState()` and we advise to use\n     * those APIs in any modern lexer code, rather than `begin()`.\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    begin: function lexer_begin(condition) {\n      return this.pushState(condition);\n    },\n\n    /**\n     * activates a new lexer condition state (pushes the new lexer\n     * condition state onto the condition stack)\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    pushState: function lexer_pushState(condition) {\n      this.conditionStack.push(condition);\n      this.__currentRuleSet__ = null;\n      return this;\n    },\n\n    /**\n     * pop the previously active lexer condition state off the condition\n     * stack\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    popState: function lexer_popState() {\n      var n = this.conditionStack.length - 1;\n\n      if (n > 0) {\n        this.__currentRuleSet__ = null;\n        return this.conditionStack.pop();\n      } else {\n        return this.conditionStack[0];\n      }\n    },\n\n    /**\n     * return the currently active lexer condition state; when an index\n     * argument is provided it produces the N-th previous condition state,\n     * if available\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    topState: function lexer_topState(n) {\n      n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n      if (n >= 0) {\n        return this.conditionStack[n];\n      } else {\n        return 'INITIAL';\n      }\n    },\n\n    /**\n     * (internal) determine the lexer rule set which is active for the\n     * currently active lexer condition state\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    _currentRules: function lexer__currentRules() {\n      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n      } else {\n        return this.conditions['INITIAL'];\n      }\n    },\n\n    /**\n     * return the number of states currently on the stack\n     *\n     * @public\n     * @this {RegExpLexer}\n     */\n    stateStackSize: function lexer_stateStackSize() {\n      return this.conditionStack.length;\n    },\n\n    options: {\n      trackPosition: true,\n      caseInsensitive: true\n    },\n\n    JisonLexerError: JisonLexerError,\n\n    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\n      var yy_ = this;\n      var YYSTATE = YY_START;\n\n      switch (yyrulenumber) {\n      case 0:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       \\s+ */\n        /* skip whitespace */\n        break;\n\n      case 7:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)em\\b */\n        return 12;      // em\n\n        break;\n\n      case 8:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)ex\\b */\n        return 12;      // ex\n\n        break;\n\n      case 9:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)ch\\b */\n        return 12;      // ch\n\n        break;\n\n      case 10:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)rem\\b */\n        return 12;      // rem\n\n        break;\n\n      case 11:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vw\\b */\n        return 12;      // vw\n\n        break;\n\n      case 12:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vh\\b */\n        return 12;      // vh\n\n        break;\n\n      case 13:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vmin\\b */\n        return 12;      // vmin\n\n        break;\n\n      case 14:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vmax\\b */\n        return 12;      // vmax\n\n        break;\n\n      case 15:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)vm\\b */\n        return 12;      // vm (non-standard name)\n\n        break;\n\n      case 16:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)px\\b */\n        return 12;      // px\n\n        break;\n\n      case 17:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)mm\\b */\n        return 12;      // mm\n\n        break;\n\n      case 18:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)cm\\b */\n        return 12;      // cm\n\n        break;\n\n      case 19:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)in\\b */\n        return 12;      // in\n\n        break;\n\n      case 20:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)pt\\b */\n        return 12;      // pt\n\n        break;\n\n      case 21:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)pc\\b */\n        return 12;      // pc\n\n        break;\n\n      case 22:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)Q\\b */\n        return 12;      // Q\n\n        break;\n\n      case 23:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)fr\\b */\n        return 12;      // fr\n\n        break;\n\n      case 24:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)deg\\b */\n        return 13;       // deg\n\n        break;\n\n      case 25:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)grad\\b */\n        return 13;       // grad\n\n        break;\n\n      case 26:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)turn\\b */\n        return 13;       // turn\n\n        break;\n\n      case 27:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)rad\\b */\n        return 13;       // rad\n\n        break;\n\n      case 28:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)s\\b */\n        return 14;        // s\n\n        break;\n\n      case 29:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)ms\\b */\n        return 14;        // ms\n\n        break;\n\n      case 30:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)Hz\\b */\n        return 15;        // Hz\n\n        break;\n\n      case 31:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)kHz\\b */\n        return 15;        // kHz\n\n        break;\n\n      case 32:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)dpi\\b */\n        return 16;         // dpi\n\n        break;\n\n      case 33:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)dpcm\\b */\n        return 16;         // dpcm\n\n        break;\n\n      case 34:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)dppx\\b */\n        return 16;         // dppm\n\n        break;\n\n      case 39:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       #\\{([\\s\\S]*?)\\} */\n        return 18;  // scss variable\n\n        break;\n\n      case 40:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       @\\{([\\s\\S]*?)\\} */\n        return 18;  // less variable\n\n        break;\n\n      default:\n        return this.simpleCaseActionClusters[yyrulenumber];\n      }\n    },\n\n    simpleCaseActionClusters: {\n      /*! Conditions:: INITIAL */\n      /*! Rule::       (-(webkit|moz)-)?calc\\b */\n      1: 3,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       [a-z][a-z0-9-]*\\s*\\((?:(?:\"(?:\\\\.|[^\\\"\\\\])*\"|'(?:\\\\.|[^\\'\\\\])*')|\\([^)]*\\)|[^\\(\\)]*)*\\) */\n      2: 11,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\* */\n      3: 8,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\/ */\n      4: 9,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\+ */\n      5: 6,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       - */\n      6: 7,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)% */\n      35: 17,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]+)?|\\.[0-9]+)\\b */\n      36: 10,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\( */\n      37: 4,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\) */\n      38: 5,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\S[^\\s()*\\/+-]* */\n      41: 18,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       $ */\n      42: 1\n    },\n\n    rules: [\n      /*  0: */  /^(?:\\s+)/i,\n      /*  1: */  /^(?:(-(webkit|moz)-)?calc\\b)/i,\n      /*  2: */  /^(?:[a-z][\\d\\-a-z]*\\s*\\((?:(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*')|\\([^)]*\\)|[^()]*)*\\))/i,\n      /*  3: */  /^(?:\\*)/i,\n      /*  4: */  /^(?:\\/)/i,\n      /*  5: */  /^(?:\\+)/i,\n      /*  6: */  /^(?:-)/i,\n      /*  7: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)em\\b)/i,\n      /*  8: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)ex\\b)/i,\n      /*  9: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)ch\\b)/i,\n      /* 10: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)rem\\b)/i,\n      /* 11: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vw\\b)/i,\n      /* 12: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vh\\b)/i,\n      /* 13: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vmin\\b)/i,\n      /* 14: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vmax\\b)/i,\n      /* 15: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)vm\\b)/i,\n      /* 16: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)px\\b)/i,\n      /* 17: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)mm\\b)/i,\n      /* 18: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)cm\\b)/i,\n      /* 19: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)in\\b)/i,\n      /* 20: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)pt\\b)/i,\n      /* 21: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)pc\\b)/i,\n      /* 22: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)Q\\b)/i,\n      /* 23: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)fr\\b)/i,\n      /* 24: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)deg\\b)/i,\n      /* 25: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)grad\\b)/i,\n      /* 26: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)turn\\b)/i,\n      /* 27: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)rad\\b)/i,\n      /* 28: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)s\\b)/i,\n      /* 29: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)ms\\b)/i,\n      /* 30: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)Hz\\b)/i,\n      /* 31: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)kHz\\b)/i,\n      /* 32: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)dpi\\b)/i,\n      /* 33: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)dpcm\\b)/i,\n      /* 34: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)dppx\\b)/i,\n      /* 35: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)%)/i,\n      /* 36: */  /^(?:(\\d+(\\.\\d+)?|\\.\\d+)\\b)/i,\n      /* 37: */  /^(?:\\()/i,\n      /* 38: */  /^(?:\\))/i,\n      /* 39: */  /^(?:#\\{([\\s\\S]*?)\\})/i,\n      /* 40: */  /^(?:@\\{([\\s\\S]*?)\\})/i,\n      /* 41: */  /^(?:\\S[^\\s()*\\/+-]*)/i,\n      /* 42: */  /^(?:$)/i\n    ],\n\n    conditions: {\n      'INITIAL': {\n        rules: [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8,\n          9,\n          10,\n          11,\n          12,\n          13,\n          14,\n          15,\n          16,\n          17,\n          18,\n          19,\n          20,\n          21,\n          22,\n          23,\n          24,\n          25,\n          26,\n          27,\n          28,\n          29,\n          30,\n          31,\n          32,\n          33,\n          34,\n          35,\n          36,\n          37,\n          38,\n          39,\n          40,\n          41,\n          42\n        ],\n\n        inclusive: true\n      }\n    }\n  };\n\n  return lexer;\n}();\nparser.lexer = lexer;\n\n\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = parser;\n  exports.Parser = parser.Parser;\n  exports.parse = function () {\n    return parser.parse.apply(parser, arguments);\n  };\n\n}\n"]},"metadata":{},"sourceType":"script"}