{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'value-list-max-empty-lines';\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`\n});\n\nfunction rule(max, options, context) {\n  const maxAdjacentNewlines = max + 1;\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const violatedCRLFNewLinesRegex = new RegExp(`(?:\\r\\n){${maxAdjacentNewlines + 1},}`);\n    const violatedLFNewLinesRegex = new RegExp(`\\n{${maxAdjacentNewlines + 1},}`);\n    const allowedLFNewLinesString = context.fix ? '\\n'.repeat(maxAdjacentNewlines) : '';\n    const allowedCRLFNewLinesString = context.fix ? '\\r\\n'.repeat(maxAdjacentNewlines) : '';\n    root.walkDecls(decl => {\n      const value = decl.raws.value ? decl.raws.value.raw : decl.value;\n\n      if (context.fix) {\n        const newValueString = value.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);\n\n        if (decl.raws.value) {\n          decl.raws.value.raw = newValueString;\n        } else {\n          decl.value = newValueString;\n        }\n      } else if (violatedLFNewLinesRegex.test(value) || violatedCRLFNewLinesRegex.test(value)) {\n        report({\n          message: messages.expected(max),\n          node: decl,\n          index: 0,\n          result,\n          ruleName\n        });\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/value-list-max-empty-lines/index.js"],"names":["_","require","report","ruleMessages","validateOptions","ruleName","messages","expected","max","rule","options","context","maxAdjacentNewlines","root","result","validOptions","actual","possible","isNumber","violatedCRLFNewLinesRegex","RegExp","violatedLFNewLinesRegex","allowedLFNewLinesString","fix","repeat","allowedCRLFNewLinesString","walkDecls","decl","value","raws","raw","newValueString","replace","test","message","node","index","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,6BAAD,CAA/B;;AAEA,MAAMI,QAAQ,GAAG,4BAAjB;AAEA,MAAMC,QAAQ,GAAGH,YAAY,CAACE,QAAD,EAAW;AACvCE,EAAAA,QAAQ,EAAGC,GAAD,IAAU,yBAAwBA,GAAI,UAASA,GAAG,KAAK,CAAR,GAAY,MAAZ,GAAqB,OAAQ;AAD/C,CAAX,CAA7B;;AAIA,SAASC,IAAT,CAAcD,GAAd,EAAmBE,OAAnB,EAA4BC,OAA5B,EAAqC;AACpC,QAAMC,mBAAmB,GAAGJ,GAAG,GAAG,CAAlC;AAEA,SAAO,CAACK,IAAD,EAAOC,MAAP,KAAkB;AACxB,UAAMC,YAAY,GAAGX,eAAe,CAACU,MAAD,EAAST,QAAT,EAAmB;AACtDW,MAAAA,MAAM,EAAER,GAD8C;AAEtDS,MAAAA,QAAQ,EAAEjB,CAAC,CAACkB;AAF0C,KAAnB,CAApC;;AAKA,QAAI,CAACH,YAAL,EAAmB;AAClB;AACA;;AAED,UAAMI,yBAAyB,GAAG,IAAIC,MAAJ,CAAY,YAAWR,mBAAmB,GAAG,CAAE,IAA/C,CAAlC;AACA,UAAMS,uBAAuB,GAAG,IAAID,MAAJ,CAAY,MAAKR,mBAAmB,GAAG,CAAE,IAAzC,CAAhC;AACA,UAAMU,uBAAuB,GAAGX,OAAO,CAACY,GAAR,GAAc,KAAKC,MAAL,CAAYZ,mBAAZ,CAAd,GAAiD,EAAjF;AACA,UAAMa,yBAAyB,GAAGd,OAAO,CAACY,GAAR,GAAc,OAAOC,MAAP,CAAcZ,mBAAd,CAAd,GAAmD,EAArF;AAEAC,IAAAA,IAAI,CAACa,SAAL,CAAgBC,IAAD,IAAU;AACxB,YAAMC,KAAK,GAAGD,IAAI,CAACE,IAAL,CAAUD,KAAV,GAAkBD,IAAI,CAACE,IAAL,CAAUD,KAAV,CAAgBE,GAAlC,GAAwCH,IAAI,CAACC,KAA3D;;AAEA,UAAIjB,OAAO,CAACY,GAAZ,EAAiB;AAChB,cAAMQ,cAAc,GAAGH,KAAK,CAC1BI,OADqB,CACb,IAAIZ,MAAJ,CAAWC,uBAAX,EAAoC,IAApC,CADa,EAC8BC,uBAD9B,EAErBU,OAFqB,CAEb,IAAIZ,MAAJ,CAAWD,yBAAX,EAAsC,IAAtC,CAFa,EAEgCM,yBAFhC,CAAvB;;AAIA,YAAIE,IAAI,CAACE,IAAL,CAAUD,KAAd,EAAqB;AACpBD,UAAAA,IAAI,CAACE,IAAL,CAAUD,KAAV,CAAgBE,GAAhB,GAAsBC,cAAtB;AACA,SAFD,MAEO;AACNJ,UAAAA,IAAI,CAACC,KAAL,GAAaG,cAAb;AACA;AACD,OAVD,MAUO,IAAIV,uBAAuB,CAACY,IAAxB,CAA6BL,KAA7B,KAAuCT,yBAAyB,CAACc,IAA1B,CAA+BL,KAA/B,CAA3C,EAAkF;AACxF1B,QAAAA,MAAM,CAAC;AACNgC,UAAAA,OAAO,EAAE5B,QAAQ,CAACC,QAAT,CAAkBC,GAAlB,CADH;AAEN2B,UAAAA,IAAI,EAAER,IAFA;AAGNS,UAAAA,KAAK,EAAE,CAHD;AAINtB,UAAAA,MAJM;AAKNT,UAAAA;AALM,SAAD,CAAN;AAOA;AACD,KAtBD;AAuBA,GAtCD;AAuCA;;AAEDI,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAI,IAAI,CAACH,QAAL,GAAgBA,QAAhB;AACA+B,MAAM,CAACC,OAAP,GAAiB7B,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'value-list-max-empty-lines';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (max) => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`,\n});\n\nfunction rule(max, options, context) {\n\tconst maxAdjacentNewlines = max + 1;\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: max,\n\t\t\tpossible: _.isNumber,\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst violatedCRLFNewLinesRegex = new RegExp(`(?:\\r\\n){${maxAdjacentNewlines + 1},}`);\n\t\tconst violatedLFNewLinesRegex = new RegExp(`\\n{${maxAdjacentNewlines + 1},}`);\n\t\tconst allowedLFNewLinesString = context.fix ? '\\n'.repeat(maxAdjacentNewlines) : '';\n\t\tconst allowedCRLFNewLinesString = context.fix ? '\\r\\n'.repeat(maxAdjacentNewlines) : '';\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst value = decl.raws.value ? decl.raws.value.raw : decl.value;\n\n\t\t\tif (context.fix) {\n\t\t\t\tconst newValueString = value\n\t\t\t\t\t.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString)\n\t\t\t\t\t.replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);\n\n\t\t\t\tif (decl.raws.value) {\n\t\t\t\t\tdecl.raws.value.raw = newValueString;\n\t\t\t\t} else {\n\t\t\t\t\tdecl.value = newValueString;\n\t\t\t\t}\n\t\t\t} else if (violatedLFNewLinesRegex.test(value) || violatedCRLFNewLinesRegex.test(value)) {\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(max),\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}