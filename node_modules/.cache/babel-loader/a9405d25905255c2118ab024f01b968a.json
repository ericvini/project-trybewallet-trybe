{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = tokenize;\nexports.FIELDS = void 0;\n\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar _unescapable, _wordDelimiters;\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/postcss-selector-parser/dist/tokenize.js"],"names":["exports","__esModule","default","tokenize","FIELDS","t","_interopRequireWildcard","require","_unescapable","_wordDelimiters","obj","newObj","key","Object","prototype","hasOwnProperty","call","desc","defineProperty","getOwnPropertyDescriptor","get","set","unescapable","tab","newline","cr","feed","wordDelimiters","space","ampersand","asterisk","bang","comma","colon","semicolon","openParenthesis","closeParenthesis","openSquare","closeSquare","singleQuote","doubleQuote","plus","pipe","tilde","greaterThan","equals","dollar","caret","slash","hex","hexChars","i","length","charCodeAt","consumeWord","css","start","next","code","backslash","consumeEscape","hexDigits","TYPE","START_LINE","START_COL","END_LINE","END_COL","START_POS","END_POS","input","tokens","valueOf","_css","offset","line","end","content","endColumn","endLine","escaped","escapePos","last","lines","nextLine","nextOffset","quote","tokenType","unclosed","what","fix","safe","error","combinator","indexOf","str","slice","split","comment","word","push"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = tokenize;\nexports.FIELDS = void 0;\n\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar _unescapable, _wordDelimiters;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}"]},"metadata":{},"sourceType":"script"}