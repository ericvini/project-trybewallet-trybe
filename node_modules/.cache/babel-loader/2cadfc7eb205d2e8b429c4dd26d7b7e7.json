{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\n\nconst blockString = require('../../utils/blockString');\n\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\n\nconst isAfterComment = require('../../utils/isAfterComment');\n\nconst isAfterStandardPropertyDeclaration = require('../../utils/isAfterStandardPropertyDeclaration');\n\nconst isCustomProperty = require('../../utils/isCustomProperty');\n\nconst isFirstNested = require('../../utils/isFirstNested');\n\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\n\nconst isSingleLineString = require('../../utils/isSingleLineString');\n\nconst isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'declaration-empty-line-before';\nconst messages = ruleMessages(ruleName, {\n  expected: 'Expected empty line before declaration',\n  rejected: 'Unexpected empty line before declaration'\n});\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never']\n    }, {\n      actual: options,\n      possible: {\n        except: ['first-nested', 'after-comment', 'after-declaration'],\n        ignore: ['after-comment', 'after-declaration', 'first-nested', 'inside-single-line-block']\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop;\n      const parent = decl.parent; // Ignore the first node\n\n      if (isFirstNodeOfRoot(decl)) {\n        return;\n      }\n\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return;\n      }\n\n      if (isCustomProperty(prop)) {\n        return;\n      } // Optionally ignore the node if a comment precedes it\n\n\n      if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(decl)) {\n        return;\n      } // Optionally ignore the node if a declaration precedes it\n\n\n      if (optionsMatches(options, 'ignore', 'after-declaration') && isAfterStandardPropertyDeclaration(decl)) {\n        return;\n      } // Optionally ignore the node if it is the first nested\n\n\n      if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(decl)) {\n        return;\n      } // Optionally ignore nodes inside single-line blocks\n\n\n      if (optionsMatches(options, 'ignore', 'inside-single-line-block') && isSingleLineString(blockString(parent))) {\n        return;\n      }\n\n      let expectEmptyLineBefore = expectation === 'always'; // Optionally reverse the expectation if any exceptions apply\n\n      if (optionsMatches(options, 'except', 'first-nested') && isFirstNested(decl) || optionsMatches(options, 'except', 'after-comment') && isAfterComment(decl) || optionsMatches(options, 'except', 'after-declaration') && isAfterStandardPropertyDeclaration(decl)) {\n        expectEmptyLineBefore = !expectEmptyLineBefore;\n      } // Check for at least one empty line\n\n\n      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before); // Return if the expectation is met\n\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      } // Fix\n\n\n      if (context.fix) {\n        if (expectEmptyLineBefore) {\n          addEmptyLineBefore(decl, context.newline);\n        } else {\n          removeEmptyLinesBefore(decl, context.newline);\n        }\n\n        return;\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n      report({\n        message,\n        node: decl,\n        result,\n        ruleName\n      });\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/declaration-empty-line-before/index.js"],"names":["addEmptyLineBefore","require","blockString","hasEmptyLine","isAfterComment","isAfterStandardPropertyDeclaration","isCustomProperty","isFirstNested","isFirstNodeOfRoot","isSingleLineString","isStandardSyntaxDeclaration","optionsMatches","removeEmptyLinesBefore","report","ruleMessages","validateOptions","ruleName","messages","expected","rejected","rule","expectation","options","context","root","result","validOptions","actual","possible","except","ignore","optional","walkDecls","decl","prop","parent","expectEmptyLineBefore","hasEmptyLineBefore","raws","before","fix","newline","message","node","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst addEmptyLineBefore = require('../../utils/addEmptyLineBefore');\nconst blockString = require('../../utils/blockString');\nconst hasEmptyLine = require('../../utils/hasEmptyLine');\nconst isAfterComment = require('../../utils/isAfterComment');\nconst isAfterStandardPropertyDeclaration = require('../../utils/isAfterStandardPropertyDeclaration');\nconst isCustomProperty = require('../../utils/isCustomProperty');\nconst isFirstNested = require('../../utils/isFirstNested');\nconst isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');\nconst isSingleLineString = require('../../utils/isSingleLineString');\nconst isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'declaration-empty-line-before';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: 'Expected empty line before declaration',\n\trejected: 'Unexpected empty line before declaration',\n});\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: ['always', 'never'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\texcept: ['first-nested', 'after-comment', 'after-declaration'],\n\t\t\t\t\tignore: [\n\t\t\t\t\t\t'after-comment',\n\t\t\t\t\t\t'after-declaration',\n\t\t\t\t\t\t'first-nested',\n\t\t\t\t\t\t'inside-single-line-block',\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst prop = decl.prop;\n\t\t\tconst parent = decl.parent;\n\n\t\t\t// Ignore the first node\n\t\t\tif (isFirstNodeOfRoot(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isStandardSyntaxDeclaration(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isCustomProperty(prop)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if a comment precedes it\n\t\t\tif (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if a declaration precedes it\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'ignore', 'after-declaration') &&\n\t\t\t\tisAfterStandardPropertyDeclaration(decl)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore the node if it is the first nested\n\t\t\tif (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(decl)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Optionally ignore nodes inside single-line blocks\n\t\t\tif (\n\t\t\t\toptionsMatches(options, 'ignore', 'inside-single-line-block') &&\n\t\t\t\tisSingleLineString(blockString(parent))\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet expectEmptyLineBefore = expectation === 'always';\n\n\t\t\t// Optionally reverse the expectation if any exceptions apply\n\t\t\tif (\n\t\t\t\t(optionsMatches(options, 'except', 'first-nested') && isFirstNested(decl)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'after-comment') && isAfterComment(decl)) ||\n\t\t\t\t(optionsMatches(options, 'except', 'after-declaration') &&\n\t\t\t\t\tisAfterStandardPropertyDeclaration(decl))\n\t\t\t) {\n\t\t\t\texpectEmptyLineBefore = !expectEmptyLineBefore;\n\t\t\t}\n\n\t\t\t// Check for at least one empty line\n\t\t\tconst hasEmptyLineBefore = hasEmptyLine(decl.raws.before);\n\n\t\t\t// Return if the expectation is met\n\t\t\tif (expectEmptyLineBefore === hasEmptyLineBefore) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fix\n\t\t\tif (context.fix) {\n\t\t\t\tif (expectEmptyLineBefore) {\n\t\t\t\t\taddEmptyLineBefore(decl, context.newline);\n\t\t\t\t} else {\n\t\t\t\t\tremoveEmptyLinesBefore(decl, context.newline);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n\t\t\treport({ message, node: decl, result, ruleName });\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}