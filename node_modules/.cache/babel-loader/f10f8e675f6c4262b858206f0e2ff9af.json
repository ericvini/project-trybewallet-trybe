{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isOnlyWhitespace = require('../../utils/isOnlyWhitespace');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'no-eol-whitespace';\nconst messages = ruleMessages(ruleName, {\n  rejected: 'Unexpected whitespace at end of line'\n});\nconst whitespacesToReject = new Set([' ', '\\t']);\n\nfunction fixString(str) {\n  return str.replace(/[ \\t]+$/, '');\n}\n\nfunction findErrorStartIndex(lastEOLIndex, string, {\n  ignoreEmptyLines,\n  isRootFirst\n} = {\n  ignoreEmptyLines: false,\n  isRootFirst: false\n}) {\n  const eolWhitespaceIndex = lastEOLIndex - 1; // If the character before newline is not whitespace, ignore\n\n  if (!whitespacesToReject.has(string[eolWhitespaceIndex])) {\n    return -1;\n  }\n\n  if (ignoreEmptyLines) {\n    // If there is only whitespace between the previous newline and\n    // this newline, ignore\n    const beforeNewlineIndex = string.lastIndexOf('\\n', eolWhitespaceIndex);\n\n    if (beforeNewlineIndex >= 0 || isRootFirst) {\n      const line = string.substring(beforeNewlineIndex, eolWhitespaceIndex);\n\n      if (isOnlyWhitespace(line)) {\n        return -1;\n      }\n    }\n  }\n\n  return eolWhitespaceIndex;\n}\n\nfunction rule(on, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: on\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignore: ['empty-lines']\n      }\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const ignoreEmptyLines = optionsMatches(options, 'ignore', 'empty-lines');\n\n    if (context.fix) {\n      fix(root);\n    }\n\n    const rootString = context.fix ? root.toString() : root.source.input.css;\n\n    const reportFromIndex = index => {\n      report({\n        message: messages.rejected,\n        node: root,\n        index,\n        result,\n        ruleName\n      });\n    };\n\n    eachEolWhitespace(rootString, reportFromIndex, true);\n    const errorIndex = findErrorStartIndex(rootString.length, rootString, {\n      ignoreEmptyLines,\n      isRootFirst: true\n    });\n\n    if (errorIndex > -1) {\n      reportFromIndex(errorIndex);\n    }\n    /**\n     * Iterate each whitespace at the end of each line of the given string.\n     * @param {string} string the source code string\n     * @param {Function} callback callback the whitespace index at the end of each line.\n     * @param {boolean} isRootFirst set `true` if the given string is the first token of the root.\n     * @returns {void}\n     */\n\n\n    function eachEolWhitespace(string, callback, isRootFirst) {\n      styleSearch({\n        source: string,\n        target: ['\\n', '\\r'],\n        comments: 'check'\n      }, match => {\n        // TODO: Issue #4985\n        // eslint-disable-next-line no-shadow\n        const errorIndex = findErrorStartIndex(match.startIndex, string, {\n          ignoreEmptyLines,\n          isRootFirst\n        });\n\n        if (errorIndex > -1) {\n          callback(errorIndex);\n        }\n      });\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function fix(root) {\n      let isRootFirst = true;\n      root.walk(node => {\n        fixText(node.raws.before, fixed => {\n          node.raws.before = fixed;\n        }, isRootFirst);\n        isRootFirst = false; // AtRule\n\n        fixText(node.raws.afterName, fixed => {\n          node.raws.afterName = fixed;\n        });\n\n        if (node.raws.params) {\n          fixText(node.raws.params.raw, fixed => {\n            node.raws.params.raw = fixed;\n          });\n        } else {\n          fixText(node.params, fixed => {\n            node.params = fixed;\n          });\n        } // Rule\n\n\n        if (node.raws.selector) {\n          fixText(node.raws.selector.raw, fixed => {\n            node.raws.selector.raw = fixed;\n          });\n        } else {\n          fixText(node.selector, fixed => {\n            node.selector = fixed;\n          });\n        } // AtRule or Rule or Decl\n\n\n        fixText(node.raws.between, fixed => {\n          node.raws.between = fixed;\n        }); // Decl\n\n        if (node.raws.value) {\n          fixText(node.raws.value.raw, fixed => {\n            node.raws.value.raw = fixed;\n          });\n        } else {\n          fixText(node.value, fixed => {\n            node.value = fixed;\n          });\n        } // Comment\n\n\n        fixText(node.raws.left, fixed => {\n          node.raws.left = fixed;\n        });\n\n        if (node.raws.inline) {\n          node.raws.right = fixString(node.raws.right);\n        } else {\n          fixText(node.raws.right, fixed => {\n            node.raws.right = fixed;\n          });\n        }\n\n        fixText(node.text, fixed => {\n          node.text = fixed;\n        });\n        fixText(node.raws.after, fixed => {\n          node.raws.after = fixed;\n        });\n      });\n      fixText(root.raws.after, fixed => {\n        root.raws.after = fixed;\n      }, isRootFirst);\n\n      if (typeof root.raws.after === 'string') {\n        const lastEOL = Math.max(root.raws.after.lastIndexOf('\\n'), root.raws.after.lastIndexOf('\\r'));\n\n        if (lastEOL !== root.raws.after.length - 1) {\n          root.raws.after = root.raws.after.slice(0, lastEOL + 1) + fixString(root.raws.after.slice(lastEOL + 1));\n        }\n      }\n    } // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n\n    function fixText(value, fix, isRootFirst) {\n      if (!value) {\n        return;\n      }\n\n      let fixed = '';\n      let lastIndex = 0;\n      eachEolWhitespace(value, index => {\n        const newlineIndex = index + 1;\n        fixed += fixString(value.slice(lastIndex, newlineIndex));\n        lastIndex = newlineIndex;\n      }, isRootFirst);\n\n      if (lastIndex) {\n        fixed += value.slice(lastIndex);\n        fix(fixed);\n      }\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/no-eol-whitespace/index.js"],"names":["isOnlyWhitespace","require","optionsMatches","report","ruleMessages","styleSearch","validateOptions","ruleName","messages","rejected","whitespacesToReject","Set","fixString","str","replace","findErrorStartIndex","lastEOLIndex","string","ignoreEmptyLines","isRootFirst","eolWhitespaceIndex","has","beforeNewlineIndex","lastIndexOf","line","substring","rule","on","options","context","root","result","validOptions","actual","optional","possible","ignore","fix","rootString","toString","source","input","css","reportFromIndex","index","message","node","eachEolWhitespace","errorIndex","length","callback","target","comments","match","startIndex","walk","fixText","raws","before","fixed","afterName","params","raw","selector","between","value","left","inline","right","text","after","lastEOL","Math","max","slice","lastIndex","newlineIndex","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isOnlyWhitespace = require('../../utils/isOnlyWhitespace');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'no-eol-whitespace';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: 'Unexpected whitespace at end of line',\n});\n\nconst whitespacesToReject = new Set([' ', '\\t']);\n\nfunction fixString(str) {\n\treturn str.replace(/[ \\t]+$/, '');\n}\n\nfunction findErrorStartIndex(\n\tlastEOLIndex,\n\tstring,\n\t{ ignoreEmptyLines, isRootFirst } = {\n\t\tignoreEmptyLines: false,\n\t\tisRootFirst: false,\n\t},\n) {\n\tconst eolWhitespaceIndex = lastEOLIndex - 1;\n\n\t// If the character before newline is not whitespace, ignore\n\tif (!whitespacesToReject.has(string[eolWhitespaceIndex])) {\n\t\treturn -1;\n\t}\n\n\tif (ignoreEmptyLines) {\n\t\t// If there is only whitespace between the previous newline and\n\t\t// this newline, ignore\n\t\tconst beforeNewlineIndex = string.lastIndexOf('\\n', eolWhitespaceIndex);\n\n\t\tif (beforeNewlineIndex >= 0 || isRootFirst) {\n\t\t\tconst line = string.substring(beforeNewlineIndex, eolWhitespaceIndex);\n\n\t\t\tif (isOnlyWhitespace(line)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn eolWhitespaceIndex;\n}\n\nfunction rule(on, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: on,\n\t\t\t},\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignore: ['empty-lines'],\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ignoreEmptyLines = optionsMatches(options, 'ignore', 'empty-lines');\n\n\t\tif (context.fix) {\n\t\t\tfix(root);\n\t\t}\n\n\t\tconst rootString = context.fix ? root.toString() : root.source.input.css;\n\t\tconst reportFromIndex = (index) => {\n\t\t\treport({\n\t\t\t\tmessage: messages.rejected,\n\t\t\t\tnode: root,\n\t\t\t\tindex,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t};\n\n\t\teachEolWhitespace(rootString, reportFromIndex, true);\n\n\t\tconst errorIndex = findErrorStartIndex(rootString.length, rootString, {\n\t\t\tignoreEmptyLines,\n\t\t\tisRootFirst: true,\n\t\t});\n\n\t\tif (errorIndex > -1) {\n\t\t\treportFromIndex(errorIndex);\n\t\t}\n\n\t\t/**\n\t\t * Iterate each whitespace at the end of each line of the given string.\n\t\t * @param {string} string the source code string\n\t\t * @param {Function} callback callback the whitespace index at the end of each line.\n\t\t * @param {boolean} isRootFirst set `true` if the given string is the first token of the root.\n\t\t * @returns {void}\n\t\t */\n\t\tfunction eachEolWhitespace(string, callback, isRootFirst) {\n\t\t\tstyleSearch(\n\t\t\t\t{\n\t\t\t\t\tsource: string,\n\t\t\t\t\ttarget: ['\\n', '\\r'],\n\t\t\t\t\tcomments: 'check',\n\t\t\t\t},\n\t\t\t\t(match) => {\n\t\t\t\t\t// TODO: Issue #4985\n\t\t\t\t\t// eslint-disable-next-line no-shadow\n\t\t\t\t\tconst errorIndex = findErrorStartIndex(match.startIndex, string, {\n\t\t\t\t\t\tignoreEmptyLines,\n\t\t\t\t\t\tisRootFirst,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (errorIndex > -1) {\n\t\t\t\t\t\tcallback(errorIndex);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction fix(root) {\n\t\t\tlet isRootFirst = true;\n\n\t\t\troot.walk((node) => {\n\t\t\t\tfixText(\n\t\t\t\t\tnode.raws.before,\n\t\t\t\t\t(fixed) => {\n\t\t\t\t\t\tnode.raws.before = fixed;\n\t\t\t\t\t},\n\t\t\t\t\tisRootFirst,\n\t\t\t\t);\n\t\t\t\tisRootFirst = false;\n\n\t\t\t\t// AtRule\n\t\t\t\tfixText(node.raws.afterName, (fixed) => {\n\t\t\t\t\tnode.raws.afterName = fixed;\n\t\t\t\t});\n\n\t\t\t\tif (node.raws.params) {\n\t\t\t\t\tfixText(node.raws.params.raw, (fixed) => {\n\t\t\t\t\t\tnode.raws.params.raw = fixed;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tfixText(node.params, (fixed) => {\n\t\t\t\t\t\tnode.params = fixed;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Rule\n\t\t\t\tif (node.raws.selector) {\n\t\t\t\t\tfixText(node.raws.selector.raw, (fixed) => {\n\t\t\t\t\t\tnode.raws.selector.raw = fixed;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tfixText(node.selector, (fixed) => {\n\t\t\t\t\t\tnode.selector = fixed;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// AtRule or Rule or Decl\n\t\t\t\tfixText(node.raws.between, (fixed) => {\n\t\t\t\t\tnode.raws.between = fixed;\n\t\t\t\t});\n\n\t\t\t\t// Decl\n\t\t\t\tif (node.raws.value) {\n\t\t\t\t\tfixText(node.raws.value.raw, (fixed) => {\n\t\t\t\t\t\tnode.raws.value.raw = fixed;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tfixText(node.value, (fixed) => {\n\t\t\t\t\t\tnode.value = fixed;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Comment\n\t\t\t\tfixText(node.raws.left, (fixed) => {\n\t\t\t\t\tnode.raws.left = fixed;\n\t\t\t\t});\n\n\t\t\t\tif (node.raws.inline) {\n\t\t\t\t\tnode.raws.right = fixString(node.raws.right);\n\t\t\t\t} else {\n\t\t\t\t\tfixText(node.raws.right, (fixed) => {\n\t\t\t\t\t\tnode.raws.right = fixed;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfixText(node.text, (fixed) => {\n\t\t\t\t\tnode.text = fixed;\n\t\t\t\t});\n\n\t\t\t\tfixText(node.raws.after, (fixed) => {\n\t\t\t\t\tnode.raws.after = fixed;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfixText(\n\t\t\t\troot.raws.after,\n\t\t\t\t(fixed) => {\n\t\t\t\t\troot.raws.after = fixed;\n\t\t\t\t},\n\t\t\t\tisRootFirst,\n\t\t\t);\n\n\t\t\tif (typeof root.raws.after === 'string') {\n\t\t\t\tconst lastEOL = Math.max(\n\t\t\t\t\troot.raws.after.lastIndexOf('\\n'),\n\t\t\t\t\troot.raws.after.lastIndexOf('\\r'),\n\t\t\t\t);\n\n\t\t\t\tif (lastEOL !== root.raws.after.length - 1) {\n\t\t\t\t\troot.raws.after =\n\t\t\t\t\t\troot.raws.after.slice(0, lastEOL + 1) + fixString(root.raws.after.slice(lastEOL + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\tfunction fixText(value, fix, isRootFirst) {\n\t\t\tif (!value) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet fixed = '';\n\t\t\tlet lastIndex = 0;\n\n\t\t\teachEolWhitespace(\n\t\t\t\tvalue,\n\t\t\t\t(index) => {\n\t\t\t\t\tconst newlineIndex = index + 1;\n\n\t\t\t\t\tfixed += fixString(value.slice(lastIndex, newlineIndex));\n\t\t\t\t\tlastIndex = newlineIndex;\n\t\t\t\t},\n\t\t\t\tisRootFirst,\n\t\t\t);\n\n\t\t\tif (lastIndex) {\n\t\t\t\tfixed += value.slice(lastIndex);\n\t\t\t\tfix(fixed);\n\t\t\t}\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}