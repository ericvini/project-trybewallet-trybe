{"ast":null,"code":"\"use strict\";\n\nconst reNewLine = /(?:\\r?\\n|\\r)/gm;\n\nconst Input = require(\"postcss/lib/input\");\n\nconst Document = require(\"./document\");\n\nconst getSyntax = require(\"./get-syntax\");\n\nconst patch = require(\"./patch-postcss\");\n\nclass LocalFixer {\n  constructor(lines, style) {\n    let line = 0;\n    let column = style.startIndex;\n    lines.some((lineEndIndex, lineNumber) => {\n      if (lineEndIndex >= style.startIndex) {\n        line = lineNumber--;\n\n        if (lineNumber in lines) {\n          column = style.startIndex - lines[lineNumber] - 1;\n        }\n\n        return true;\n      }\n    });\n    this.line = line;\n    this.column = column;\n    this.style = style;\n  }\n\n  object(object) {\n    if (object) {\n      if (object.line === 1) {\n        object.column += this.column;\n      }\n\n      object.line += this.line;\n    }\n  }\n\n  node(node) {\n    this.object(node.source.start);\n    this.object(node.source.end);\n  }\n\n  root(root) {\n    this.node(root);\n    root.walk(node => {\n      this.node(node);\n    });\n  }\n\n  error(error) {\n    if (error && error.name === \"CssSyntaxError\") {\n      this.object(error);\n      this.object(error.input);\n      error.message = error.message.replace(/:\\d+:\\d+:/, \":\" + error.line + \":\" + error.column + \":\");\n    }\n\n    return error;\n  }\n\n  parse(opts) {\n    const style = this.style;\n    const syntax = style.syntax || getSyntax(style.lang, opts);\n    let root = style.root;\n\n    try {\n      root = syntax.parse(style.content, Object.assign({}, opts, {\n        map: false\n      }, style.opts));\n    } catch (error) {\n      if (style.ignoreErrors) {\n        return;\n      } else if (!style.skipConvert) {\n        this.error(error);\n      }\n\n      throw error;\n    }\n\n    if (!style.skipConvert) {\n      this.root(root);\n    }\n\n    root.source.inline = Boolean(style.inline);\n    root.source.lang = style.lang;\n    root.source.syntax = syntax;\n    return root;\n  }\n\n}\n\nfunction docFixer(source, opts) {\n  let match;\n  const lines = [];\n  reNewLine.lastIndex = 0;\n\n  while (match = reNewLine.exec(source)) {\n    lines.push(match.index);\n  }\n\n  lines.push(source.length);\n  return function parseStyle(style) {\n    return new LocalFixer(lines, style).parse(opts);\n  };\n}\n\nfunction parseStyle(source, opts, styles) {\n  patch(Document);\n  const document = new Document();\n  let index = 0;\n\n  if (styles.length) {\n    const parseStyle = docFixer(source, opts);\n    styles.sort((a, b) => a.startIndex - b.startIndex).forEach(style => {\n      const root = parseStyle(style);\n\n      if (root) {\n        root.raws.beforeStart = source.slice(index, style.startIndex);\n\n        if (style.endIndex) {\n          index = style.endIndex;\n        } else {\n          index = style.startIndex + (style.content || root.source.input.css).length;\n        }\n\n        root.document = document;\n        document.nodes.push(root);\n      }\n    });\n  }\n\n  document.raws.afterEnd = index ? source.slice(index) : source;\n  document.source = {\n    input: new Input(source, opts),\n    start: {\n      line: 1,\n      column: 1\n    },\n    opts\n  };\n  return document;\n}\n\nmodule.exports = parseStyle;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/postcss-syntax/parse-style.js"],"names":["reNewLine","Input","require","Document","getSyntax","patch","LocalFixer","constructor","lines","style","line","column","startIndex","some","lineEndIndex","lineNumber","object","node","source","start","end","root","walk","error","name","input","message","replace","parse","opts","syntax","lang","content","Object","assign","map","ignoreErrors","skipConvert","inline","Boolean","docFixer","match","lastIndex","exec","push","index","length","parseStyle","styles","document","sort","a","b","forEach","raws","beforeStart","slice","endIndex","css","nodes","afterEnd","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst reNewLine = /(?:\\r?\\n|\\r)/gm;\nconst Input = require(\"postcss/lib/input\");\nconst Document = require(\"./document\");\nconst getSyntax = require(\"./get-syntax\");\nconst patch = require(\"./patch-postcss\");\n\nclass LocalFixer {\n\tconstructor (lines, style) {\n\t\tlet line = 0;\n\t\tlet column = style.startIndex;\n\t\tlines.some((lineEndIndex, lineNumber) => {\n\t\t\tif (lineEndIndex >= style.startIndex) {\n\t\t\t\tline = lineNumber--;\n\t\t\t\tif (lineNumber in lines) {\n\t\t\t\t\tcolumn = style.startIndex - lines[lineNumber] - 1;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tthis.line = line;\n\t\tthis.column = column;\n\t\tthis.style = style;\n\t}\n\tobject (object) {\n\t\tif (object) {\n\t\t\tif (object.line === 1) {\n\t\t\t\tobject.column += this.column;\n\t\t\t}\n\t\t\tobject.line += this.line;\n\t\t}\n\t}\n\tnode (node) {\n\t\tthis.object(node.source.start);\n\t\tthis.object(node.source.end);\n\t}\n\troot (root) {\n\t\tthis.node(root);\n\t\troot.walk(node => {\n\t\t\tthis.node(node);\n\t\t});\n\t}\n\terror (error) {\n\t\tif (error && error.name === \"CssSyntaxError\") {\n\t\t\tthis.object(error);\n\t\t\tthis.object(error.input);\n\t\t\terror.message = error.message.replace(/:\\d+:\\d+:/, \":\" + error.line + \":\" + error.column + \":\");\n\t\t}\n\t\treturn error;\n\t}\n\tparse (opts) {\n\t\tconst style = this.style;\n\t\tconst syntax = style.syntax || getSyntax(style.lang, opts);\n\t\tlet root = style.root;\n\t\ttry {\n\t\t\troot = syntax.parse(style.content, Object.assign({}, opts, {\n\t\t\t\tmap: false,\n\t\t\t}, style.opts));\n\t\t} catch (error) {\n\t\t\tif (style.ignoreErrors) {\n\t\t\t\treturn;\n\t\t\t} else if (!style.skipConvert) {\n\t\t\t\tthis.error(error);\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t\tif (!style.skipConvert) {\n\t\t\tthis.root(root);\n\t\t}\n\n\t\troot.source.inline = Boolean(style.inline);\n\t\troot.source.lang = style.lang;\n\t\troot.source.syntax = syntax;\n\t\treturn root;\n\t}\n}\n\nfunction docFixer (source, opts) {\n\tlet match;\n\tconst lines = [];\n\treNewLine.lastIndex = 0;\n\twhile ((match = reNewLine.exec(source))) {\n\t\tlines.push(match.index);\n\t}\n\tlines.push(source.length);\n\treturn function parseStyle (style) {\n\t\treturn new LocalFixer(lines, style).parse(opts);\n\t};\n}\n\nfunction parseStyle (source, opts, styles) {\n\tpatch(Document);\n\n\tconst document = new Document();\n\n\tlet index = 0;\n\tif (styles.length) {\n\t\tconst parseStyle = docFixer(source, opts);\n\t\tstyles.sort((a, b) => (\n\t\t\ta.startIndex - b.startIndex\n\t\t)).forEach(style => {\n\t\t\tconst root = parseStyle(style);\n\t\t\tif (root) {\n\t\t\t\troot.raws.beforeStart = source.slice(index, style.startIndex);\n\t\t\t\tif (style.endIndex) {\n\t\t\t\t\tindex = style.endIndex;\n\t\t\t\t} else {\n\t\t\t\t\tindex = style.startIndex + (style.content || root.source.input.css).length;\n\t\t\t\t}\n\t\t\t\troot.document = document;\n\t\t\t\tdocument.nodes.push(root);\n\t\t\t}\n\t\t});\n\t}\n\tdocument.raws.afterEnd = index ? source.slice(index) : source;\n\tdocument.source = {\n\t\tinput: new Input(source, opts),\n\t\tstart: {\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t},\n\t\topts,\n\t};\n\treturn document;\n}\nmodule.exports = parseStyle;\n"]},"metadata":{},"sourceType":"script"}