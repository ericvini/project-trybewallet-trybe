{"ast":null,"code":"import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-ff5147c6.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-04825f30.js';\nimport { S as Schema } from './Schema-2bf2c74e.js';\nimport { w as warn } from './warnings-0e4b70d3.js';\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  _createClass(Anchors, null, [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: {},\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document$1 = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document$1(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document$1(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify$1(value, options) {\n  var doc = new Document$1(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document$1,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify$1\n};\nexport { YAML };","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/yaml/browser/dist/index.js"],"names":["d","defaultTagPrefix","_","_createForOfIteratorHelper","a","_typeof","b","_createClass","c","_classCallCheck","e","_defineProperty","Y","YAMLSyntaxError","T","Type","f","YAMLWarning","g","YAMLSemanticError","h","_slicedToArray","i","YAMLError","j","_inherits","k","_createSuper","parse","parse$1","binaryOptions","boolOptions","intOptions","n","nullOptions","s","strOptions","N","Node","P","Pair","S","Scalar","stringifyString","A","Alias","YAMLSeq","YAMLMap","M","Merge","C","Collection","r","resolveNode","isEmptyPath","t","toJSON","addComment","Schema","w","warn","defaultOptions","anchorPrefix","customTags","indent","indentSeq","keepCstNodes","keepNodeTypes","keepBlobsInJSON","mapAsMap","maxAliasCount","prettyErrors","simpleKeys","version","scalarOptions","binary","opt","Object","assign","bool","int","null","str","documentOptions","schema","merge","tagPrefixes","handle","prefix","stringifyTag","doc","tag","options","priv","match","vocab","concat","replace","p","find","indexOf","dtp","getDefaults","suffix","substr","length","ch","getTagObject","tags","item","filter","format","tagObj","obj","value","_match","identify","class","nodeClass","name","constructor","Error","stringifyProps","node","_ref","anchors","props","anchor","getName","push","default","join","stringify","ctx","onComment","onChompKeep","_ctx$doc","createCtx","aliasNodes","onTagObj","o","prevObjects","Map","createNode","_iterator","_step","done","alias","source","newName","map","err","toString","indentAtStart","Anchors","key","validAnchorNode","createAlias","setAnchor","createMergePair","_this","_len","arguments","sources","Array","_key","items","keys","getNames","getNode","names","includes","resolveNodes","_cstAliases","forEach","resolved","test","prev","visit","listTagNames","parseContents","contents","comments","before","after","body","undefined","spaceBefore","valueRange","msg","errors","res","comment","cc","type","BLANK_LINE","commentBefore","cb","cbNode","resolveTagDirective","directive","_directive$parameters","parameters","some","_msg","resolveYamlDirective","_directive$parameters2","v0","_msg2","warnings","parseDirectives","directives","prevDoc","directiveComments","hasDirectives","error","_msg3","copyTagPrefix","_ref2","assertCollection","Document","directivesEndMarker","add","addIn","path","_delete","delete","deleteIn","defaults","get","keepScalar","getIn","has","hasIn","set","setIn","setSchema","id","toFixed","isArray","cstNode","_node$directives","_node$contents","range","start","end","_error","makePretty","_iterator2","_step2","listNonDefaultTags","defaultPrefix","setTagPrefix","toJSON$1","arg","onAnchor","_this$options","keep","indentStep","anchorNames","aliasCount","count","_iterator3","values","_step3","_step3$value","_res","indentSize","Number","isInteger","JSON","lines","vd","tagNames","unshift","repeat","chompKeep","contentComment","forceBlockIndent","wrapScalars","Document$1","_YAMLDocument","_super","call","parseAllDocuments","src","stream","cstDoc","parseDocument","cst","errMsg","warning","stringify$1","String","YAML","parseCST"],"mappings":"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","sourcesContent":["import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-ff5147c6.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-04825f30.js';\nimport { S as Schema } from './Schema-2bf2c74e.js';\nimport { w as warn } from './warnings-0e4b70d3.js';\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  _createClass(Anchors, null, [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: {},\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document$1 = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document$1(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document$1(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify$1(value, options) {\n  var doc = new Document$1(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document$1,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify$1\n};\n\nexport { YAML };\n"]},"metadata":{},"sourceType":"module"}