{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst findAtRuleContext = require('../../utils/findAtRuleContext');\n\nconst isKeyframeRule = require('../../utils/isKeyframeRule');\n\nconst nodeContextLookup = require('../../utils/nodeContextLookup');\n\nconst normalizeSelector = require('normalize-selector');\n\nconst parseSelector = require('../../utils/parseSelector');\n\nconst report = require('../../utils/report');\n\nconst resolvedNestedSelector = require('postcss-resolve-nested-selector');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'no-duplicate-selectors';\nconst messages = ruleMessages(ruleName, {\n  rejected: (selector, firstDuplicateLine) => `Unexpected duplicate selector \"${selector}\", first used at line ${firstDuplicateLine}`\n});\n\nfunction rule(actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual\n    }, {\n      actual: options,\n      possible: {\n        disallowInList: _.isBoolean\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    const shouldDisallowDuplicateInList = _.get(options, 'disallowInList'); // The top level of this map will be rule sources.\n    // Each source maps to another map, which maps rule parents to a set of selectors.\n    // This ensures that selectors are only checked against selectors\n    // from other rules that share the same parent and the same source.\n\n\n    const selectorContextLookup = nodeContextLookup(); // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    root.walkRules(rule => {\n      if (isKeyframeRule(rule)) {\n        return;\n      }\n\n      const contextSelectorSet = selectorContextLookup.getContext(rule, findAtRuleContext(rule)); // TODO: Issue #4985\n      // eslint-disable-next-line no-shadow\n\n      const resolvedSelectors = rule.selectors.reduce((result, selector) => {\n        return _.union(result, resolvedNestedSelector(selector, rule));\n      }, []);\n      const normalizedSelectorList = resolvedSelectors.map(normalizeSelector); // Sort the selectors list so that the order of the constituents\n      // doesn't matter\n\n      const sortedSelectorList = normalizedSelectorList.slice().sort().join(',');\n      const selectorLine = rule.source.start.line; // Complain if the same selector list occurs twice\n\n      let previousDuplicatePosition; // When `disallowInList` is true, we must parse `sortedSelectorList` into\n      // list items.\n\n      let selectorListParsed = [];\n\n      if (shouldDisallowDuplicateInList) {\n        parseSelector(sortedSelectorList, result, rule, selectors => {\n          selectors.each(s => {\n            const selector = String(s);\n            selectorListParsed.push(selector);\n\n            if (contextSelectorSet.get(selector)) {\n              previousDuplicatePosition = contextSelectorSet.get(selector);\n            }\n          });\n        });\n      } else {\n        previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList);\n      }\n\n      if (previousDuplicatePosition) {\n        // If the selector isn't nested we can use its raw value; otherwise,\n        // we have to approximate something for the message -- which is close enough\n        const isNestedSelector = resolvedSelectors.join(',') !== rule.selectors.join(',');\n        const selectorForMessage = isNestedSelector ? resolvedSelectors.join(', ') : rule.selector;\n        return report({\n          result,\n          ruleName,\n          node: rule,\n          message: messages.rejected(selectorForMessage, previousDuplicatePosition)\n        });\n      }\n\n      const presentedSelectors = new Set();\n      const reportedSelectors = new Set(); // Or complain if one selector list contains the same selector more than once\n\n      rule.selectors.forEach(selector => {\n        const normalized = normalizeSelector(selector);\n\n        if (presentedSelectors.has(normalized)) {\n          if (reportedSelectors.has(normalized)) {\n            return;\n          }\n\n          report({\n            result,\n            ruleName,\n            node: rule,\n            message: messages.rejected(selector, selectorLine)\n          });\n          reportedSelectors.add(normalized);\n        } else {\n          presentedSelectors.add(normalized);\n        }\n      });\n\n      if (shouldDisallowDuplicateInList) {\n        for (let selector of selectorListParsed) {\n          // [selectorLine] will not really be accurate for multi-line\n          // selectors, such as \"bar\" in \"foo,\\nbar {}\".\n          contextSelectorSet.set(selector, selectorLine);\n        }\n      } else {\n        contextSelectorSet.set(sortedSelectorList, selectorLine);\n      }\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/no-duplicate-selectors/index.js"],"names":["_","require","findAtRuleContext","isKeyframeRule","nodeContextLookup","normalizeSelector","parseSelector","report","resolvedNestedSelector","ruleMessages","validateOptions","ruleName","messages","rejected","selector","firstDuplicateLine","rule","actual","options","root","result","validOptions","possible","disallowInList","isBoolean","optional","shouldDisallowDuplicateInList","get","selectorContextLookup","walkRules","contextSelectorSet","getContext","resolvedSelectors","selectors","reduce","union","normalizedSelectorList","map","sortedSelectorList","slice","sort","join","selectorLine","source","start","line","previousDuplicatePosition","selectorListParsed","each","s","String","push","isNestedSelector","selectorForMessage","node","message","presentedSelectors","Set","reportedSelectors","forEach","normalized","has","add","set","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst findAtRuleContext = require('../../utils/findAtRuleContext');\nconst isKeyframeRule = require('../../utils/isKeyframeRule');\nconst nodeContextLookup = require('../../utils/nodeContextLookup');\nconst normalizeSelector = require('normalize-selector');\nconst parseSelector = require('../../utils/parseSelector');\nconst report = require('../../utils/report');\nconst resolvedNestedSelector = require('postcss-resolve-nested-selector');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'no-duplicate-selectors';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: (selector, firstDuplicateLine) =>\n\t\t`Unexpected duplicate selector \"${selector}\", first used at line ${firstDuplicateLine}`,\n});\n\nfunction rule(actual, options) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{ actual },\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tdisallowInList: _.isBoolean,\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst shouldDisallowDuplicateInList = _.get(options, 'disallowInList');\n\n\t\t// The top level of this map will be rule sources.\n\t\t// Each source maps to another map, which maps rule parents to a set of selectors.\n\t\t// This ensures that selectors are only checked against selectors\n\t\t// from other rules that share the same parent and the same source.\n\t\tconst selectorContextLookup = nodeContextLookup();\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (isKeyframeRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst contextSelectorSet = selectorContextLookup.getContext(rule, findAtRuleContext(rule));\n\t\t\t// TODO: Issue #4985\n\t\t\t// eslint-disable-next-line no-shadow\n\t\t\tconst resolvedSelectors = rule.selectors.reduce((result, selector) => {\n\t\t\t\treturn _.union(result, resolvedNestedSelector(selector, rule));\n\t\t\t}, []);\n\n\t\t\tconst normalizedSelectorList = resolvedSelectors.map(normalizeSelector);\n\n\t\t\t// Sort the selectors list so that the order of the constituents\n\t\t\t// doesn't matter\n\t\t\tconst sortedSelectorList = normalizedSelectorList.slice().sort().join(',');\n\n\t\t\tconst selectorLine = rule.source.start.line;\n\n\t\t\t// Complain if the same selector list occurs twice\n\n\t\t\tlet previousDuplicatePosition;\n\t\t\t// When `disallowInList` is true, we must parse `sortedSelectorList` into\n\t\t\t// list items.\n\t\t\tlet selectorListParsed = [];\n\n\t\t\tif (shouldDisallowDuplicateInList) {\n\t\t\t\tparseSelector(sortedSelectorList, result, rule, (selectors) => {\n\t\t\t\t\tselectors.each((s) => {\n\t\t\t\t\t\tconst selector = String(s);\n\n\t\t\t\t\t\tselectorListParsed.push(selector);\n\n\t\t\t\t\t\tif (contextSelectorSet.get(selector)) {\n\t\t\t\t\t\t\tpreviousDuplicatePosition = contextSelectorSet.get(selector);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tpreviousDuplicatePosition = contextSelectorSet.get(sortedSelectorList);\n\t\t\t}\n\n\t\t\tif (previousDuplicatePosition) {\n\t\t\t\t// If the selector isn't nested we can use its raw value; otherwise,\n\t\t\t\t// we have to approximate something for the message -- which is close enough\n\t\t\t\tconst isNestedSelector = resolvedSelectors.join(',') !== rule.selectors.join(',');\n\t\t\t\tconst selectorForMessage = isNestedSelector ? resolvedSelectors.join(', ') : rule.selector;\n\n\t\t\t\treturn report({\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t\tnode: rule,\n\t\t\t\t\tmessage: messages.rejected(selectorForMessage, previousDuplicatePosition),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst presentedSelectors = new Set();\n\t\t\tconst reportedSelectors = new Set();\n\n\t\t\t// Or complain if one selector list contains the same selector more than once\n\t\t\trule.selectors.forEach((selector) => {\n\t\t\t\tconst normalized = normalizeSelector(selector);\n\n\t\t\t\tif (presentedSelectors.has(normalized)) {\n\t\t\t\t\tif (reportedSelectors.has(normalized)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\tmessage: messages.rejected(selector, selectorLine),\n\t\t\t\t\t});\n\t\t\t\t\treportedSelectors.add(normalized);\n\t\t\t\t} else {\n\t\t\t\t\tpresentedSelectors.add(normalized);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (shouldDisallowDuplicateInList) {\n\t\t\t\tfor (let selector of selectorListParsed) {\n\t\t\t\t\t// [selectorLine] will not really be accurate for multi-line\n\t\t\t\t\t// selectors, such as \"bar\" in \"foo,\\nbar {}\".\n\t\t\t\t\tcontextSelectorSet.set(selector, selectorLine);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontextSelectorSet.set(sortedSelectorList, selectorLine);\n\t\t\t}\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}