{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst valueParser = require('postcss-value-parser');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'alpha-value-notation';\nconst messages = ruleMessages(ruleName, {\n  expected: (unfixed, fixed) => `Expected \"${unfixed}\" to be \"${fixed}\"`\n});\nconst ALPHA_PROPS = ['opacity', 'shape-image-threshold'];\nconst ALPHA_FUNCS = ['hsl', 'hsla', 'hwb', 'lab', 'lch', 'rgb', 'rgba'];\n\nfunction rule(primary, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: primary,\n      possible: ['number', 'percentage']\n    }, {\n      actual: options,\n      possible: {\n        exceptProperties: [_.isString, _.isRegExp]\n      },\n      optional: true\n    });\n    if (!validOptions) return;\n    root.walkDecls(decl => {\n      let needsFix = false;\n      const parsedValue = valueParser(getValue(decl));\n      parsedValue.walk(node => {\n        let alpha;\n\n        if (ALPHA_PROPS.includes(decl.prop.toLowerCase())) {\n          alpha = findAlphaInValue(node);\n        } else {\n          if (node.type !== 'function') return;\n          if (!ALPHA_FUNCS.includes(node.value.toLowerCase())) return;\n          alpha = findAlphaInFunction(node);\n        }\n\n        if (!alpha) return;\n        const {\n          value\n        } = alpha;\n        if (!isStandardSyntaxValue(value)) return;\n        if (!isNumber(value) && !isPercentage(value)) return;\n        const optionFuncs = {\n          number: {\n            expFunc: isNumber,\n            fixFunc: asNumber\n          },\n          percentage: {\n            expFunc: isPercentage,\n            fixFunc: asPercentage\n          }\n        };\n        let expectation = primary;\n\n        if (optionsMatches(options, 'exceptProperties', decl.prop)) {\n          expectation = Object.keys(optionFuncs).filter(key => key !== expectation);\n        }\n\n        if (optionFuncs[expectation].expFunc(value)) return;\n        const fixed = optionFuncs[expectation].fixFunc(value);\n        const unfixed = value;\n\n        if (context.fix) {\n          alpha.value = fixed;\n          needsFix = true;\n          return;\n        }\n\n        report({\n          message: messages.expected(unfixed, fixed),\n          node: decl,\n          index: declarationValueIndex(decl) + alpha.sourceIndex,\n          result,\n          ruleName\n        });\n      });\n\n      if (needsFix) {\n        setValue(decl, parsedValue.toString());\n      }\n    });\n  };\n}\n\nfunction asPercentage(value) {\n  return `${Number((value * 100).toPrecision(3))}%`;\n}\n\nfunction asNumber(value) {\n  const {\n    number\n  } = valueParser.unit(value);\n  return Number((number / 100).toPrecision(3));\n}\n\nfunction findAlphaInValue(node) {\n  return node.type === 'word' || node.type === 'function' ? node : false;\n}\n\nfunction findAlphaInFunction(node) {\n  const args = node.nodes.filter(({\n    type\n  }) => type === 'word' || type === 'function');\n  if (args.length === 4) return args[3];\n  return false;\n}\n\nfunction isPercentage(value) {\n  const {\n    unit\n  } = valueParser.unit(value);\n  return unit && unit === '%';\n}\n\nfunction isNumber(value) {\n  const {\n    unit\n  } = valueParser.unit(value);\n  return unit === '';\n}\n\nfunction getValue(decl) {\n  return decl.raws.value ? decl.raws.value.raw : decl.value;\n}\n\nfunction setValue(decl, value) {\n  if (decl.raws.value) decl.raws.value.raw = value;else decl.value = value;\n  return decl;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/alpha-value-notation/index.js"],"names":["_","require","valueParser","declarationValueIndex","isStandardSyntaxValue","optionsMatches","report","ruleMessages","validateOptions","ruleName","messages","expected","unfixed","fixed","ALPHA_PROPS","ALPHA_FUNCS","rule","primary","options","context","root","result","validOptions","actual","possible","exceptProperties","isString","isRegExp","optional","walkDecls","decl","needsFix","parsedValue","getValue","walk","node","alpha","includes","prop","toLowerCase","findAlphaInValue","type","value","findAlphaInFunction","isNumber","isPercentage","optionFuncs","number","expFunc","fixFunc","asNumber","percentage","asPercentage","expectation","Object","keys","filter","key","fix","message","index","sourceIndex","setValue","toString","Number","toPrecision","unit","args","nodes","length","raws","raw","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst valueParser = require('postcss-value-parser');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'alpha-value-notation';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (unfixed, fixed) => `Expected \"${unfixed}\" to be \"${fixed}\"`,\n});\n\nconst ALPHA_PROPS = ['opacity', 'shape-image-threshold'];\nconst ALPHA_FUNCS = ['hsl', 'hsla', 'hwb', 'lab', 'lch', 'rgb', 'rgba'];\n\nfunction rule(primary, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: primary,\n\t\t\t\tpossible: ['number', 'percentage'],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\texceptProperties: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) return;\n\n\t\troot.walkDecls((decl) => {\n\t\t\tlet needsFix = false;\n\t\t\tconst parsedValue = valueParser(getValue(decl));\n\n\t\t\tparsedValue.walk((node) => {\n\t\t\t\tlet alpha;\n\n\t\t\t\tif (ALPHA_PROPS.includes(decl.prop.toLowerCase())) {\n\t\t\t\t\talpha = findAlphaInValue(node);\n\t\t\t\t} else {\n\t\t\t\t\tif (node.type !== 'function') return;\n\n\t\t\t\t\tif (!ALPHA_FUNCS.includes(node.value.toLowerCase())) return;\n\n\t\t\t\t\talpha = findAlphaInFunction(node);\n\t\t\t\t}\n\n\t\t\t\tif (!alpha) return;\n\n\t\t\t\tconst { value } = alpha;\n\n\t\t\t\tif (!isStandardSyntaxValue(value)) return;\n\n\t\t\t\tif (!isNumber(value) && !isPercentage(value)) return;\n\n\t\t\t\tconst optionFuncs = {\n\t\t\t\t\tnumber: {\n\t\t\t\t\t\texpFunc: isNumber,\n\t\t\t\t\t\tfixFunc: asNumber,\n\t\t\t\t\t},\n\t\t\t\t\tpercentage: {\n\t\t\t\t\t\texpFunc: isPercentage,\n\t\t\t\t\t\tfixFunc: asPercentage,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tlet expectation = primary;\n\n\t\t\t\tif (optionsMatches(options, 'exceptProperties', decl.prop)) {\n\t\t\t\t\texpectation = Object.keys(optionFuncs).filter((key) => key !== expectation);\n\t\t\t\t}\n\n\t\t\t\tif (optionFuncs[expectation].expFunc(value)) return;\n\n\t\t\t\tconst fixed = optionFuncs[expectation].fixFunc(value);\n\t\t\t\tconst unfixed = value;\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\talpha.value = fixed;\n\t\t\t\t\tneedsFix = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(unfixed, fixed),\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + alpha.sourceIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (needsFix) {\n\t\t\t\tsetValue(decl, parsedValue.toString());\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction asPercentage(value) {\n\treturn `${Number((value * 100).toPrecision(3))}%`;\n}\n\nfunction asNumber(value) {\n\tconst { number } = valueParser.unit(value);\n\n\treturn Number((number / 100).toPrecision(3));\n}\n\nfunction findAlphaInValue(node) {\n\treturn node.type === 'word' || node.type === 'function' ? node : false;\n}\n\nfunction findAlphaInFunction(node) {\n\tconst args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');\n\n\tif (args.length === 4) return args[3];\n\n\treturn false;\n}\n\nfunction isPercentage(value) {\n\tconst { unit } = valueParser.unit(value);\n\n\treturn unit && unit === '%';\n}\n\nfunction isNumber(value) {\n\tconst { unit } = valueParser.unit(value);\n\n\treturn unit === '';\n}\n\nfunction getValue(decl) {\n\treturn decl.raws.value ? decl.raws.value.raw : decl.value;\n}\n\nfunction setValue(decl, value) {\n\tif (decl.raws.value) decl.raws.value.raw = value;\n\telse decl.value = value;\n\n\treturn decl;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}