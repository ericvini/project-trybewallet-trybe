{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst blockString = require('../../utils/blockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst rawNodeString = require('../../utils/rawNodeString');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-closing-brace-space-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected single space after \"}\"',\n  rejectedAfter: () => 'Unexpected whitespace after \"}\"',\n  expectedAfterSingleLine: () => 'Expected single space after \"}\" of a single-line block',\n  rejectedAfterSingleLine: () => 'Unexpected whitespace after \"}\" of a single-line block',\n  expectedAfterMultiLine: () => 'Expected single space after \"}\" of a multi-line block',\n  rejectedAfterMultiLine: () => 'Unexpected whitespace after \"}\" of a multi-line block'\n});\n\nfunction rule(expectation) {\n  const checker = whitespaceChecker('space', expectation, messages);\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'never', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']\n    });\n\n    if (!validOptions) {\n      return;\n    } // Check both kinds of statements: rules and at-rules\n\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      const nextNode = statement.next();\n\n      if (!nextNode) {\n        return;\n      }\n\n      if (!hasBlock(statement)) {\n        return;\n      }\n\n      let reportIndex = statement.toString().length;\n      let source = rawNodeString(nextNode); // Skip a semicolon at the beginning, if any\n\n      if (source && source.startsWith(';')) {\n        source = source.slice(1);\n        reportIndex++;\n      }\n\n      checker.after({\n        source,\n        index: -1,\n        lineCheckStr: blockString(statement),\n        err: msg => {\n          report({\n            message: msg,\n            node: statement,\n            index: reportIndex,\n            result,\n            ruleName\n          });\n        }\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-closing-brace-space-after/index.js"],"names":["blockString","require","hasBlock","rawNodeString","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","rejectedAfter","expectedAfterSingleLine","rejectedAfterSingleLine","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","checker","root","result","validOptions","actual","possible","walkRules","check","walkAtRules","statement","nextNode","next","reportIndex","toString","length","source","startsWith","slice","after","index","lineCheckStr","err","msg","message","node","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,yBAAD,CAA3B;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMK,eAAe,GAAGL,OAAO,CAAC,6BAAD,CAA/B;;AACA,MAAMM,iBAAiB,GAAGN,OAAO,CAAC,+BAAD,CAAjC;;AAEA,MAAMO,QAAQ,GAAG,iCAAjB;AAEA,MAAMC,QAAQ,GAAGJ,YAAY,CAACG,QAAD,EAAW;AACvCE,EAAAA,aAAa,EAAE,MAAM,iCADkB;AAEvCC,EAAAA,aAAa,EAAE,MAAM,iCAFkB;AAGvCC,EAAAA,uBAAuB,EAAE,MAAM,wDAHQ;AAIvCC,EAAAA,uBAAuB,EAAE,MAAM,wDAJQ;AAKvCC,EAAAA,sBAAsB,EAAE,MAAM,uDALS;AAMvCC,EAAAA,sBAAsB,EAAE,MAAM;AANS,CAAX,CAA7B;;AASA,SAASC,IAAT,CAAcC,WAAd,EAA2B;AAC1B,QAAMC,OAAO,GAAGX,iBAAiB,CAAC,OAAD,EAAUU,WAAV,EAAuBR,QAAvB,CAAjC;AAEA,SAAO,UAAUU,IAAV,EAAgBC,MAAhB,EAAwB;AAC9B,UAAMC,YAAY,GAAGf,eAAe,CAACc,MAAD,EAASZ,QAAT,EAAmB;AACtDc,MAAAA,MAAM,EAAEL,WAD8C;AAEtDM,MAAAA,QAAQ,EAAE,CACT,QADS,EAET,OAFS,EAGT,oBAHS,EAIT,mBAJS,EAKT,mBALS,EAMT,kBANS;AAF4C,KAAnB,CAApC;;AAYA,QAAI,CAACF,YAAL,EAAmB;AAClB;AACA,KAf6B,CAiB9B;;;AACAF,IAAAA,IAAI,CAACK,SAAL,CAAeC,KAAf;AACAN,IAAAA,IAAI,CAACO,WAAL,CAAiBD,KAAjB;;AAEA,aAASA,KAAT,CAAeE,SAAf,EAA0B;AACzB,YAAMC,QAAQ,GAAGD,SAAS,CAACE,IAAV,EAAjB;;AAEA,UAAI,CAACD,QAAL,EAAe;AACd;AACA;;AAED,UAAI,CAAC1B,QAAQ,CAACyB,SAAD,CAAb,EAA0B;AACzB;AACA;;AAED,UAAIG,WAAW,GAAGH,SAAS,CAACI,QAAV,GAAqBC,MAAvC;AACA,UAAIC,MAAM,GAAG9B,aAAa,CAACyB,QAAD,CAA1B,CAZyB,CAczB;;AACA,UAAIK,MAAM,IAAIA,MAAM,CAACC,UAAP,CAAkB,GAAlB,CAAd,EAAsC;AACrCD,QAAAA,MAAM,GAAGA,MAAM,CAACE,KAAP,CAAa,CAAb,CAAT;AACAL,QAAAA,WAAW;AACX;;AAEDZ,MAAAA,OAAO,CAACkB,KAAR,CAAc;AACbH,QAAAA,MADa;AAEbI,QAAAA,KAAK,EAAE,CAAC,CAFK;AAGbC,QAAAA,YAAY,EAAEtC,WAAW,CAAC2B,SAAD,CAHZ;AAIbY,QAAAA,GAAG,EAAGC,GAAD,IAAS;AACbpC,UAAAA,MAAM,CAAC;AACNqC,YAAAA,OAAO,EAAED,GADH;AAENE,YAAAA,IAAI,EAAEf,SAFA;AAGNU,YAAAA,KAAK,EAAEP,WAHD;AAINV,YAAAA,MAJM;AAKNZ,YAAAA;AALM,WAAD,CAAN;AAOA;AAZY,OAAd;AAcA;AACD,GAxDD;AAyDA;;AAEDQ,IAAI,CAACR,QAAL,GAAgBA,QAAhB;AACAQ,IAAI,CAACP,QAAL,GAAgBA,QAAhB;AACAkC,MAAM,CAACC,OAAP,GAAiB5B,IAAjB","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst blockString = require('../../utils/blockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst rawNodeString = require('../../utils/rawNodeString');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-closing-brace-space-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected single space after \"}\"',\n\trejectedAfter: () => 'Unexpected whitespace after \"}\"',\n\texpectedAfterSingleLine: () => 'Expected single space after \"}\" of a single-line block',\n\trejectedAfterSingleLine: () => 'Unexpected whitespace after \"}\" of a single-line block',\n\texpectedAfterMultiLine: () => 'Expected single space after \"}\" of a multi-line block',\n\trejectedAfterMultiLine: () => 'Unexpected whitespace after \"}\" of a multi-line block',\n});\n\nfunction rule(expectation) {\n\tconst checker = whitespaceChecker('space', expectation, messages);\n\n\treturn function (root, result) {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: [\n\t\t\t\t'always',\n\t\t\t\t'never',\n\t\t\t\t'always-single-line',\n\t\t\t\t'never-single-line',\n\t\t\t\t'always-multi-line',\n\t\t\t\t'never-multi-line',\n\t\t\t],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check both kinds of statements: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\tconst nextNode = statement.next();\n\n\t\t\tif (!nextNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!hasBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet reportIndex = statement.toString().length;\n\t\t\tlet source = rawNodeString(nextNode);\n\n\t\t\t// Skip a semicolon at the beginning, if any\n\t\t\tif (source && source.startsWith(';')) {\n\t\t\t\tsource = source.slice(1);\n\t\t\t\treportIndex++;\n\t\t\t}\n\n\t\t\tchecker.after({\n\t\t\t\tsource,\n\t\t\t\tindex: -1,\n\t\t\t\tlineCheckStr: blockString(statement),\n\t\t\t\terr: (msg) => {\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: msg,\n\t\t\t\t\t\tnode: statement,\n\t\t\t\t\t\tindex: reportIndex,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}