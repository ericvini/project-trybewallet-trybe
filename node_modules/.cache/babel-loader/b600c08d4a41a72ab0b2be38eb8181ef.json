{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst balancedMatch = require('balanced-match');\n\nconst isWhitespace = require('../../utils/isWhitespace');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst styleSearch = require('style-search');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-calc-no-unspaced-operator';\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: operator => `Expected single space before \"${operator}\" operator`,\n  expectedAfter: operator => `Expected single space after \"${operator}\" operator`,\n  expectedOperatorBeforeSign: operator => `Expected an operator before sign \"${operator}\"`\n});\n\nfunction rule(actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    function complain(message, node, index) {\n      report({\n        message,\n        node,\n        index,\n        result,\n        ruleName\n      });\n    }\n\n    root.walkDecls(decl => {\n      valueParser(decl.value).walk(node => {\n        if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') {\n          return;\n        }\n\n        const nodeText = valueParser.stringify(node);\n        const parensMatch = balancedMatch('(', ')', nodeText);\n\n        if (!parensMatch) {\n          throw new Error(`No parens match: \"${nodeText}\"`);\n        }\n\n        const rawExpression = parensMatch.body;\n        const expressionIndex = decl.source.start.column + decl.prop.length + (decl.raws.between || '').length + node.sourceIndex;\n        const expression = blurVariables(rawExpression);\n        checkSymbol('+');\n        checkSymbol('-');\n        checkSymbol('*');\n        checkSymbol('/');\n\n        function checkSymbol(symbol) {\n          const styleSearchOptions = {\n            source: expression,\n            target: symbol,\n            functionArguments: 'skip'\n          };\n          styleSearch(styleSearchOptions, match => {\n            const index = match.startIndex; // Deal with signs.\n            // (@ and $ are considered \"digits\" here to allow for variable syntaxes\n            // that permit signs in front of variables, e.g. `-$number`)\n            // As is \".\" to deal with fractional numbers without a leading zero\n\n            if ((symbol === '+' || symbol === '-') && /[\\d@$.]/.test(expression[index + 1])) {\n              const expressionBeforeSign = expression.substr(0, index); // Ignore signs that directly follow a opening bracket\n\n              if (expressionBeforeSign[expressionBeforeSign.length - 1] === '(') {\n                return;\n              } // Ignore signs at the beginning of the expression\n\n\n              if (/^\\s*$/.test(expressionBeforeSign)) {\n                return;\n              } // Otherwise, ensure that there is a real operator preceding them\n\n\n              if (/[*/+-]\\s*$/.test(expressionBeforeSign)) {\n                return;\n              } // And if not, complain\n\n\n              complain(messages.expectedOperatorBeforeSign(symbol), decl, expressionIndex + index);\n              return;\n            }\n\n            const beforeOk = expression[index - 1] === ' ' && !isWhitespace(expression[index - 2]) || newlineBefore(expression, index - 1);\n\n            if (!beforeOk) {\n              complain(messages.expectedBefore(symbol), decl, expressionIndex + index);\n            }\n\n            const afterOk = expression[index + 1] === ' ' && !isWhitespace(expression[index + 2]) || expression[index + 1] === '\\n' || expression.substr(index + 1, 2) === '\\r\\n';\n\n            if (!afterOk) {\n              complain(messages.expectedAfter(symbol), decl, expressionIndex + index);\n            }\n          });\n        }\n      });\n    });\n  };\n}\n\nfunction blurVariables(source) {\n  return source.replace(/[$@][^)\\s]+|#{.+?}/g, '0');\n}\n\nfunction newlineBefore(str, startIndex) {\n  let index = startIndex;\n\n  while (index && isWhitespace(str[index])) {\n    if (str[index] === '\\n') return true;\n    index--;\n  }\n\n  return false;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/function-calc-no-unspaced-operator/index.js"],"names":["balancedMatch","require","isWhitespace","report","ruleMessages","styleSearch","validateOptions","valueParser","ruleName","messages","expectedBefore","operator","expectedAfter","expectedOperatorBeforeSign","rule","actual","root","result","validOptions","complain","message","node","index","walkDecls","decl","value","walk","type","toLowerCase","nodeText","stringify","parensMatch","Error","rawExpression","body","expressionIndex","source","start","column","prop","length","raws","between","sourceIndex","expression","blurVariables","checkSymbol","symbol","styleSearchOptions","target","functionArguments","match","startIndex","test","expressionBeforeSign","substr","beforeOk","newlineBefore","afterOk","replace","str","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst balancedMatch = require('balanced-match');\nconst isWhitespace = require('../../utils/isWhitespace');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst styleSearch = require('style-search');\nconst validateOptions = require('../../utils/validateOptions');\nconst valueParser = require('postcss-value-parser');\n\nconst ruleName = 'function-calc-no-unspaced-operator';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedBefore: (operator) => `Expected single space before \"${operator}\" operator`,\n\texpectedAfter: (operator) => `Expected single space after \"${operator}\" operator`,\n\texpectedOperatorBeforeSign: (operator) => `Expected an operator before sign \"${operator}\"`,\n});\n\nfunction rule(actual) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, { actual });\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction complain(message, node, index) {\n\t\t\treport({ message, node, index, result, ruleName });\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tvalueParser(decl.value).walk((node) => {\n\t\t\t\tif (node.type !== 'function' || node.value.toLowerCase() !== 'calc') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst nodeText = valueParser.stringify(node);\n\t\t\t\tconst parensMatch = balancedMatch('(', ')', nodeText);\n\n\t\t\t\tif (!parensMatch) {\n\t\t\t\t\tthrow new Error(`No parens match: \"${nodeText}\"`);\n\t\t\t\t}\n\n\t\t\t\tconst rawExpression = parensMatch.body;\n\t\t\t\tconst expressionIndex =\n\t\t\t\t\tdecl.source.start.column +\n\t\t\t\t\tdecl.prop.length +\n\t\t\t\t\t(decl.raws.between || '').length +\n\t\t\t\t\tnode.sourceIndex;\n\t\t\t\tconst expression = blurVariables(rawExpression);\n\n\t\t\t\tcheckSymbol('+');\n\t\t\t\tcheckSymbol('-');\n\t\t\t\tcheckSymbol('*');\n\t\t\t\tcheckSymbol('/');\n\n\t\t\t\tfunction checkSymbol(symbol) {\n\t\t\t\t\tconst styleSearchOptions = {\n\t\t\t\t\t\tsource: expression,\n\t\t\t\t\t\ttarget: symbol,\n\t\t\t\t\t\tfunctionArguments: 'skip',\n\t\t\t\t\t};\n\n\t\t\t\t\tstyleSearch(styleSearchOptions, (match) => {\n\t\t\t\t\t\tconst index = match.startIndex;\n\n\t\t\t\t\t\t// Deal with signs.\n\t\t\t\t\t\t// (@ and $ are considered \"digits\" here to allow for variable syntaxes\n\t\t\t\t\t\t// that permit signs in front of variables, e.g. `-$number`)\n\t\t\t\t\t\t// As is \".\" to deal with fractional numbers without a leading zero\n\t\t\t\t\t\tif ((symbol === '+' || symbol === '-') && /[\\d@$.]/.test(expression[index + 1])) {\n\t\t\t\t\t\t\tconst expressionBeforeSign = expression.substr(0, index);\n\n\t\t\t\t\t\t\t// Ignore signs that directly follow a opening bracket\n\t\t\t\t\t\t\tif (expressionBeforeSign[expressionBeforeSign.length - 1] === '(') {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Ignore signs at the beginning of the expression\n\t\t\t\t\t\t\tif (/^\\s*$/.test(expressionBeforeSign)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Otherwise, ensure that there is a real operator preceding them\n\t\t\t\t\t\t\tif (/[*/+-]\\s*$/.test(expressionBeforeSign)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// And if not, complain\n\t\t\t\t\t\t\tcomplain(messages.expectedOperatorBeforeSign(symbol), decl, expressionIndex + index);\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst beforeOk =\n\t\t\t\t\t\t\t(expression[index - 1] === ' ' && !isWhitespace(expression[index - 2])) ||\n\t\t\t\t\t\t\tnewlineBefore(expression, index - 1);\n\n\t\t\t\t\t\tif (!beforeOk) {\n\t\t\t\t\t\t\tcomplain(messages.expectedBefore(symbol), decl, expressionIndex + index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst afterOk =\n\t\t\t\t\t\t\t(expression[index + 1] === ' ' && !isWhitespace(expression[index + 2])) ||\n\t\t\t\t\t\t\texpression[index + 1] === '\\n' ||\n\t\t\t\t\t\t\texpression.substr(index + 1, 2) === '\\r\\n';\n\n\t\t\t\t\t\tif (!afterOk) {\n\t\t\t\t\t\t\tcomplain(messages.expectedAfter(symbol), decl, expressionIndex + index);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction blurVariables(source) {\n\treturn source.replace(/[$@][^)\\s]+|#{.+?}/g, '0');\n}\n\nfunction newlineBefore(str, startIndex) {\n\tlet index = startIndex;\n\n\twhile (index && isWhitespace(str[index])) {\n\t\tif (str[index] === '\\n') return true;\n\n\t\tindex--;\n\t}\n\n\treturn false;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}