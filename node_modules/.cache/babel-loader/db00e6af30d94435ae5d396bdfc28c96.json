{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\n\nconst isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');\n\nconst keywordSets = require('../../reference/keywordSets');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst parseSelector = require('../../utils/parseSelector');\n\nconst report = require('../../utils/report');\n\nconst resolvedNestedSelector = require('postcss-resolve-nested-selector');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst specificity = require('specificity');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-max-specificity';\nconst messages = ruleMessages(ruleName, {\n  // TODO: Issue #4985\n  // eslint-disable-next-line no-shadow\n  expected: (selector, specificity) => `Expected \"${selector}\" to have a specificity no more than \"${specificity}\"`\n}); // Return an array representation of zero specificity. We need a new array each time so that it can mutated\n\nconst zeroSpecificity = () => [0, 0, 0, 0]; // Calculate the sum of given array of specificity arrays\n\n\nconst specificitySum = specificities => {\n  const sum = zeroSpecificity();\n  specificities.forEach(specificityArray => {\n    specificityArray.forEach((value, i) => {\n      sum[i] += value;\n    });\n  });\n  return sum;\n};\n\nfunction rule(max, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: [// TODO: Issue #4985\n      // eslint-disable-next-line no-shadow\n      function (max) {\n        // Check that the max specificity is in the form \"a,b,c\"\n        return /^\\d+,\\d+,\\d+$/.test(max);\n      }]\n    }, {\n      actual: options,\n      possible: {\n        ignoreSelectors: [_.isString, _.isRegExp]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    } // Calculate the specificity of a simple selector (type, attribute, class, ID, or pseudos's own value)\n\n\n    const simpleSpecificity = selector => {\n      if (optionsMatches(options, 'ignoreSelectors', selector)) {\n        return zeroSpecificity();\n      }\n\n      return specificity.calculate(selector)[0].specificityArray;\n    }; // Calculate the the specificity of the most specific direct child\n\n\n    const maxChildSpecificity = node => // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n    node.reduce((max, child) => {\n      const childSpecificity = nodeSpecificity(child); // eslint-disable-line no-use-before-define\n\n      return specificity.compare(childSpecificity, max) === 1 ? childSpecificity : max;\n    }, zeroSpecificity()); // Calculate the specificity of a pseudo selector including own value and children\n\n\n    const pseudoSpecificity = node => {\n      // `node.toString()` includes children which should be processed separately,\n      // so use `node.value` instead\n      const ownValue = node.value;\n      const ownSpecificity = ownValue === ':not' || ownValue === ':matches' ? // :not and :matches don't add specificity themselves, but their children do\n      zeroSpecificity() : simpleSpecificity(ownValue);\n      return specificitySum([ownSpecificity, maxChildSpecificity(node)]);\n    };\n\n    const shouldSkipPseudoClassArgument = node => {\n      // postcss-selector-parser includes the arguments to nth-child() functions\n      // as \"tags\", so we need to ignore them ourselves.\n      // The fake-tag's \"parent\" is actually a selector node, whose parent\n      // should be the :nth-child pseudo node.\n      const parentNode = node.parent.parent;\n\n      if (parentNode && parentNode.value) {\n        const parentNodeValue = parentNode.value;\n        const normalisedParentNode = parentNodeValue.toLowerCase().replace(/:+/, '');\n        return parentNode.type === 'pseudo' && (keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentNode) || keywordSets.linguisticPseudoClasses.has(normalisedParentNode));\n      }\n\n      return false;\n    }; // Calculate the specificity of a node parsed by `postcss-selector-parser`\n\n\n    const nodeSpecificity = node => {\n      if (shouldSkipPseudoClassArgument(node)) {\n        return zeroSpecificity();\n      }\n\n      switch (node.type) {\n        case 'attribute':\n        case 'class':\n        case 'id':\n        case 'tag':\n          return simpleSpecificity(node.toString());\n\n        case 'pseudo':\n          return pseudoSpecificity(node);\n\n        case 'selector':\n          // Calculate the sum of all the direct children\n          return specificitySum(node.map(nodeSpecificity));\n\n        default:\n          return zeroSpecificity();\n      }\n    };\n\n    const maxSpecificityArray = `0,${max}`.split(',').map(parseFloat); // TODO: Issue #4985\n    // eslint-disable-next-line no-shadow\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return;\n      } // Using rule.selectors gets us each selector in the eventuality we have a comma separated set\n\n\n      rule.selectors.forEach(selector => {\n        resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {\n          try {\n            // Skip non-standard syntax selectors\n            if (!isStandardSyntaxSelector(resolvedSelector)) {\n              return;\n            }\n\n            parseSelector(resolvedSelector, result, rule, selectorTree => {\n              // Check if the selector specificity exceeds the allowed maximum\n              if (specificity.compare(maxChildSpecificity(selectorTree), maxSpecificityArray) === 1) {\n                report({\n                  ruleName,\n                  result,\n                  node: rule,\n                  message: messages.expected(resolvedSelector, max),\n                  word: selector\n                });\n              }\n            });\n          } catch (e) {\n            result.warn('Cannot parse selector', {\n              node: rule,\n              stylelintType: 'parseError'\n            });\n          }\n        });\n      });\n    });\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selector-max-specificity/index.js"],"names":["_","require","isStandardSyntaxRule","isStandardSyntaxSelector","keywordSets","optionsMatches","parseSelector","report","resolvedNestedSelector","ruleMessages","specificity","validateOptions","ruleName","messages","expected","selector","zeroSpecificity","specificitySum","specificities","sum","forEach","specificityArray","value","i","rule","max","options","root","result","validOptions","actual","possible","test","ignoreSelectors","isString","isRegExp","optional","simpleSpecificity","calculate","maxChildSpecificity","node","reduce","child","childSpecificity","nodeSpecificity","compare","pseudoSpecificity","ownValue","ownSpecificity","shouldSkipPseudoClassArgument","parentNode","parent","parentNodeValue","normalisedParentNode","toLowerCase","replace","type","aNPlusBNotationPseudoClasses","has","linguisticPseudoClasses","toString","map","maxSpecificityArray","split","parseFloat","walkRules","selectors","resolvedSelector","selectorTree","message","word","e","warn","stylelintType","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');\nconst isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');\nconst keywordSets = require('../../reference/keywordSets');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst parseSelector = require('../../utils/parseSelector');\nconst report = require('../../utils/report');\nconst resolvedNestedSelector = require('postcss-resolve-nested-selector');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst specificity = require('specificity');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'selector-max-specificity';\n\nconst messages = ruleMessages(ruleName, {\n\t// TODO: Issue #4985\n\t// eslint-disable-next-line no-shadow\n\texpected: (selector, specificity) =>\n\t\t`Expected \"${selector}\" to have a specificity no more than \"${specificity}\"`,\n});\n\n// Return an array representation of zero specificity. We need a new array each time so that it can mutated\nconst zeroSpecificity = () => [0, 0, 0, 0];\n\n// Calculate the sum of given array of specificity arrays\nconst specificitySum = (specificities) => {\n\tconst sum = zeroSpecificity();\n\n\tspecificities.forEach((specificityArray) => {\n\t\tspecificityArray.forEach((value, i) => {\n\t\t\tsum[i] += value;\n\t\t});\n\t});\n\n\treturn sum;\n};\n\nfunction rule(max, options) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: max,\n\t\t\t\tpossible: [\n\t\t\t\t\t// TODO: Issue #4985\n\t\t\t\t\t// eslint-disable-next-line no-shadow\n\t\t\t\t\tfunction (max) {\n\t\t\t\t\t\t// Check that the max specificity is in the form \"a,b,c\"\n\t\t\t\t\t\treturn /^\\d+,\\d+,\\d+$/.test(max);\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignoreSelectors: [_.isString, _.isRegExp],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the specificity of a simple selector (type, attribute, class, ID, or pseudos's own value)\n\t\tconst simpleSpecificity = (selector) => {\n\t\t\tif (optionsMatches(options, 'ignoreSelectors', selector)) {\n\t\t\t\treturn zeroSpecificity();\n\t\t\t}\n\n\t\t\treturn specificity.calculate(selector)[0].specificityArray;\n\t\t};\n\n\t\t// Calculate the the specificity of the most specific direct child\n\t\tconst maxChildSpecificity = (node) =>\n\t\t\t// TODO: Issue #4985\n\t\t\t// eslint-disable-next-line no-shadow\n\t\t\tnode.reduce((max, child) => {\n\t\t\t\tconst childSpecificity = nodeSpecificity(child); // eslint-disable-line no-use-before-define\n\n\t\t\t\treturn specificity.compare(childSpecificity, max) === 1 ? childSpecificity : max;\n\t\t\t}, zeroSpecificity());\n\n\t\t// Calculate the specificity of a pseudo selector including own value and children\n\t\tconst pseudoSpecificity = (node) => {\n\t\t\t// `node.toString()` includes children which should be processed separately,\n\t\t\t// so use `node.value` instead\n\t\t\tconst ownValue = node.value;\n\t\t\tconst ownSpecificity =\n\t\t\t\townValue === ':not' || ownValue === ':matches'\n\t\t\t\t\t? // :not and :matches don't add specificity themselves, but their children do\n\t\t\t\t\t  zeroSpecificity()\n\t\t\t\t\t: simpleSpecificity(ownValue);\n\n\t\t\treturn specificitySum([ownSpecificity, maxChildSpecificity(node)]);\n\t\t};\n\n\t\tconst shouldSkipPseudoClassArgument = (node) => {\n\t\t\t// postcss-selector-parser includes the arguments to nth-child() functions\n\t\t\t// as \"tags\", so we need to ignore them ourselves.\n\t\t\t// The fake-tag's \"parent\" is actually a selector node, whose parent\n\t\t\t// should be the :nth-child pseudo node.\n\t\t\tconst parentNode = node.parent.parent;\n\n\t\t\tif (parentNode && parentNode.value) {\n\t\t\t\tconst parentNodeValue = parentNode.value;\n\t\t\t\tconst normalisedParentNode = parentNodeValue.toLowerCase().replace(/:+/, '');\n\n\t\t\t\treturn (\n\t\t\t\t\tparentNode.type === 'pseudo' &&\n\t\t\t\t\t(keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentNode) ||\n\t\t\t\t\t\tkeywordSets.linguisticPseudoClasses.has(normalisedParentNode))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\t// Calculate the specificity of a node parsed by `postcss-selector-parser`\n\t\tconst nodeSpecificity = (node) => {\n\t\t\tif (shouldSkipPseudoClassArgument(node)) {\n\t\t\t\treturn zeroSpecificity();\n\t\t\t}\n\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'attribute':\n\t\t\t\tcase 'class':\n\t\t\t\tcase 'id':\n\t\t\t\tcase 'tag':\n\t\t\t\t\treturn simpleSpecificity(node.toString());\n\t\t\t\tcase 'pseudo':\n\t\t\t\t\treturn pseudoSpecificity(node);\n\t\t\t\tcase 'selector':\n\t\t\t\t\t// Calculate the sum of all the direct children\n\t\t\t\t\treturn specificitySum(node.map(nodeSpecificity));\n\t\t\t\tdefault:\n\t\t\t\t\treturn zeroSpecificity();\n\t\t\t}\n\t\t};\n\n\t\tconst maxSpecificityArray = `0,${max}`.split(',').map(parseFloat);\n\n\t\t// TODO: Issue #4985\n\t\t// eslint-disable-next-line no-shadow\n\t\troot.walkRules((rule) => {\n\t\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Using rule.selectors gets us each selector in the eventuality we have a comma separated set\n\t\t\trule.selectors.forEach((selector) => {\n\t\t\t\tresolvedNestedSelector(selector, rule).forEach((resolvedSelector) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Skip non-standard syntax selectors\n\t\t\t\t\t\tif (!isStandardSyntaxSelector(resolvedSelector)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparseSelector(resolvedSelector, result, rule, (selectorTree) => {\n\t\t\t\t\t\t\t// Check if the selector specificity exceeds the allowed maximum\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tspecificity.compare(maxChildSpecificity(selectorTree), maxSpecificityArray) === 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treport({\n\t\t\t\t\t\t\t\t\truleName,\n\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\t\t\t\tmessage: messages.expected(resolvedSelector, max),\n\t\t\t\t\t\t\t\t\tword: selector,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tresult.warn('Cannot parse selector', {\n\t\t\t\t\t\t\tnode: rule,\n\t\t\t\t\t\t\tstylelintType: 'parseError',\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}