{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');\n\nconst parseSelector = require('../utils/parseSelector');\n\nconst report = require('../utils/report');\n\nconst styleSearch = require('style-search');\n\nmodule.exports = function (options) {\n  options.root.walkRules(rule => {\n    if (!isStandardSyntaxRule(rule)) {\n      return;\n    }\n\n    if (!rule.selector.includes('[') || !rule.selector.includes('=')) {\n      return;\n    }\n\n    let hasFixed = false;\n    const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n    const fixedSelector = parseSelector(selector, options.result, rule, selectorTree => {\n      selectorTree.walkAttributes(attributeNode => {\n        const operator = attributeNode.operator;\n\n        if (!operator) {\n          return;\n        }\n\n        const attributeNodeString = attributeNode.toString();\n        styleSearch({\n          source: attributeNodeString,\n          target: operator\n        }, match => {\n          const index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1;\n          checkOperator(attributeNodeString, index, rule, attributeNode, operator);\n        });\n      });\n    });\n\n    if (hasFixed) {\n      if (!rule.raws.selector) {\n        rule.selector = fixedSelector;\n      } else {\n        rule.raws.selector.raw = fixedSelector;\n      }\n    }\n\n    function checkOperator(source, index, node, attributeNode, operator) {\n      options.locationChecker({\n        source,\n        index,\n        err: m => {\n          if (options.fix && options.fix(attributeNode)) {\n            hasFixed = true;\n            return;\n          }\n\n          report({\n            message: m.replace(options.checkBeforeOperator ? operator[0] : operator[operator.length - 1], operator),\n            node,\n            index: attributeNode.sourceIndex + index,\n            result: options.result,\n            ruleName: options.checkedRuleName\n          });\n        }\n      });\n    }\n  });\n};","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/selectorAttributeOperatorSpaceChecker.js"],"names":["isStandardSyntaxRule","require","parseSelector","report","styleSearch","module","exports","options","root","walkRules","rule","selector","includes","hasFixed","raws","raw","fixedSelector","result","selectorTree","walkAttributes","attributeNode","operator","attributeNodeString","toString","source","target","match","index","checkBeforeOperator","startIndex","endIndex","checkOperator","node","locationChecker","err","m","fix","message","replace","length","sourceIndex","ruleName","checkedRuleName"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');\nconst parseSelector = require('../utils/parseSelector');\nconst report = require('../utils/report');\nconst styleSearch = require('style-search');\n\nmodule.exports = function (options) {\n\toptions.root.walkRules((rule) => {\n\t\tif (!isStandardSyntaxRule(rule)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!rule.selector.includes('[') || !rule.selector.includes('=')) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet hasFixed = false;\n\t\tconst selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;\n\n\t\tconst fixedSelector = parseSelector(selector, options.result, rule, (selectorTree) => {\n\t\t\tselectorTree.walkAttributes((attributeNode) => {\n\t\t\t\tconst operator = attributeNode.operator;\n\n\t\t\t\tif (!operator) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst attributeNodeString = attributeNode.toString();\n\n\t\t\t\tstyleSearch({ source: attributeNodeString, target: operator }, (match) => {\n\t\t\t\t\tconst index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1;\n\n\t\t\t\t\tcheckOperator(attributeNodeString, index, rule, attributeNode, operator);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tif (hasFixed) {\n\t\t\tif (!rule.raws.selector) {\n\t\t\t\trule.selector = fixedSelector;\n\t\t\t} else {\n\t\t\t\trule.raws.selector.raw = fixedSelector;\n\t\t\t}\n\t\t}\n\n\t\tfunction checkOperator(source, index, node, attributeNode, operator) {\n\t\t\toptions.locationChecker({\n\t\t\t\tsource,\n\t\t\t\tindex,\n\t\t\t\terr: (m) => {\n\t\t\t\t\tif (options.fix && options.fix(attributeNode)) {\n\t\t\t\t\t\thasFixed = true;\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: m.replace(\n\t\t\t\t\t\t\toptions.checkBeforeOperator ? operator[0] : operator[operator.length - 1],\n\t\t\t\t\t\t\toperator,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tindex: attributeNode.sourceIndex + index,\n\t\t\t\t\t\tresult: options.result,\n\t\t\t\t\t\truleName: options.checkedRuleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}