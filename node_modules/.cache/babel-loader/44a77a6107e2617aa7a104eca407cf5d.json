{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst _ = require('lodash');\n\nconst blockString = require('../../utils/blockString');\n\nconst hasBlock = require('../../utils/hasBlock');\n\nconst optionsMatches = require('../../utils/optionsMatches');\n\nconst rawNodeString = require('../../utils/rawNodeString');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-closing-brace-newline-after';\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => 'Expected newline after \"}\"',\n  expectedAfterSingleLine: () => 'Expected newline after \"}\" of a single-line block',\n  rejectedAfterSingleLine: () => 'Unexpected whitespace after \"}\" of a single-line block',\n  expectedAfterMultiLine: () => 'Expected newline after \"}\" of a multi-line block',\n  rejectedAfterMultiLine: () => 'Unexpected whitespace after \"}\" of a multi-line block'\n});\n\nfunction rule(expectation, options, context) {\n  const checker = whitespaceChecker('newline', expectation, messages);\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['always', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']\n    }, {\n      actual: options,\n      possible: {\n        ignoreAtRules: [_.isString]\n      },\n      optional: true\n    });\n\n    if (!validOptions) {\n      return;\n    } // Check both kinds of statements: rules and at-rules\n\n\n    root.walkRules(check);\n    root.walkAtRules(check);\n\n    function check(statement) {\n      if (!hasBlock(statement)) {\n        return;\n      }\n\n      if (optionsMatches(options, 'ignoreAtRules', statement.name)) {\n        return;\n      }\n\n      const nextNode = statement.next();\n\n      if (!nextNode) {\n        return;\n      } // Allow an end-of-line comment x spaces after the brace\n\n\n      const nextNodeIsSingleLineComment = nextNode.type === 'comment' && !/[^ ]/.test(nextNode.raws.before || '') && !nextNode.toString().includes('\\n');\n      const nodeToCheck = nextNodeIsSingleLineComment ? nextNode.next() : nextNode;\n\n      if (!nodeToCheck) {\n        return;\n      }\n\n      let reportIndex = statement.toString().length;\n      let source = rawNodeString(nodeToCheck); // Skip a semicolon at the beginning, if any\n\n      if (source && source.startsWith(';')) {\n        source = source.slice(1);\n        reportIndex++;\n      } // Only check one after, because there might be other\n      // spaces handled by the indentation rule\n\n\n      checker.afterOneOnly({\n        source,\n        index: -1,\n        lineCheckStr: blockString(statement),\n        err: msg => {\n          if (context.fix) {\n            if (expectation.startsWith('always')) {\n              const index = nodeToCheck.raws.before.search(/\\r?\\n/);\n\n              if (index >= 0) {\n                nodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);\n              } else {\n                nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n              }\n\n              return;\n            }\n\n            if (expectation.startsWith('never')) {\n              nodeToCheck.raws.before = '';\n              return;\n            }\n          }\n\n          report({\n            message: msg,\n            node: statement,\n            index: reportIndex,\n            result,\n            ruleName\n          });\n        }\n      });\n    }\n  };\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/home/eric/sd-07-project-trybewallet/node_modules/stylelint/lib/rules/block-closing-brace-newline-after/index.js"],"names":["_","require","blockString","hasBlock","optionsMatches","rawNodeString","report","ruleMessages","validateOptions","whitespaceChecker","ruleName","messages","expectedAfter","expectedAfterSingleLine","rejectedAfterSingleLine","expectedAfterMultiLine","rejectedAfterMultiLine","rule","expectation","options","context","checker","root","result","validOptions","actual","possible","ignoreAtRules","isString","optional","walkRules","check","walkAtRules","statement","name","nextNode","next","nextNodeIsSingleLineComment","type","test","raws","before","toString","includes","nodeToCheck","reportIndex","length","source","startsWith","slice","afterOneOnly","index","lineCheckStr","err","msg","fix","search","newline","message","node","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst _ = require('lodash');\nconst blockString = require('../../utils/blockString');\nconst hasBlock = require('../../utils/hasBlock');\nconst optionsMatches = require('../../utils/optionsMatches');\nconst rawNodeString = require('../../utils/rawNodeString');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\nconst whitespaceChecker = require('../../utils/whitespaceChecker');\n\nconst ruleName = 'block-closing-brace-newline-after';\n\nconst messages = ruleMessages(ruleName, {\n\texpectedAfter: () => 'Expected newline after \"}\"',\n\texpectedAfterSingleLine: () => 'Expected newline after \"}\" of a single-line block',\n\trejectedAfterSingleLine: () => 'Unexpected whitespace after \"}\" of a single-line block',\n\texpectedAfterMultiLine: () => 'Expected newline after \"}\" of a multi-line block',\n\trejectedAfterMultiLine: () => 'Unexpected whitespace after \"}\" of a multi-line block',\n});\n\nfunction rule(expectation, options, context) {\n\tconst checker = whitespaceChecker('newline', expectation, messages);\n\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(\n\t\t\tresult,\n\t\t\truleName,\n\t\t\t{\n\t\t\t\tactual: expectation,\n\t\t\t\tpossible: [\n\t\t\t\t\t'always',\n\t\t\t\t\t'always-single-line',\n\t\t\t\t\t'never-single-line',\n\t\t\t\t\t'always-multi-line',\n\t\t\t\t\t'never-multi-line',\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tactual: options,\n\t\t\t\tpossible: {\n\t\t\t\t\tignoreAtRules: [_.isString],\n\t\t\t\t},\n\t\t\t\toptional: true,\n\t\t\t},\n\t\t);\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check both kinds of statements: rules and at-rules\n\t\troot.walkRules(check);\n\t\troot.walkAtRules(check);\n\n\t\tfunction check(statement) {\n\t\t\tif (!hasBlock(statement)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (optionsMatches(options, 'ignoreAtRules', statement.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextNode = statement.next();\n\n\t\t\tif (!nextNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Allow an end-of-line comment x spaces after the brace\n\t\t\tconst nextNodeIsSingleLineComment =\n\t\t\t\tnextNode.type === 'comment' &&\n\t\t\t\t!/[^ ]/.test(nextNode.raws.before || '') &&\n\t\t\t\t!nextNode.toString().includes('\\n');\n\n\t\t\tconst nodeToCheck = nextNodeIsSingleLineComment ? nextNode.next() : nextNode;\n\n\t\t\tif (!nodeToCheck) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet reportIndex = statement.toString().length;\n\t\t\tlet source = rawNodeString(nodeToCheck);\n\n\t\t\t// Skip a semicolon at the beginning, if any\n\t\t\tif (source && source.startsWith(';')) {\n\t\t\t\tsource = source.slice(1);\n\t\t\t\treportIndex++;\n\t\t\t}\n\n\t\t\t// Only check one after, because there might be other\n\t\t\t// spaces handled by the indentation rule\n\t\t\tchecker.afterOneOnly({\n\t\t\t\tsource,\n\t\t\t\tindex: -1,\n\t\t\t\tlineCheckStr: blockString(statement),\n\t\t\t\terr: (msg) => {\n\t\t\t\t\tif (context.fix) {\n\t\t\t\t\t\tif (expectation.startsWith('always')) {\n\t\t\t\t\t\t\tconst index = nodeToCheck.raws.before.search(/\\r?\\n/);\n\n\t\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\t\tnodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expectation.startsWith('never')) {\n\t\t\t\t\t\t\tnodeToCheck.raws.before = '';\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treport({\n\t\t\t\t\t\tmessage: msg,\n\t\t\t\t\t\tnode: statement,\n\t\t\t\t\t\tindex: reportIndex,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\truleName,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t};\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}